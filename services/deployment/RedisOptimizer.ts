/**
 * Redis Production Optimizer
 * 
 * Configures Redis with optimized memory and persistence settings
 * and tunes Redis for high-frequency trading operations with minimal latency.
 */

import { EventEmitter } from 'events';
import { execSync, spawn, ChildProcess } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';

export interface RedisOptimizationConfig {
  // Memory optimization
  maxMemory: string; // e.g., "2gb"
  maxMemoryPolicy: 'allkeys-lru' | 'volatile-lru' | 'allkeys-lfu' | 'volatile-lfu' | 'noeviction';
  
  // Persistence optimization
  save: string[]; // e.g., ["900 1", "300 10", "60 10000"]
  appendOnly: boolean;
  appendFsync: 'always' | 'everysec' | 'no';
  
  // Network optimization
  tcpKeepalive: number; // seconds
  timeout: number; // seconds
  tcpBacklog: number;
  
  // Performance optimization
  databases: number;
  hashMaxZiplistEntries: number;
  hashMaxZiplistValue: number;
  listMaxZiplistSize: number;
  setMaxIntsetEntries: number;
  zsetMaxZiplistEntries: number;
  zsetMaxZiplistValue: number;
  
  // High-frequency trading specific
  lazyfreeLazyEviction: boolean;
  lazyfreeLazyExpire: boolean;
  lazyfreeLazyServerDel: boolean;
  replicaLazyFlush: boolean;
  
  // Monitoring
  slowlogLogSlowerThan: number; // microseconds
  slowlogMaxLen: number;
}

export interface RedisMetrics {
  memory: {
    used: number;
    peak: number;
    fragmentation: number;
    efficiency: number;
  };
  performance: {
    commandsPerSecond: number;
    hitRate: number;
    missRate: number;
    avgLatency: number;
  };
  persistence: {
    lastSave: Date;
    changesSinceSave: number;
    aofSize: number;
  };
  connections: {
    connected: number;
    blocked: number;
    rejected: number;
  };
}

export interface RedisHealthCheck {
  status: 'healthy' | 'warning' | 'critical';
  checks: {
    connectivity: boolean;
    memory: boolean;
    performance: boolean;
    persistence: boolean;
  };
  issues: string[];
  recommendations: string[];
}

/**
 * Redis Production Optimizer
 * 
 * Implements production-grade optimizations for Redis including:
 * - Memory management and eviction policies
 * - Persistence configuration for durability vs performance
 * - Network and connection optimization
 * - High-frequency trading specific tuning
 */
export class RedisOptimizer extends EventEmitter {
  private config: RedisOptimizationConfig;
  private redisProcess?: ChildProcess;
  private configPath: string;
  private dataDir: string;
  private logPath: string;
  private pidPath: string;
  private isRunning: boolean = false;

  constructor(config: RedisOptimizationConfig, dataDir: string = '/var/lib/redis') {
    super();
    this.config = config;
    this.dataDir = dataDir;
    this.configPath = path.join(dataDir, 'redis.conf');
    this.logPath = path.join(dataDir, 'redis.log');
    this.pidPath = path.join(dataDir, 'redis.pid');
  }

  /**
   * Apply Redis optimizations and start Redis server
   */
  async applyOptimizations(): Promise<void> {
    try {
      // Ensure data directory exists
      await this.ensureDataDirectory();
      
      // Generate optimized Redis configuration
      await this.generateRedisConfig();
      
      // Apply system-level optimizations
      await this.applySystemOptimizations();
      
      // Start Redis with optimized configuration
      await this.startRedis();
      
      // Verify optimizations
      await this.verifyOptimizations();
      
      this.emit('optimizations-applied', {
        timestamp: new Date(),
        config: this.config,
        configPath: this.configPath
      });
    } catch (error) {
      this.emit('optimization-error', {
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date()
      });
      throw error;
    }
  }

  /**
   * Generate optimized Redis configuration file
   */
  private async generateRedisConfig(): Promise<void> {
    const configContent = this.buildRedisConfig();
    await fs.writeFile(this.configPath, configContent, 'utf8');
    
    this.emit('config-generated', {
      path: this.configPath,
      timestamp: new Date()
    });
  }

  /**
   * Build Redis configuration content
   */
  private buildRedisConfig(): string {
    const config = [
      '# Redis Production Configuration - Generated by RedisOptimizer',
      `# Generated at: ${new Date().toISOString()}`,
      '',
      '# Basic Configuration',
      `port 6379`,
      `bind 127.0.0.1`,
      `timeout ${this.config.timeout}`,
      `tcp-keepalive ${this.config.tcpKeepalive}`,
      `tcp-backlog ${this.config.tcpBacklog}`,
      `databases ${this.config.databases}`,
      '',
      '# Memory Management',
      `maxmemory ${this.config.maxMemory}`,
      `maxmemory-policy ${this.config.maxMemoryPolicy}`,
      '',
      '# Persistence Configuration',
      ...this.config.save.map(saveRule => `save ${saveRule}`),
      `appendonly ${this.config.appendOnly ? 'yes' : 'no'}`,
      `appendfsync ${this.config.appendFsync}`,
      '',
      '# Data Structure Optimization',
      `hash-max-ziplist-entries ${this.config.hashMaxZiplistEntries}`,
      `hash-max-ziplist-value ${this.config.hashMaxZiplistValue}`,
      `list-max-ziplist-size ${this.config.listMaxZiplistSize}`,
      `set-max-intset-entries ${this.config.setMaxIntsetEntries}`,
      `zset-max-ziplist-entries ${this.config.zsetMaxZiplistEntries}`,
      `zset-max-ziplist-value ${this.config.zsetMaxZiplistValue}`,
      '',
      '# High-Frequency Trading Optimizations',
      `lazyfree-lazy-eviction ${this.config.lazyfreeLazyEviction ? 'yes' : 'no'}`,
      `lazyfree-lazy-expire ${this.config.lazyfreeLazyExpire ? 'yes' : 'no'}`,
      `lazyfree-lazy-server-del ${this.config.lazyfreeLazyServerDel ? 'yes' : 'no'}`,
      `replica-lazy-flush ${this.config.replicaLazyFlush ? 'yes' : 'no'}`,
      '',
      '# Monitoring and Logging',
      `slowlog-log-slower-than ${this.config.slowlogLogSlowerThan}`,
      `slowlog-max-len ${this.config.slowlogMaxLen}`,
      `logfile ${this.logPath}`,
      `pidfile ${this.pidPath}`,
      `dir ${this.dataDir}`,
      '',
      '# Security',
      'protected-mode yes',
      '',
      '# Performance Tuning',
      'stop-writes-on-bgsave-error no',
      'rdbcompression yes',
      'rdbchecksum yes',
      'auto-aof-rewrite-percentage 100',
      'auto-aof-rewrite-min-size 64mb',
      'aof-load-truncated yes',
      'aof-use-rdb-preamble yes',
      '',
      '# Client Configuration',
      'client-output-buffer-limit normal 0 0 0',
      'client-output-buffer-limit replica 256mb 64mb 60',
      'client-output-buffer-limit pubsub 32mb 8mb 60',
      '',
      '# Advanced Configuration',
      'hz 10',
      'dynamic-hz yes',
      'aof-rewrite-incremental-fsync yes',
      'rdb-save-incremental-fsync yes'
    ];
    
    return config.join('\n') + '\n';
  }

  /**
   * Apply system-level optimizations for Redis
   */
  private async applySystemOptimizations(): Promise<void> {
    try {
      // Disable transparent huge pages (THP) for better memory management
      execSync('echo never > /sys/kernel/mm/transparent_hugepage/enabled', { stdio: 'ignore' });
      
      // Set vm.overcommit_memory to 1 for Redis
      execSync('sysctl vm.overcommit_memory=1', { stdio: 'ignore' });
      
      // Increase somaxconn for better connection handling
      execSync('sysctl net.core.somaxconn=65535', { stdio: 'ignore' });
      
      // Optimize TCP settings for low latency
      execSync('sysctl net.ipv4.tcp_keepalive_time=120', { stdio: 'ignore' });
      execSync('sysctl net.ipv4.tcp_keepalive_intvl=30', { stdio: 'ignore' });
      execSync('sysctl net.ipv4.tcp_keepalive_probes=3', { stdio: 'ignore' });
      
      this.emit('system-optimizations-applied', {
        timestamp: new Date()
      });
    } catch (error) {
      // Log warning but don't fail - some optimizations may require root
      this.emit('system-optimization-warning', {
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date()
      });
    }
  }

  /**
   * Start Redis server with optimized configuration
   */
  private async startRedis(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.redisProcess = spawn('redis-server', [this.configPath], {
        stdio: ['ignore', 'pipe', 'pipe'],
        detached: false
      });
      
      let startupOutput = '';
      
      this.redisProcess.stdout?.on('data', (data) => {
        startupOutput += data.toString();
        if (startupOutput.includes('Ready to accept connections')) {
          this.isRunning = true;
          this.emit('redis-started', {
            pid: this.redisProcess?.pid,
            timestamp: new Date()
          });
          resolve();
        }
      });
      
      this.redisProcess.stderr?.on('data', (data) => {
        const error = data.toString();
        this.emit('redis-error', {
          error,
          timestamp: new Date()
        });
      });
      
      this.redisProcess.on('error', (error) => {
        this.isRunning = false;
        reject(error);
      });
      
      this.redisProcess.on('exit', (code) => {
        this.isRunning = false;
        this.emit('redis-stopped', {
          exitCode: code,
          timestamp: new Date()
        });
      });
      
      // Timeout after 30 seconds
      setTimeout(() => {
        if (!this.isRunning) {
          reject(new Error('Redis startup timeout'));
        }
      }, 30000);
    });
  }

  /**
   * Verify Redis optimizations are applied correctly
   */
  private async verifyOptimizations(): Promise<void> {
    try {
      // Test Redis connectivity
      const pingResult = execSync('redis-cli ping', { encoding: 'utf8' }).trim();
      if (pingResult !== 'PONG') {
        throw new Error('Redis connectivity test failed');
      }
      
      // Verify configuration settings
      const configCheck = execSync('redis-cli CONFIG GET maxmemory', { encoding: 'utf8' });
      if (!configCheck.includes(this.config.maxMemory)) {
        throw new Error('Redis configuration verification failed');
      }
      
      this.emit('optimizations-verified', {
        timestamp: new Date()
      });
    } catch (error) {
      throw new Error(`Redis optimization verification failed: ${error}`);
    }
  }

  /**
   * Get Redis performance metrics
   */
  async getMetrics(): Promise<RedisMetrics> {
    try {
      const info = execSync('redis-cli INFO', { encoding: 'utf8' });
      return this.parseRedisInfo(info);
    } catch (error) {
      throw new Error(`Failed to get Redis metrics: ${error}`);
    }
  }

  /**
   * Parse Redis INFO output into structured metrics
   */
  private parseRedisInfo(info: string): RedisMetrics {
    const lines = info.split('\n');
    const data: Record<string, string> = {};
    
    for (const line of lines) {
      if (line.includes(':')) {
        const [key, value] = line.split(':');
        data[key] = value.trim();
      }
    }
    
    return {
      memory: {
        used: parseInt(data.used_memory || '0'),
        peak: parseInt(data.used_memory_peak || '0'),
        fragmentation: parseFloat(data.mem_fragmentation_ratio || '1.0'),
        efficiency: parseFloat(data.mem_efficiency || '100.0')
      },
      performance: {
        commandsPerSecond: parseFloat(data.instantaneous_ops_per_sec || '0'),
        hitRate: parseFloat(data.keyspace_hits || '0') / 
                 (parseFloat(data.keyspace_hits || '0') + parseFloat(data.keyspace_misses || '1')) * 100,
        missRate: parseFloat(data.keyspace_misses || '0') / 
                  (parseFloat(data.keyspace_hits || '1') + parseFloat(data.keyspace_misses || '0')) * 100,
        avgLatency: parseFloat(data.avg_ttl || '0')
      },
      persistence: {
        lastSave: new Date(parseInt(data.rdb_last_save_time || '0') * 1000),
        changesSinceSave: parseInt(data.rdb_changes_since_last_save || '0'),
        aofSize: parseInt(data.aof_current_size || '0')
      },
      connections: {
        connected: parseInt(data.connected_clients || '0'),
        blocked: parseInt(data.blocked_clients || '0'),
        rejected: parseInt(data.rejected_connections || '0')
      }
    };
  }

  /**
   * Perform Redis health check
   */
  async performHealthCheck(): Promise<RedisHealthCheck> {
    const issues: string[] = [];
    const recommendations: string[] = [];
    
    try {
      const metrics = await this.getMetrics();
      
      // Check connectivity
      const connectivityOk = this.isRunning;
      if (!connectivityOk) {
        issues.push('Redis server is not running');
      }
      
      // Check memory usage
      const memoryOk = metrics.memory.fragmentation < 1.5;
      if (!memoryOk) {
        issues.push(`High memory fragmentation: ${metrics.memory.fragmentation.toFixed(2)}`);
        recommendations.push('Consider restarting Redis to defragment memory');
      }
      
      // Check performance
      const performanceOk = metrics.performance.hitRate > 90;
      if (!performanceOk) {
        issues.push(`Low cache hit rate: ${metrics.performance.hitRate.toFixed(2)}%`);
        recommendations.push('Review cache key patterns and TTL settings');
      }
      
      // Check persistence
      const persistenceOk = Date.now() - metrics.persistence.lastSave.getTime() < 3600000; // 1 hour
      if (!persistenceOk) {
        issues.push('Last save was more than 1 hour ago');
        recommendations.push('Check persistence configuration and disk space');
      }
      
      const allChecksOk = connectivityOk && memoryOk && performanceOk && persistenceOk;
      
      return {
        status: allChecksOk ? 'healthy' : issues.length > 2 ? 'critical' : 'warning',
        checks: {
          connectivity: connectivityOk,
          memory: memoryOk,
          performance: performanceOk,
          persistence: persistenceOk
        },
        issues,
        recommendations
      };
    } catch (error) {
      return {
        status: 'critical',
        checks: {
          connectivity: false,
          memory: false,
          performance: false,
          persistence: false
        },
        issues: [`Health check failed: ${error}`],
        recommendations: ['Check Redis server status and configuration']
      };
    }
  }

  /**
   * Optimize Redis for high-frequency operations
   */
  async optimizeForHighFrequency(): Promise<void> {
    try {
      // Disable slow operations
      execSync('redis-cli CONFIG SET stop-writes-on-bgsave-error no', { stdio: 'ignore' });
      
      // Optimize for speed over durability (use with caution)
      execSync('redis-cli CONFIG SET appendfsync no', { stdio: 'ignore' });
      
      // Increase client output buffer limits
      execSync('redis-cli CONFIG SET client-output-buffer-limit "normal 0 0 0"', { stdio: 'ignore' });
      
      // Enable lazy freeing for better performance
      execSync('redis-cli CONFIG SET lazyfree-lazy-eviction yes', { stdio: 'ignore' });
      execSync('redis-cli CONFIG SET lazyfree-lazy-expire yes', { stdio: 'ignore' });
      
      this.emit('high-frequency-optimized', {
        timestamp: new Date()
      });
    } catch (error) {
      throw new Error(`High-frequency optimization failed: ${error}`);
    }
  }

  /**
   * Ensure data directory exists with proper permissions
   */
  private async ensureDataDirectory(): Promise<void> {
    try {
      await fs.access(this.dataDir);
    } catch {
      await fs.mkdir(this.dataDir, { recursive: true, mode: 0o755 });
    }
  }

  /**
   * Get Redis configuration
   */
  getConfig(): RedisOptimizationConfig {
    return { ...this.config };
  }

  /**
   * Update Redis configuration
   */
  updateConfig(newConfig: Partial<RedisOptimizationConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.emit('config-updated', this.config);
  }

  /**
   * Stop Redis server and cleanup
   */
  async stop(): Promise<void> {
    if (this.redisProcess && this.isRunning) {
      this.redisProcess.kill('SIGTERM');
      
      // Wait for graceful shutdown
      await new Promise<void>((resolve) => {
        const timeout = setTimeout(() => {
          this.redisProcess?.kill('SIGKILL');
          resolve();
        }, 10000);
        
        this.redisProcess?.on('exit', () => {
          clearTimeout(timeout);
          resolve();
        });
      });
    }
    
    this.isRunning = false;
    this.emit('stopped');
  }
}

/**
 * Default Redis optimization configuration for high-frequency trading
 */
export const DEFAULT_REDIS_CONFIG: RedisOptimizationConfig = {
  maxMemory: '2gb',
  maxMemoryPolicy: 'allkeys-lru',
  save: ['900 1', '300 10', '60 10000'],
  appendOnly: true,
  appendFsync: 'everysec',
  tcpKeepalive: 300,
  timeout: 0,
  tcpBacklog: 511,
  databases: 16,
  hashMaxZiplistEntries: 512,
  hashMaxZiplistValue: 64,
  listMaxZiplistSize: -2,
  setMaxIntsetEntries: 512,
  zsetMaxZiplistEntries: 128,
  zsetMaxZiplistValue: 64,
  lazyfreeLazyEviction: true,
  lazyfreeLazyExpire: true,
  lazyfreeLazyServerDel: true,
  replicaLazyFlush: true,
  slowlogLogSlowerThan: 10000, // 10ms
  slowlogMaxLen: 128
};