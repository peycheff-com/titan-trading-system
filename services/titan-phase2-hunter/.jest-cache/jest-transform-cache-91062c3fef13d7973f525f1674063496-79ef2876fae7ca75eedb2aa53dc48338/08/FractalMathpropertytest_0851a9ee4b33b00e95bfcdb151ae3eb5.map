{"file":"/Users/ivan/Code/trading/titan/services/titan-phase2-hunter/tests/property/FractalMath.property.test.ts","mappings":"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","names":[],"sources":["/Users/ivan/Code/trading/titan/services/titan-phase2-hunter/tests/property/FractalMath.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for FractalMath Engine\n * \n * Tests universal properties that should hold across all valid inputs\n * using fast-check for property generation.\n * \n * **Feature: titan-phase2-hunter, Property 1: Fractal Detection Consistency**\n * **Validates: Requirements 5.1-5.7**\n */\n\nimport * as fc from 'fast-check';\nimport { FractalMath } from '../../src/engine/FractalMath';\nimport { OHLCV } from '../../src/types';\n\ndescribe('FractalMath Property Tests', () => {\n  \n  /**\n   * Generator for valid OHLCV candles\n   * Ensures high >= low and close is within [low, high] range\n   */\n  const ohlcvArbitrary = fc.record({\n    timestamp: fc.integer({ min: 1000000000, max: 2000000000 }),\n    open: fc.float({ min: 1, max: 100000, noNaN: true }),\n    high: fc.float({ min: 1, max: 100000, noNaN: true }),\n    low: fc.float({ min: 1, max: 100000, noNaN: true }),\n    close: fc.float({ min: 1, max: 100000, noNaN: true }),\n    volume: fc.float({ min: 0, max: 1000000, noNaN: true })\n  }).map((candle): OHLCV => {\n    // Ensure valid OHLC relationships\n    const low = Math.min(candle.open, candle.high, candle.low, candle.close);\n    const high = Math.max(candle.open, candle.high, candle.low, candle.close);\n    const close = Math.max(low, Math.min(high, candle.close));\n    \n    return {\n      timestamp: candle.timestamp,\n      open: candle.open,\n      high,\n      low,\n      close,\n      volume: candle.volume\n    };\n  });\n\n  /**\n   * Generator for arrays of OHLCV candles with minimum length of 5\n   * (required for fractal detection)\n   */\n  const candleArrayArbitrary = fc.array(ohlcvArbitrary, { minLength: 5, maxLength: 100 })\n    .map(candles => {\n      // Ensure timestamps are in ascending order\n      return candles.map((candle, index) => ({\n        ...candle,\n        timestamp: 1000000000 + (index * 60000) // 1-minute intervals\n      }));\n    });\n\n  /**\n   * Property 1: Fractal Detection Consistency\n   * \n   * For any OHLCV array, detecting fractals twice should produce identical results.\n   * This tests that the detectFractals() function is deterministic and pure.\n   * \n   * **Validates: Requirements 5.1-5.7**\n   */\n  it('Property 1: Fractal detection should be deterministic and consistent', () => {\n    fc.assert(\n      fc.property(candleArrayArbitrary, (candles) => {\n        // Detect fractals twice with the same input\n        const fractals1 = FractalMath.detectFractals(candles);\n        const fractals2 = FractalMath.detectFractals(candles);\n        \n        // Results should be identical\n        expect(fractals1).toHaveLength(fractals2.length);\n        \n        // Compare each fractal in detail\n        for (let i = 0; i < fractals1.length; i++) {\n          const f1 = fractals1[i];\n          const f2 = fractals2[i];\n          \n          expect(f1.type).toBe(f2.type);\n          expect(f1.price).toBe(f2.price);\n          expect(f1.barIndex).toBe(f2.barIndex);\n          expect(f1.timestamp).toBe(f2.timestamp);\n          expect(f1.confirmed).toBe(f2.confirmed);\n        }\n        \n        // Verify that fractals are properly ordered by barIndex\n        for (let i = 1; i < fractals1.length; i++) {\n          expect(fractals1[i].barIndex).toBeGreaterThanOrEqual(fractals1[i-1].barIndex);\n        }\n        \n        // Verify that all detected fractals have valid bar indices\n        fractals1.forEach(fractal => {\n          expect(fractal.barIndex).toBeGreaterThanOrEqual(2); // Need 2 bars on each side\n          expect(fractal.barIndex).toBeLessThan(candles.length - 2);\n        });\n        \n        // Verify that fractal prices match the actual candle data\n        fractals1.forEach(fractal => {\n          const candle = candles[fractal.barIndex];\n          if (fractal.type === 'HIGH') {\n            expect(fractal.price).toBe(candle.high);\n          } else {\n            expect(fractal.price).toBe(candle.low);\n          }\n        });\n      }),\n      {\n        numRuns: 100, // Run 100 iterations as specified in requirements\n        verbose: true,\n        seed: 42 // Fixed seed for reproducible tests\n      }\n    );\n  });\n\n  /**\n   * Property 2: Fractal Validation Consistency\n   * \n   * For any detected fractal, it should satisfy the Bill Williams definition:\n   * - High fractal: middle candle's high > 2 candles on each side\n   * - Low fractal: middle candle's low < 2 candles on each side\n   */\n  it('Property 2: All detected fractals should satisfy Bill Williams definition', () => {\n    fc.assert(\n      fc.property(candleArrayArbitrary, (candles) => {\n        const fractals = FractalMath.detectFractals(candles);\n        \n        // Verify each fractal satisfies the 5-candle pattern\n        fractals.forEach(fractal => {\n          const i = fractal.barIndex;\n          \n          // Ensure we have enough candles on both sides\n          expect(i).toBeGreaterThanOrEqual(2);\n          expect(i).toBeLessThan(candles.length - 2);\n          \n          if (fractal.type === 'HIGH') {\n            // High fractal: candles[i].high > all 4 neighbors\n            expect(candles[i].high).toBeGreaterThan(candles[i-1].high);\n            expect(candles[i].high).toBeGreaterThan(candles[i-2].high);\n            expect(candles[i].high).toBeGreaterThan(candles[i+1].high);\n            expect(candles[i].high).toBeGreaterThan(candles[i+2].high);\n          } else {\n            // Low fractal: candles[i].low < all 4 neighbors\n            expect(candles[i].low).toBeLessThan(candles[i-1].low);\n            expect(candles[i].low).toBeLessThan(candles[i-2].low);\n            expect(candles[i].low).toBeLessThan(candles[i+1].low);\n            expect(candles[i].low).toBeLessThan(candles[i+2].low);\n          }\n        });\n      }),\n      {\n        numRuns: 100,\n        verbose: true,\n        seed: 42\n      }\n    );\n  });\n\n  /**\n   * Property 3: Fractal Count Bounds\n   * \n   * For any OHLCV array of length N, the number of fractals should be bounded:\n   * - Minimum: 0 fractals (no valid patterns)\n   * - Maximum: N-4 fractals (theoretical max if every eligible candle is a fractal)\n   */\n  it('Property 3: Fractal count should be within expected bounds', () => {\n    fc.assert(\n      fc.property(candleArrayArbitrary, (candles) => {\n        const fractals = FractalMath.detectFractals(candles);\n        \n        // Fractal count should be non-negative\n        expect(fractals.length).toBeGreaterThanOrEqual(0);\n        \n        // Fractal count should not exceed theoretical maximum\n        // Maximum possible fractals = candles.length - 4 (need 2 on each side)\n        const maxPossibleFractals = Math.max(0, candles.length - 4);\n        expect(fractals.length).toBeLessThanOrEqual(maxPossibleFractals);\n        \n        // All fractals should have unique bar indices\n        const barIndices = fractals.map(f => f.barIndex);\n        const uniqueBarIndices = new Set(barIndices);\n        expect(uniqueBarIndices.size).toBe(barIndices.length);\n      }),\n      {\n        numRuns: 100,\n        verbose: true,\n        seed: 42\n      }\n    );\n  });\n\n  /**\n   * Property 4: Empty Input Handling\n   * \n   * For arrays with fewer than 5 candles, detectFractals should return empty array\n   */\n  it('Property 4: Should handle insufficient input gracefully', () => {\n    fc.assert(\n      fc.property(\n        fc.array(ohlcvArbitrary, { minLength: 0, maxLength: 4 }),\n        (candles) => {\n          const fractals = FractalMath.detectFractals(candles);\n          expect(fractals).toHaveLength(0);\n        }\n      ),\n      {\n        numRuns: 50,\n        verbose: true,\n        seed: 42\n      }\n    );\n  });\n\n  /**\n   * Property 5: Fractal Immutability\n   * \n   * The detectFractals function should not modify the input array\n   */\n  it('Property 5: Input array should remain unchanged', () => {\n    fc.assert(\n      fc.property(candleArrayArbitrary, (candles) => {\n        // Create deep copy of input\n        const originalCandles = JSON.parse(JSON.stringify(candles));\n        \n        // Call detectFractals\n        FractalMath.detectFractals(candles);\n        \n        // Verify input is unchanged\n        expect(candles).toEqual(originalCandles);\n      }),\n      {\n        numRuns: 100,\n        verbose: true,\n        seed: 42\n      }\n    );\n  });\n});"],"version":3}