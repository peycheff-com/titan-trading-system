45bd05f3ae80276efac07468d62ad430
"use strict";
/**
 * Limit Order Executor (The Sniper) for Titan Phase 2 - The Hunter
 *
 * Implements passive execution strategy using Post-Only Limit Orders at Order Blocks.
 * Designed for Bulgaria (200ms latency) - orders wait at pre-calculated levels.
 *
 * Key Features:
 * - Post-Only orders at Order Block top/bottom (earn Maker rebates)
 * - 60-second order timeout with price movement cancellation
 * - Volatility-Adjusted Position Sizing using ATR
 * - 3:1 Risk-Reward ratio (1.5% stop, 4.5% target)
 * - Smart cancellation logic (price moves >0.2%, level fails >0.5%)
 *
 * Requirements: 7.1-7.7 (Execution)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrderExecutor = void 0;
const events_1 = require("events");
class LimitOrderExecutor extends events_1.EventEmitter {
    bybitClient;
    config;
    activeOrders = new Map();
    monitoringInterval = null;
    MONITORING_FREQUENCY = 1000; // 1 second
    constructor(bybitClient, config) {
        super();
        this.bybitClient = bybitClient;
        this.config = {
            orderTimeout: 60000, // 60 seconds
            priceMoveCancelThreshold: 0.002, // 0.2%
            levelFailThreshold: 0.005, // 0.5%
            stopLossPercent: 0.015, // 1.5%
            takeProfitPercent: 0.045, // 4.5%
            atrPeriod: 14,
            maxRetries: 2,
            retryDelay: 1000,
            ...config
        };
        // Start order monitoring
        this.startMonitoring();
    }
    /**
     * Place Post-Only Limit Order at Order Block top/bottom
     * @param signal - Signal data with entry details
     * @param orderBlock - Order Block for entry level
     * @param equity - Current account equity for position sizing
     * @returns Promise with execution result
     */
    async placePostOnlyOrder(signal, orderBlock, equity) {
        try {
            console.log(`üéØ Placing Post-Only order for ${signal.symbol} ${signal.direction}`);
            // Calculate entry price at Order Block level
            const entryPrice = signal.direction === 'LONG'
                ? orderBlock.low // Enter at OB bottom for longs
                : orderBlock.high; // Enter at OB top for shorts
            // Calculate position size using Volatility-Adjusted Sizing
            const positionSize = await this.calcPositionSize(signal.symbol, entryPrice, equity, signal.leverage);
            if (positionSize <= 0) {
                return {
                    success: false,
                    error: 'Position size calculation failed or too small'
                };
            }
            // Calculate stop loss and take profit
            const { stopLoss, takeProfit } = this.setStopAndTarget(entryPrice, signal.direction);
            // Prepare order parameters
            const orderParams = {
                phase: 'phase2',
                symbol: signal.symbol,
                side: signal.direction === 'LONG' ? 'Buy' : 'Sell',
                type: 'POST_ONLY',
                price: entryPrice,
                qty: positionSize,
                leverage: signal.leverage,
                stopLoss,
                takeProfit
            };
            // Place order with retry logic
            const orderResult = await this.bybitClient.placeOrderWithRetry(orderParams, this.config.maxRetries);
            if (orderResult.orderId) {
                // Start monitoring the order
                this.startOrderMonitoring(orderResult.orderId, signal.symbol, entryPrice, orderBlock);
                this.emit('order:placed', orderResult.orderId, signal.symbol, entryPrice);
                console.log(`‚úÖ Post-Only order placed: ${signal.symbol} @ ${entryPrice} (ID: ${orderResult.orderId})`);
                return {
                    success: true,
                    orderId: orderResult.orderId,
                    positionSize,
                    stopLoss,
                    takeProfit
                };
            }
            return {
                success: false,
                error: 'Order placement failed - no order ID returned'
            };
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : 'Unknown error';
            console.error(`‚ùå Failed to place Post-Only order for ${signal.symbol}:`, errorMsg);
            this.emit('execution:error', error, { signal, orderBlock });
            return {
                success: false,
                error: errorMsg
            };
        }
    }
    /**
     * Monitor order with 60-second timeout
     * @param orderId - Order ID to monitor
     * @param symbol - Trading symbol
     * @param entryPrice - Expected entry price
     * @param orderBlock - Order Block reference
     */
    startOrderMonitoring(orderId, symbol, entryPrice, orderBlock) {
        const monitoringState = {
            orderId,
            symbol,
            entryPrice,
            orderBlock,
            startTime: Date.now(),
            cancelled: false,
            filled: false
        };
        this.activeOrders.set(orderId, monitoringState);
        console.log(`üëÅÔ∏è Started monitoring order ${orderId} for ${symbol}`);
    }
    /**
     * Monitor order and cancel if price moves away > 0.2%
     * @param orderId - Order ID to monitor
     * @param currentPrice - Current market price
     * @returns Promise with cancellation result
     */
    async cancelIfPriceMoves(orderId, currentPrice) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState || orderState.cancelled || orderState.filled) {
            return false;
        }
        // Calculate price movement from entry level
        const priceMove = Math.abs(currentPrice - orderState.entryPrice) / orderState.entryPrice;
        if (priceMove > this.config.priceMoveCancelThreshold) {
            console.log(`üìâ Price moved ${(priceMove * 100).toFixed(2)}% away from ${orderState.symbol} order, cancelling`);
            try {
                const success = await this.bybitClient.cancelOrder(orderId, orderState.symbol);
                if (success) {
                    orderState.cancelled = true;
                    this.activeOrders.set(orderId, orderState);
                    this.emit('order:cancelled', orderId, 'PRICE_MOVED_AWAY');
                    console.log(`‚úÖ Order cancelled due to price movement: ${orderId}`);
                    return true;
                }
            }
            catch (error) {
                console.error(`‚ùå Failed to cancel order ${orderId}:`, error);
                this.emit('execution:error', error, { orderId, reason: 'CANCEL_FAILED' });
            }
        }
        return false;
    }
    /**
     * Cancel order when price wicks through Order Block > 0.5%
     * @param orderId - Order ID to monitor
     * @param currentCandle - Current OHLCV candle
     * @returns Promise with cancellation result
     */
    async cancelIfLevelFails(orderId, currentCandle) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState || orderState.cancelled || orderState.filled) {
            return false;
        }
        const orderBlock = orderState.orderBlock;
        let wickThrough = false;
        let wickPercent = 0;
        if (orderBlock.type === 'BULLISH') {
            // For bullish OB, check if price wicked below OB low
            if (currentCandle.low < orderBlock.low) {
                wickPercent = (orderBlock.low - currentCandle.low) / orderBlock.low;
                wickThrough = wickPercent > this.config.levelFailThreshold;
            }
        }
        else {
            // For bearish OB, check if price wicked above OB high
            if (currentCandle.high > orderBlock.high) {
                wickPercent = (currentCandle.high - orderBlock.high) / orderBlock.high;
                wickThrough = wickPercent > this.config.levelFailThreshold;
            }
        }
        if (wickThrough) {
            console.log(`üí• Order Block level failed for ${orderState.symbol} (${(wickPercent * 100).toFixed(2)}% wick), cancelling`);
            try {
                const success = await this.bybitClient.cancelOrder(orderId, orderState.symbol);
                if (success) {
                    orderState.cancelled = true;
                    this.activeOrders.set(orderId, orderState);
                    this.emit('order:cancelled', orderId, 'LEVEL_FAILED');
                    console.log(`‚úÖ Order cancelled due to level failure: ${orderId}`);
                    return true;
                }
            }
            catch (error) {
                console.error(`‚ùå Failed to cancel order ${orderId}:`, error);
                this.emit('execution:error', error, { orderId, reason: 'CANCEL_FAILED' });
            }
        }
        return false;
    }
    /**
     * Calculate position size using Volatility-Adjusted Sizing
     * @param symbol - Trading symbol
     * @param entryPrice - Entry price
     * @param equity - Account equity
     * @param leverage - Leverage multiplier
     * @returns Promise with position size
     */
    async calcPositionSize(symbol, entryPrice, equity, leverage) {
        try {
            // Fetch recent OHLCV data for ATR calculation
            const candles = await this.bybitClient.fetchOHLCV(symbol, '1h', this.config.atrPeriod + 10);
            if (candles.length < this.config.atrPeriod) {
                throw new Error(`Insufficient candle data for ATR calculation: ${candles.length} < ${this.config.atrPeriod}`);
            }
            // Calculate ATR (Average True Range)
            const atr = this.calculateATR(candles, this.config.atrPeriod);
            // Risk amount (2% of equity by default)
            const riskPercent = 0.02; // 2% risk per trade
            const riskAmount = equity * riskPercent;
            // Stop distance in price terms
            const stopDistance = entryPrice * this.config.stopLossPercent;
            // Volatility-Adjusted Sizing: Risk_Dollars / (ATR * Stop_Distance_Multiplier)
            // Use ATR as volatility adjustment factor
            const volatilityAdjustment = atr / entryPrice; // ATR as % of price
            const adjustedStopDistance = stopDistance * (1 + volatilityAdjustment);
            // Calculate base position size
            const basePositionSize = riskAmount / adjustedStopDistance;
            // Apply leverage (but cap at reasonable levels)
            const maxLeverageMultiplier = Math.min(leverage, 5); // Cap at 5x for safety
            const positionSize = basePositionSize * maxLeverageMultiplier;
            // Ensure minimum position size (0.001 for most symbols)
            const minPositionSize = 0.001;
            const finalPositionSize = Math.max(positionSize, minPositionSize);
            console.log(`üìä Position sizing for ${symbol}:`);
            console.log(`   ATR: ${atr.toFixed(4)} (${(volatilityAdjustment * 100).toFixed(2)}%)`);
            console.log(`   Risk Amount: $${riskAmount.toFixed(2)}`);
            console.log(`   Stop Distance: ${stopDistance.toFixed(4)} (${(this.config.stopLossPercent * 100).toFixed(1)}%)`);
            console.log(`   Position Size: ${finalPositionSize.toFixed(4)}`);
            return finalPositionSize;
        }
        catch (error) {
            console.error(`‚ùå Failed to calculate position size for ${symbol}:`, error);
            throw new Error(`Position size calculation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Set stop loss and take profit with 1.5% stop, 4.5% target (3:1 R:R)
     * @param entryPrice - Entry price
     * @param direction - Trade direction
     * @returns Stop loss and take profit prices
     */
    setStopAndTarget(entryPrice, direction) {
        const stopDistance = entryPrice * this.config.stopLossPercent;
        const targetDistance = entryPrice * this.config.takeProfitPercent;
        let stopLoss;
        let takeProfit;
        if (direction === 'LONG') {
            stopLoss = entryPrice - stopDistance; // 1.5% below entry
            takeProfit = entryPrice + targetDistance; // 4.5% above entry
        }
        else {
            stopLoss = entryPrice + stopDistance; // 1.5% above entry
            takeProfit = entryPrice - targetDistance; // 4.5% below entry
        }
        const riskReward = targetDistance / stopDistance;
        console.log(`üéØ Stop & Target for ${direction} @ ${entryPrice.toFixed(4)}:`);
        console.log(`   Stop Loss: ${stopLoss.toFixed(4)} (-${(this.config.stopLossPercent * 100).toFixed(1)}%)`);
        console.log(`   Take Profit: ${takeProfit.toFixed(4)} (+${(this.config.takeProfitPercent * 100).toFixed(1)}%)`);
        console.log(`   Risk:Reward = 1:${riskReward.toFixed(1)}`);
        return { stopLoss, takeProfit };
    }
    /**
     * Calculate Average True Range (ATR)
     * @param candles - OHLCV candle data
     * @param period - ATR period (default: 14)
     * @returns ATR value
     */
    calculateATR(candles, period) {
        if (candles.length < period + 1) {
            throw new Error(`Insufficient data for ATR calculation: need ${period + 1}, got ${candles.length}`);
        }
        const trueRanges = [];
        // Calculate True Range for each candle (starting from index 1)
        for (let i = 1; i < candles.length; i++) {
            const current = candles[i];
            const previous = candles[i - 1];
            // True Range = max(high-low, |high-prevClose|, |low-prevClose|)
            const highLow = current.high - current.low;
            const highPrevClose = Math.abs(current.high - previous.close);
            const lowPrevClose = Math.abs(current.low - previous.close);
            const trueRange = Math.max(highLow, highPrevClose, lowPrevClose);
            trueRanges.push(trueRange);
        }
        // Calculate ATR as Simple Moving Average of True Ranges
        const recentTrueRanges = trueRanges.slice(-period);
        const atr = recentTrueRanges.reduce((sum, tr) => sum + tr, 0) / period;
        return atr;
    }
    /**
     * Start monitoring all active orders
     */
    startMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
        }
        this.monitoringInterval = setInterval(async () => {
            await this.monitorActiveOrders();
        }, this.MONITORING_FREQUENCY);
        console.log(`üëÅÔ∏è Limit Order Executor: Started monitoring (${this.MONITORING_FREQUENCY}ms interval)`);
    }
    /**
     * Monitor all active orders for timeout, fills, and cancellation conditions
     */
    async monitorActiveOrders() {
        const activeOrderIds = Array.from(this.activeOrders.keys());
        for (const orderId of activeOrderIds) {
            const orderState = this.activeOrders.get(orderId);
            if (!orderState || orderState.cancelled || orderState.filled) {
                continue;
            }
            try {
                // Check for timeout (60 seconds)
                const elapsed = Date.now() - orderState.startTime;
                if (elapsed > this.config.orderTimeout) {
                    await this.handleOrderTimeout(orderId);
                    continue;
                }
                // Check order status
                const status = await this.bybitClient.getOrderStatus(orderId, orderState.symbol);
                if (status === 'FILLED') {
                    await this.handleOrderFilled(orderId);
                }
                else if (status === 'CANCELLED') {
                    await this.handleOrderCancelled(orderId);
                }
                else {
                    // Order still active, check cancellation conditions
                    await this.checkCancellationConditions(orderId);
                }
            }
            catch (error) {
                console.error(`‚ùå Error monitoring order ${orderId}:`, error);
                this.emit('execution:error', error, { orderId, action: 'MONITORING' });
            }
        }
    }
    /**
     * Handle order timeout (60 seconds)
     * @param orderId - Order ID that timed out
     */
    async handleOrderTimeout(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        console.log(`‚è∞ Order timeout for ${orderState.symbol}: ${orderId}`);
        try {
            // Cancel the timed-out order
            await this.bybitClient.cancelOrder(orderId, orderState.symbol);
            orderState.cancelled = true;
            this.activeOrders.set(orderId, orderState);
            this.emit('order:timeout', orderId);
            this.emit('order:cancelled', orderId, 'TIMEOUT');
            console.log(`‚úÖ Timed-out order cancelled: ${orderId}`);
        }
        catch (error) {
            console.error(`‚ùå Failed to cancel timed-out order ${orderId}:`, error);
            this.emit('execution:error', error, { orderId, reason: 'TIMEOUT_CANCEL_FAILED' });
        }
    }
    /**
     * Handle order filled
     * @param orderId - Order ID that was filled
     */
    async handleOrderFilled(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        console.log(`‚úÖ Order filled: ${orderState.symbol} @ ${orderState.entryPrice}`);
        try {
            // Get fill details (this would need to be implemented in BybitPerpsClient)
            const fillPrice = orderState.entryPrice; // Simplified - should get actual fill price
            orderState.filled = true;
            this.activeOrders.set(orderId, orderState);
            // Calculate position size (this should be stored from original order)
            const positionSize = 0.1; // Simplified - should get actual fill quantity
            this.emit('order:filled', orderId, fillPrice, positionSize);
            // Create position object for position manager
            const { stopLoss, takeProfit } = this.setStopAndTarget(fillPrice, orderState.symbol.includes('LONG') ? 'LONG' : 'SHORT' // Simplified direction detection
            );
            const position = {
                id: orderId,
                symbol: orderState.symbol,
                side: orderState.symbol.includes('LONG') ? 'LONG' : 'SHORT', // Simplified
                entryPrice: fillPrice,
                currentPrice: fillPrice,
                quantity: positionSize,
                leverage: 3, // Default leverage
                stopLoss,
                takeProfit,
                unrealizedPnL: 0,
                realizedPnL: 0,
                entryTime: Date.now(),
                status: 'OPEN',
                rValue: 0,
                atr: await this.getATRForSymbol(orderState.symbol)
            };
            this.emit('position:created', position);
            // Remove from active monitoring
            this.activeOrders.delete(orderId);
        }
        catch (error) {
            console.error(`‚ùå Error handling filled order ${orderId}:`, error);
            this.emit('execution:error', error, { orderId, reason: 'FILL_HANDLING_FAILED' });
        }
    }
    /**
     * Handle order cancelled
     * @param orderId - Order ID that was cancelled
     */
    async handleOrderCancelled(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        console.log(`‚ùå Order cancelled: ${orderState.symbol} (${orderId})`);
        orderState.cancelled = true;
        this.activeOrders.set(orderId, orderState);
        this.emit('order:cancelled', orderId, 'EXTERNAL_CANCEL');
        // Remove from active monitoring
        this.activeOrders.delete(orderId);
    }
    /**
     * Check cancellation conditions for active order
     * @param orderId - Order ID to check
     */
    async checkCancellationConditions(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        try {
            // Get current price
            const currentPrice = await this.bybitClient.getCurrentPrice(orderState.symbol);
            // Check if price moved away > 0.2%
            await this.cancelIfPriceMoves(orderId, currentPrice);
            // Check if level failed (would need current candle data)
            // This is simplified - in practice, you'd need real-time candle data
        }
        catch (error) {
            console.error(`‚ùå Error checking cancellation conditions for ${orderId}:`, error);
        }
    }
    /**
     * Get ATR for symbol (helper method)
     * @param symbol - Trading symbol
     * @returns Promise with ATR value
     */
    async getATRForSymbol(symbol) {
        try {
            const candles = await this.bybitClient.fetchOHLCV(symbol, '1h', this.config.atrPeriod + 10);
            return this.calculateATR(candles, this.config.atrPeriod);
        }
        catch (error) {
            console.error(`‚ùå Failed to get ATR for ${symbol}:`, error);
            return 0.001; // Default ATR
        }
    }
    /**
     * Get active orders count
     * @returns Number of active orders
     */
    getActiveOrdersCount() {
        return this.activeOrders.size;
    }
    /**
     * Get active orders
     * @returns Array of active order states
     */
    getActiveOrders() {
        return Array.from(this.activeOrders.values());
    }
    /**
     * Cancel all active orders
     * @returns Promise with cancellation results
     */
    async cancelAllOrders() {
        console.log(`üö® Cancelling all active orders`);
        const orderIds = Array.from(this.activeOrders.keys());
        let success = 0;
        let failed = 0;
        for (const orderId of orderIds) {
            const orderState = this.activeOrders.get(orderId);
            if (!orderState)
                continue;
            try {
                const result = await this.bybitClient.cancelOrder(orderId, orderState.symbol);
                if (result) {
                    success++;
                    orderState.cancelled = true;
                    this.activeOrders.set(orderId, orderState);
                    this.emit('order:cancelled', orderId, 'MANUAL_CANCEL_ALL');
                }
                else {
                    failed++;
                }
            }
            catch (error) {
                console.error(`‚ùå Failed to cancel order ${orderId}:`, error);
                failed++;
            }
        }
        console.log(`üö® Cancel all complete: ${success} success, ${failed} failed`);
        return { success, failed };
    }
    /**
     * Update configuration
     * @param newConfig - New configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        console.log(`üéØ Limit Order Executor: Configuration updated`);
    }
    /**
     * Stop monitoring and cleanup
     */
    destroy() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
        this.activeOrders.clear();
        this.removeAllListeners();
        console.log(`üéØ Limit Order Executor: Destroyed`);
    }
}
exports.LimitOrderExecutor = LimitOrderExecutor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLXBoYXNlMi1odW50ZXIvc3JjL2V4ZWN1dGlvbi9MaW1pdE9yZGVyRXhlY3V0b3IudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7OztHQWNHOzs7QUFFSCxtQ0FBc0M7QUFzRHRDLE1BQWEsa0JBQW1CLFNBQVEscUJBQVk7SUFDMUMsV0FBVyxDQUFtQjtJQUM5QixNQUFNLENBQW1CO0lBQ3pCLFlBQVksR0FBc0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUM1RCxrQkFBa0IsR0FBMEIsSUFBSSxDQUFDO0lBQ3hDLG9CQUFvQixHQUFHLElBQUksQ0FBQyxDQUFDLFdBQVc7SUFFekQsWUFBWSxXQUE2QixFQUFFLE1BQWtDO1FBQzNFLEtBQUssRUFBRSxDQUFDO1FBRVIsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLE1BQU0sR0FBRztZQUNaLFlBQVksRUFBRSxLQUFLLEVBQUUsYUFBYTtZQUNsQyx3QkFBd0IsRUFBRSxLQUFLLEVBQUUsT0FBTztZQUN4QyxrQkFBa0IsRUFBRSxLQUFLLEVBQUUsT0FBTztZQUNsQyxlQUFlLEVBQUUsS0FBSyxFQUFFLE9BQU87WUFDL0IsaUJBQWlCLEVBQUUsS0FBSyxFQUFFLE9BQU87WUFDakMsU0FBUyxFQUFFLEVBQUU7WUFDYixVQUFVLEVBQUUsQ0FBQztZQUNiLFVBQVUsRUFBRSxJQUFJO1lBQ2hCLEdBQUcsTUFBTTtTQUNWLENBQUM7UUFFRix5QkFBeUI7UUFDekIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsa0JBQWtCLENBQzdCLE1BQWtCLEVBQ2xCLFVBQXNCLEVBQ3RCLE1BQWM7UUFFZCxJQUFJLENBQUM7WUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLGtDQUFrQyxNQUFNLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO1lBRW5GLDZDQUE2QztZQUM3QyxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsU0FBUyxLQUFLLE1BQU07Z0JBQzVDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFFLCtCQUErQjtnQkFDakQsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyw2QkFBNkI7WUFFbEQsMkRBQTJEO1lBQzNELE1BQU0sWUFBWSxHQUFHLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUM5QyxNQUFNLENBQUMsTUFBTSxFQUNiLFVBQVUsRUFDVixNQUFNLEVBQ04sTUFBTSxDQUFDLFFBQVEsQ0FDaEIsQ0FBQztZQUVGLElBQUksWUFBWSxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUN0QixPQUFPO29CQUNMLE9BQU8sRUFBRSxLQUFLO29CQUNkLEtBQUssRUFBRSwrQ0FBK0M7aUJBQ3ZELENBQUM7WUFDSixDQUFDO1lBRUQsc0NBQXNDO1lBQ3RDLE1BQU0sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFckYsMkJBQTJCO1lBQzNCLE1BQU0sV0FBVyxHQUFnQjtnQkFDL0IsS0FBSyxFQUFFLFFBQVE7Z0JBQ2YsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO2dCQUNyQixJQUFJLEVBQUUsTUFBTSxDQUFDLFNBQVMsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTTtnQkFDbEQsSUFBSSxFQUFFLFdBQVc7Z0JBQ2pCLEtBQUssRUFBRSxVQUFVO2dCQUNqQixHQUFHLEVBQUUsWUFBWTtnQkFDakIsUUFBUSxFQUFFLE1BQU0sQ0FBQyxRQUFRO2dCQUN6QixRQUFRO2dCQUNSLFVBQVU7YUFDWCxDQUFDO1lBRUYsK0JBQStCO1lBQy9CLE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FDNUQsV0FBVyxFQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUN2QixDQUFDO1lBRUYsSUFBSSxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3hCLDZCQUE2QjtnQkFDN0IsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7Z0JBRXRGLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLFdBQVcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFFMUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyw2QkFBNkIsTUFBTSxDQUFDLE1BQU0sTUFBTSxVQUFVLFNBQVMsV0FBVyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7Z0JBRXZHLE9BQU87b0JBQ0wsT0FBTyxFQUFFLElBQUk7b0JBQ2IsT0FBTyxFQUFFLFdBQVcsQ0FBQyxPQUFPO29CQUM1QixZQUFZO29CQUNaLFFBQVE7b0JBQ1IsVUFBVTtpQkFDWCxDQUFDO1lBQ0osQ0FBQztZQUVELE9BQU87Z0JBQ0wsT0FBTyxFQUFFLEtBQUs7Z0JBQ2QsS0FBSyxFQUFFLCtDQUErQzthQUN2RCxDQUFDO1FBRUosQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixNQUFNLFFBQVEsR0FBRyxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUM7WUFDMUUsT0FBTyxDQUFDLEtBQUssQ0FBQyx5Q0FBeUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRW5GLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsS0FBYyxFQUFFLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7WUFFckUsT0FBTztnQkFDTCxPQUFPLEVBQUUsS0FBSztnQkFDZCxLQUFLLEVBQUUsUUFBUTthQUNoQixDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxvQkFBb0IsQ0FDMUIsT0FBZSxFQUNmLE1BQWMsRUFDZCxVQUFrQixFQUNsQixVQUFzQjtRQUV0QixNQUFNLGVBQWUsR0FBeUI7WUFDNUMsT0FBTztZQUNQLE1BQU07WUFDTixVQUFVO1lBQ1YsVUFBVTtZQUNWLFNBQVMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ3JCLFNBQVMsRUFBRSxLQUFLO1lBQ2hCLE1BQU0sRUFBRSxLQUFLO1NBQ2QsQ0FBQztRQUVGLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztRQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLGdDQUFnQyxPQUFPLFFBQVEsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsT0FBZSxFQUFFLFlBQW9CO1FBQ25FLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLFNBQVMsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDN0QsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsNENBQTRDO1FBQzVDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDO1FBRXpGLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztZQUNyRCxPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWUsVUFBVSxDQUFDLE1BQU0sb0JBQW9CLENBQUMsQ0FBQztZQUVoSCxJQUFJLENBQUM7Z0JBQ0gsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUUvRSxJQUFJLE9BQU8sRUFBRSxDQUFDO29CQUNaLFVBQVUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO29CQUM1QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7b0JBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsT0FBTyxFQUFFLGtCQUFrQixDQUFDLENBQUM7b0JBRTFELE9BQU8sQ0FBQyxHQUFHLENBQUMsNENBQTRDLE9BQU8sRUFBRSxDQUFDLENBQUM7b0JBQ25FLE9BQU8sSUFBSSxDQUFDO2dCQUNkLENBQUM7WUFDSCxDQUFDO1lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztnQkFDZixPQUFPLENBQUMsS0FBSyxDQUFDLDRCQUE0QixPQUFPLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDN0QsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxLQUFjLEVBQUUsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7WUFDckYsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxPQUFlLEVBQUUsYUFBb0I7UUFDbkUsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsU0FBUyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUM3RCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDO1FBQ3pDLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFFcEIsSUFBSSxVQUFVLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ2xDLHFEQUFxRDtZQUNyRCxJQUFJLGFBQWEsQ0FBQyxHQUFHLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUN2QyxXQUFXLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDO2dCQUNwRSxXQUFXLEdBQUcsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUM7WUFDN0QsQ0FBQztRQUNILENBQUM7YUFBTSxDQUFDO1lBQ04sc0RBQXNEO1lBQ3RELElBQUksYUFBYSxDQUFDLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ3pDLFdBQVcsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUM7Z0JBQ3ZFLFdBQVcsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQztZQUM3RCxDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksV0FBVyxFQUFFLENBQUM7WUFDaEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQ0FBbUMsVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLFdBQVcsR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFFMUgsSUFBSSxDQUFDO2dCQUNILE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFFL0UsSUFBSSxPQUFPLEVBQUUsQ0FBQztvQkFDWixVQUFVLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztvQkFDNUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO29CQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztvQkFFdEQsT0FBTyxDQUFDLEdBQUcsQ0FBQywyQ0FBMkMsT0FBTyxFQUFFLENBQUMsQ0FBQztvQkFDbEUsT0FBTyxJQUFJLENBQUM7Z0JBQ2QsQ0FBQztZQUNILENBQUM7WUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsNEJBQTRCLE9BQU8sR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUM3RCxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEtBQWMsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQztZQUNyRixDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsZ0JBQWdCLENBQzNCLE1BQWMsRUFDZCxVQUFrQixFQUNsQixNQUFjLEVBQ2QsUUFBZ0I7UUFFaEIsSUFBSSxDQUFDO1lBQ0gsOENBQThDO1lBQzlDLE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUU1RixJQUFJLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxpREFBaUQsT0FBTyxDQUFDLE1BQU0sTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7WUFDaEgsQ0FBQztZQUVELHFDQUFxQztZQUNyQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRTlELHdDQUF3QztZQUN4QyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsQ0FBQyxvQkFBb0I7WUFDOUMsTUFBTSxVQUFVLEdBQUcsTUFBTSxHQUFHLFdBQVcsQ0FBQztZQUV4QywrQkFBK0I7WUFDL0IsTUFBTSxZQUFZLEdBQUcsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDO1lBRTlELDhFQUE4RTtZQUM5RSwwQ0FBMEM7WUFDMUMsTUFBTSxvQkFBb0IsR0FBRyxHQUFHLEdBQUcsVUFBVSxDQUFDLENBQUMsb0JBQW9CO1lBQ25FLE1BQU0sb0JBQW9CLEdBQUcsWUFBWSxHQUFHLENBQUMsQ0FBQyxHQUFHLG9CQUFvQixDQUFDLENBQUM7WUFFdkUsK0JBQStCO1lBQy9CLE1BQU0sZ0JBQWdCLEdBQUcsVUFBVSxHQUFHLG9CQUFvQixDQUFDO1lBRTNELGdEQUFnRDtZQUNoRCxNQUFNLHFCQUFxQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsdUJBQXVCO1lBQzVFLE1BQU0sWUFBWSxHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixDQUFDO1lBRTlELHdEQUF3RDtZQUN4RCxNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUM7WUFDOUIsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxlQUFlLENBQUMsQ0FBQztZQUVsRSxPQUFPLENBQUMsR0FBRyxDQUFDLDBCQUEwQixNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2pELE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsb0JBQW9CLEdBQUcsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN2RixPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN6RCxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEdBQUcsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqSCxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRWpFLE9BQU8saUJBQWlCLENBQUM7UUFFM0IsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLDJDQUEyQyxNQUFNLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzRSxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO1FBQ25ILENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxnQkFBZ0IsQ0FBQyxVQUFrQixFQUFFLFNBQTJCO1FBSXJFLE1BQU0sWUFBWSxHQUFHLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQztRQUM5RCxNQUFNLGNBQWMsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztRQUVsRSxJQUFJLFFBQWdCLENBQUM7UUFDckIsSUFBSSxVQUFrQixDQUFDO1FBRXZCLElBQUksU0FBUyxLQUFLLE1BQU0sRUFBRSxDQUFDO1lBQ3pCLFFBQVEsR0FBRyxVQUFVLEdBQUcsWUFBWSxDQUFDLENBQUcsbUJBQW1CO1lBQzNELFVBQVUsR0FBRyxVQUFVLEdBQUcsY0FBYyxDQUFDLENBQUMsbUJBQW1CO1FBQy9ELENBQUM7YUFBTSxDQUFDO1lBQ04sUUFBUSxHQUFHLFVBQVUsR0FBRyxZQUFZLENBQUMsQ0FBRyxtQkFBbUI7WUFDM0QsVUFBVSxHQUFHLFVBQVUsR0FBRyxjQUFjLENBQUMsQ0FBQyxtQkFBbUI7UUFDL0QsQ0FBQztRQUVELE1BQU0sVUFBVSxHQUFHLGNBQWMsR0FBRyxZQUFZLENBQUM7UUFFakQsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsU0FBUyxNQUFNLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdFLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixHQUFHLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEgsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFM0QsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxZQUFZLENBQUMsT0FBZ0IsRUFBRSxNQUFjO1FBQ25ELElBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsTUFBTSxHQUFHLENBQUMsU0FBUyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUN0RyxDQUFDO1FBRUQsTUFBTSxVQUFVLEdBQWEsRUFBRSxDQUFDO1FBRWhDLCtEQUErRDtRQUMvRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3hDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQixNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBRWhDLGdFQUFnRTtZQUNoRSxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUM7WUFDM0MsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM5RCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBRTVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUNqRSxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzdCLENBQUM7UUFFRCx3REFBd0Q7UUFDeEQsTUFBTSxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkQsTUFBTSxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7UUFFdkUsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSyxlQUFlO1FBQ3JCLElBQUksSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDNUIsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3pDLENBQUM7UUFFRCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsV0FBVyxDQUFDLEtBQUssSUFBSSxFQUFFO1lBQy9DLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDbkMsQ0FBQyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBRTlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsaURBQWlELElBQUksQ0FBQyxvQkFBb0IsY0FBYyxDQUFDLENBQUM7SUFDeEcsQ0FBQztJQUVEOztPQUVHO0lBQ0ssS0FBSyxDQUFDLG1CQUFtQjtRQUMvQixNQUFNLGNBQWMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUU1RCxLQUFLLE1BQU0sT0FBTyxJQUFJLGNBQWMsRUFBRSxDQUFDO1lBQ3JDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxVQUFVLElBQUksVUFBVSxDQUFDLFNBQVMsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQzdELFNBQVM7WUFDWCxDQUFDO1lBRUQsSUFBSSxDQUFDO2dCQUNILGlDQUFpQztnQkFDakMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUM7Z0JBQ2xELElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7b0JBQ3ZDLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUN2QyxTQUFTO2dCQUNYLENBQUM7Z0JBRUQscUJBQXFCO2dCQUNyQixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBRWpGLElBQUksTUFBTSxLQUFLLFFBQVEsRUFBRSxDQUFDO29CQUN4QixNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDeEMsQ0FBQztxQkFBTSxJQUFJLE1BQU0sS0FBSyxXQUFXLEVBQUUsQ0FBQztvQkFDbEMsTUFBTSxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzNDLENBQUM7cUJBQU0sQ0FBQztvQkFDTixvREFBb0Q7b0JBQ3BELE1BQU0sSUFBSSxDQUFDLDJCQUEyQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRCxDQUFDO1lBRUgsQ0FBQztZQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsT0FBTyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzdELElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsS0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO1lBQ2xGLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNLLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxPQUFlO1FBQzlDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxVQUFVO1lBQUUsT0FBTztRQUV4QixPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixVQUFVLENBQUMsTUFBTSxLQUFLLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFFcEUsSUFBSSxDQUFDO1lBQ0gsNkJBQTZCO1lBQzdCLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUUvRCxVQUFVLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztZQUM1QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFFM0MsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFFakQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQ0FBZ0MsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUV6RCxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE9BQU8sQ0FBQyxLQUFLLENBQUMsc0NBQXNDLE9BQU8sR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3ZFLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsS0FBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSx1QkFBdUIsRUFBRSxDQUFDLENBQUM7UUFDN0YsQ0FBQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSyxLQUFLLENBQUMsaUJBQWlCLENBQUMsT0FBZTtRQUM3QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsVUFBVTtZQUFFLE9BQU87UUFFeEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsVUFBVSxDQUFDLE1BQU0sTUFBTSxVQUFVLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztRQUUvRSxJQUFJLENBQUM7WUFDSCwyRUFBMkU7WUFDM0UsTUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLDRDQUE0QztZQUVyRixVQUFVLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztZQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFFM0Msc0VBQXNFO1lBQ3RFLE1BQU0sWUFBWSxHQUFHLEdBQUcsQ0FBQyxDQUFDLCtDQUErQztZQUV6RSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksQ0FBQyxDQUFDO1lBRTVELDhDQUE4QztZQUM5QyxNQUFNLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FDcEQsU0FBUyxFQUNULFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxpQ0FBaUM7YUFDeEYsQ0FBQztZQUVGLE1BQU0sUUFBUSxHQUFhO2dCQUN6QixFQUFFLEVBQUUsT0FBTztnQkFDWCxNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU07Z0JBQ3pCLElBQUksRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsYUFBYTtnQkFDMUUsVUFBVSxFQUFFLFNBQVM7Z0JBQ3JCLFlBQVksRUFBRSxTQUFTO2dCQUN2QixRQUFRLEVBQUUsWUFBWTtnQkFDdEIsUUFBUSxFQUFFLENBQUMsRUFBRSxtQkFBbUI7Z0JBQ2hDLFFBQVE7Z0JBQ1IsVUFBVTtnQkFDVixhQUFhLEVBQUUsQ0FBQztnQkFDaEIsV0FBVyxFQUFFLENBQUM7Z0JBQ2QsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ3JCLE1BQU0sRUFBRSxNQUFNO2dCQUNkLE1BQU0sRUFBRSxDQUFDO2dCQUNULEdBQUcsRUFBRSxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQzthQUNuRCxDQUFDO1lBRUYsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUV4QyxnQ0FBZ0M7WUFDaEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFcEMsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLGlDQUFpQyxPQUFPLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNsRSxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLEtBQWMsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsc0JBQXNCLEVBQUUsQ0FBQyxDQUFDO1FBQzVGLENBQUM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFDLG9CQUFvQixDQUFDLE9BQWU7UUFDaEQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLFVBQVU7WUFBRSxPQUFPO1FBRXhCLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLFVBQVUsQ0FBQyxNQUFNLEtBQUssT0FBTyxHQUFHLENBQUMsQ0FBQztRQUVwRSxVQUFVLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztRQUM1QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFFM0MsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUV6RCxnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7T0FHRztJQUNLLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxPQUFlO1FBQ3ZELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxVQUFVO1lBQUUsT0FBTztRQUV4QixJQUFJLENBQUM7WUFDSCxvQkFBb0I7WUFDcEIsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFL0UsbUNBQW1DO1lBQ25DLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztZQUVyRCx5REFBeUQ7WUFDekQscUVBQXFFO1FBRXZFLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyxnREFBZ0QsT0FBTyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbkYsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUFjO1FBQzFDLElBQUksQ0FBQztZQUNILE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUM1RixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0QsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLDJCQUEyQixNQUFNLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzRCxPQUFPLEtBQUssQ0FBQyxDQUFDLGNBQWM7UUFDOUIsQ0FBQztJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSSxvQkFBb0I7UUFDekIsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksZUFBZTtRQUNwQixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7O09BR0c7SUFDSSxLQUFLLENBQUMsZUFBZTtRQUMxQixPQUFPLENBQUMsR0FBRyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7UUFFL0MsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDdEQsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztRQUVmLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFLENBQUM7WUFDL0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLFVBQVU7Z0JBQUUsU0FBUztZQUUxQixJQUFJLENBQUM7Z0JBQ0gsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUM5RSxJQUFJLE1BQU0sRUFBRSxDQUFDO29CQUNYLE9BQU8sRUFBRSxDQUFDO29CQUNWLFVBQVUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO29CQUM1QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7b0JBQzNDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsT0FBTyxFQUFFLG1CQUFtQixDQUFDLENBQUM7Z0JBQzdELENBQUM7cUJBQU0sQ0FBQztvQkFDTixNQUFNLEVBQUUsQ0FBQztnQkFDWCxDQUFDO1lBQ0gsQ0FBQztZQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsT0FBTyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzdELE1BQU0sRUFBRSxDQUFDO1lBQ1gsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLENBQUMsR0FBRyxDQUFDLDJCQUEyQixPQUFPLGFBQWEsTUFBTSxTQUFTLENBQUMsQ0FBQztRQUM1RSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxZQUFZLENBQUMsU0FBb0M7UUFDdEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLFNBQVMsRUFBRSxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0RBQWdELENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPO1FBQ1osSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUM1QixhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7WUFDdkMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztRQUNqQyxDQUFDO1FBRUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUUxQixPQUFPLENBQUMsR0FBRyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7SUFDcEQsQ0FBQztDQUNGO0FBN25CRCxnREE2bkJDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9pdmFuL0NvZGUvdHJhZGluZy90aXRhbi9zZXJ2aWNlcy90aXRhbi1waGFzZTItaHVudGVyL3NyYy9leGVjdXRpb24vTGltaXRPcmRlckV4ZWN1dG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGltaXQgT3JkZXIgRXhlY3V0b3IgKFRoZSBTbmlwZXIpIGZvciBUaXRhbiBQaGFzZSAyIC0gVGhlIEh1bnRlclxuICogXG4gKiBJbXBsZW1lbnRzIHBhc3NpdmUgZXhlY3V0aW9uIHN0cmF0ZWd5IHVzaW5nIFBvc3QtT25seSBMaW1pdCBPcmRlcnMgYXQgT3JkZXIgQmxvY2tzLlxuICogRGVzaWduZWQgZm9yIEJ1bGdhcmlhICgyMDBtcyBsYXRlbmN5KSAtIG9yZGVycyB3YWl0IGF0IHByZS1jYWxjdWxhdGVkIGxldmVscy5cbiAqIFxuICogS2V5IEZlYXR1cmVzOlxuICogLSBQb3N0LU9ubHkgb3JkZXJzIGF0IE9yZGVyIEJsb2NrIHRvcC9ib3R0b20gKGVhcm4gTWFrZXIgcmViYXRlcylcbiAqIC0gNjAtc2Vjb25kIG9yZGVyIHRpbWVvdXQgd2l0aCBwcmljZSBtb3ZlbWVudCBjYW5jZWxsYXRpb25cbiAqIC0gVm9sYXRpbGl0eS1BZGp1c3RlZCBQb3NpdGlvbiBTaXppbmcgdXNpbmcgQVRSXG4gKiAtIDM6MSBSaXNrLVJld2FyZCByYXRpbyAoMS41JSBzdG9wLCA0LjUlIHRhcmdldClcbiAqIC0gU21hcnQgY2FuY2VsbGF0aW9uIGxvZ2ljIChwcmljZSBtb3ZlcyA+MC4yJSwgbGV2ZWwgZmFpbHMgPjAuNSUpXG4gKiBcbiAqIFJlcXVpcmVtZW50czogNy4xLTcuNyAoRXhlY3V0aW9uKVxuICovXG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgeyBcbiAgT3JkZXJQYXJhbXMsIFxuICBPcmRlclJlc3VsdCwgXG4gIE9yZGVyU3RhdHVzLCBcbiAgU2lnbmFsRGF0YSwgXG4gIEV4ZWN1dGlvbkRhdGEsXG4gIE9ITENWLFxuICBPcmRlckJsb2NrLFxuICBQb3NpdGlvblxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBCeWJpdFBlcnBzQ2xpZW50IH0gZnJvbSAnLi4vZXhjaGFuZ2VzL0J5Yml0UGVycHNDbGllbnQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbWl0T3JkZXJDb25maWcge1xuICBvcmRlclRpbWVvdXQ6IG51bWJlcjsgLy8gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDYwMDAwKVxuICBwcmljZU1vdmVDYW5jZWxUaHJlc2hvbGQ6IG51bWJlcjsgLy8gUHJpY2UgbW92ZSAlIHRvIGNhbmNlbCAoZGVmYXVsdDogMC4wMDIgPSAwLjIlKVxuICBsZXZlbEZhaWxUaHJlc2hvbGQ6IG51bWJlcjsgLy8gV2ljayAlIHRvIGNhbmNlbCAoZGVmYXVsdDogMC4wMDUgPSAwLjUlKVxuICBzdG9wTG9zc1BlcmNlbnQ6IG51bWJlcjsgLy8gU3RvcCBsb3NzICUgZnJvbSBlbnRyeSAoZGVmYXVsdDogMC4wMTUgPSAxLjUlKVxuICB0YWtlUHJvZml0UGVyY2VudDogbnVtYmVyOyAvLyBUYWtlIHByb2ZpdCAlIGZyb20gZW50cnkgKGRlZmF1bHQ6IDAuMDQ1ID0gNC41JSlcbiAgYXRyUGVyaW9kOiBudW1iZXI7IC8vIEFUUiBjYWxjdWxhdGlvbiBwZXJpb2QgKGRlZmF1bHQ6IDE0KVxuICBtYXhSZXRyaWVzOiBudW1iZXI7IC8vIE1heGltdW0gb3JkZXIgcmV0cnkgYXR0ZW1wdHMgKGRlZmF1bHQ6IDIpXG4gIHJldHJ5RGVsYXk6IG51bWJlcjsgLy8gRGVsYXkgYmV0d2VlbiByZXRyaWVzIGluIG1zIChkZWZhdWx0OiAxMDAwKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvblJlc3VsdCB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIG9yZGVySWQ/OiBzdHJpbmc7XG4gIGZpbGxQcmljZT86IG51bWJlcjtcbiAgcG9zaXRpb25TaXplPzogbnVtYmVyO1xuICBzdG9wTG9zcz86IG51bWJlcjtcbiAgdGFrZVByb2ZpdD86IG51bWJlcjtcbiAgcmVhc29uPzogc3RyaW5nO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcmRlck1vbml0b3JpbmdTdGF0ZSB7XG4gIG9yZGVySWQ6IHN0cmluZztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIGVudHJ5UHJpY2U6IG51bWJlcjtcbiAgb3JkZXJCbG9jazogT3JkZXJCbG9jaztcbiAgc3RhcnRUaW1lOiBudW1iZXI7XG4gIGNhbmNlbGxlZDogYm9vbGVhbjtcbiAgZmlsbGVkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbWl0T3JkZXJFeGVjdXRvckV2ZW50cyB7XG4gICdvcmRlcjpwbGFjZWQnOiAob3JkZXJJZDogc3RyaW5nLCBzeW1ib2w6IHN0cmluZywgcHJpY2U6IG51bWJlcikgPT4gdm9pZDtcbiAgJ29yZGVyOmZpbGxlZCc6IChvcmRlcklkOiBzdHJpbmcsIGZpbGxQcmljZTogbnVtYmVyLCBwb3NpdGlvblNpemU6IG51bWJlcikgPT4gdm9pZDtcbiAgJ29yZGVyOmNhbmNlbGxlZCc6IChvcmRlcklkOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKSA9PiB2b2lkO1xuICAnb3JkZXI6dGltZW91dCc6IChvcmRlcklkOiBzdHJpbmcpID0+IHZvaWQ7XG4gICdwb3NpdGlvbjpjcmVhdGVkJzogKHBvc2l0aW9uOiBQb3NpdGlvbikgPT4gdm9pZDtcbiAgJ2V4ZWN1dGlvbjplcnJvcic6IChlcnJvcjogRXJyb3IsIGNvbnRleHQ6IGFueSkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIExpbWl0T3JkZXJFeGVjdXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgYnliaXRDbGllbnQ6IEJ5Yml0UGVycHNDbGllbnQ7XG4gIHByaXZhdGUgY29uZmlnOiBMaW1pdE9yZGVyQ29uZmlnO1xuICBwcml2YXRlIGFjdGl2ZU9yZGVyczogTWFwPHN0cmluZywgT3JkZXJNb25pdG9yaW5nU3RhdGU+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIG1vbml0b3JpbmdJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBNT05JVE9SSU5HX0ZSRVFVRU5DWSA9IDEwMDA7IC8vIDEgc2Vjb25kXG5cbiAgY29uc3RydWN0b3IoYnliaXRDbGllbnQ6IEJ5Yml0UGVycHNDbGllbnQsIGNvbmZpZz86IFBhcnRpYWw8TGltaXRPcmRlckNvbmZpZz4pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuYnliaXRDbGllbnQgPSBieWJpdENsaWVudDtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIG9yZGVyVGltZW91dDogNjAwMDAsIC8vIDYwIHNlY29uZHNcbiAgICAgIHByaWNlTW92ZUNhbmNlbFRocmVzaG9sZDogMC4wMDIsIC8vIDAuMiVcbiAgICAgIGxldmVsRmFpbFRocmVzaG9sZDogMC4wMDUsIC8vIDAuNSVcbiAgICAgIHN0b3BMb3NzUGVyY2VudDogMC4wMTUsIC8vIDEuNSVcbiAgICAgIHRha2VQcm9maXRQZXJjZW50OiAwLjA0NSwgLy8gNC41JVxuICAgICAgYXRyUGVyaW9kOiAxNCxcbiAgICAgIG1heFJldHJpZXM6IDIsXG4gICAgICByZXRyeURlbGF5OiAxMDAwLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcblxuICAgIC8vIFN0YXJ0IG9yZGVyIG1vbml0b3JpbmdcbiAgICB0aGlzLnN0YXJ0TW9uaXRvcmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYWNlIFBvc3QtT25seSBMaW1pdCBPcmRlciBhdCBPcmRlciBCbG9jayB0b3AvYm90dG9tXG4gICAqIEBwYXJhbSBzaWduYWwgLSBTaWduYWwgZGF0YSB3aXRoIGVudHJ5IGRldGFpbHNcbiAgICogQHBhcmFtIG9yZGVyQmxvY2sgLSBPcmRlciBCbG9jayBmb3IgZW50cnkgbGV2ZWxcbiAgICogQHBhcmFtIGVxdWl0eSAtIEN1cnJlbnQgYWNjb3VudCBlcXVpdHkgZm9yIHBvc2l0aW9uIHNpemluZ1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZXhlY3V0aW9uIHJlc3VsdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHBsYWNlUG9zdE9ubHlPcmRlcihcbiAgICBzaWduYWw6IFNpZ25hbERhdGEsIFxuICAgIG9yZGVyQmxvY2s6IE9yZGVyQmxvY2ssIFxuICAgIGVxdWl0eTogbnVtYmVyXG4gICk6IFByb21pc2U8RXhlY3V0aW9uUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBsYWNpbmcgUG9zdC1Pbmx5IG9yZGVyIGZvciAke3NpZ25hbC5zeW1ib2x9ICR7c2lnbmFsLmRpcmVjdGlvbn1gKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGVudHJ5IHByaWNlIGF0IE9yZGVyIEJsb2NrIGxldmVsXG4gICAgICBjb25zdCBlbnRyeVByaWNlID0gc2lnbmFsLmRpcmVjdGlvbiA9PT0gJ0xPTkcnIFxuICAgICAgICA/IG9yZGVyQmxvY2subG93ICAvLyBFbnRlciBhdCBPQiBib3R0b20gZm9yIGxvbmdzXG4gICAgICAgIDogb3JkZXJCbG9jay5oaWdoOyAvLyBFbnRlciBhdCBPQiB0b3AgZm9yIHNob3J0c1xuXG4gICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gc2l6ZSB1c2luZyBWb2xhdGlsaXR5LUFkanVzdGVkIFNpemluZ1xuICAgICAgY29uc3QgcG9zaXRpb25TaXplID0gYXdhaXQgdGhpcy5jYWxjUG9zaXRpb25TaXplKFxuICAgICAgICBzaWduYWwuc3ltYm9sLCBcbiAgICAgICAgZW50cnlQcmljZSwgXG4gICAgICAgIGVxdWl0eSwgXG4gICAgICAgIHNpZ25hbC5sZXZlcmFnZVxuICAgICAgKTtcblxuICAgICAgaWYgKHBvc2l0aW9uU2l6ZSA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdQb3NpdGlvbiBzaXplIGNhbGN1bGF0aW9uIGZhaWxlZCBvciB0b28gc21hbGwnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdG9wIGxvc3MgYW5kIHRha2UgcHJvZml0XG4gICAgICBjb25zdCB7IHN0b3BMb3NzLCB0YWtlUHJvZml0IH0gPSB0aGlzLnNldFN0b3BBbmRUYXJnZXQoZW50cnlQcmljZSwgc2lnbmFsLmRpcmVjdGlvbik7XG5cbiAgICAgIC8vIFByZXBhcmUgb3JkZXIgcGFyYW1ldGVyc1xuICAgICAgY29uc3Qgb3JkZXJQYXJhbXM6IE9yZGVyUGFyYW1zID0ge1xuICAgICAgICBwaGFzZTogJ3BoYXNlMicsXG4gICAgICAgIHN5bWJvbDogc2lnbmFsLnN5bWJvbCxcbiAgICAgICAgc2lkZTogc2lnbmFsLmRpcmVjdGlvbiA9PT0gJ0xPTkcnID8gJ0J1eScgOiAnU2VsbCcsXG4gICAgICAgIHR5cGU6ICdQT1NUX09OTFknLFxuICAgICAgICBwcmljZTogZW50cnlQcmljZSxcbiAgICAgICAgcXR5OiBwb3NpdGlvblNpemUsXG4gICAgICAgIGxldmVyYWdlOiBzaWduYWwubGV2ZXJhZ2UsXG4gICAgICAgIHN0b3BMb3NzLFxuICAgICAgICB0YWtlUHJvZml0XG4gICAgICB9O1xuXG4gICAgICAvLyBQbGFjZSBvcmRlciB3aXRoIHJldHJ5IGxvZ2ljXG4gICAgICBjb25zdCBvcmRlclJlc3VsdCA9IGF3YWl0IHRoaXMuYnliaXRDbGllbnQucGxhY2VPcmRlcldpdGhSZXRyeShcbiAgICAgICAgb3JkZXJQYXJhbXMsIFxuICAgICAgICB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzXG4gICAgICApO1xuXG4gICAgICBpZiAob3JkZXJSZXN1bHQub3JkZXJJZCkge1xuICAgICAgICAvLyBTdGFydCBtb25pdG9yaW5nIHRoZSBvcmRlclxuICAgICAgICB0aGlzLnN0YXJ0T3JkZXJNb25pdG9yaW5nKG9yZGVyUmVzdWx0Lm9yZGVySWQsIHNpZ25hbC5zeW1ib2wsIGVudHJ5UHJpY2UsIG9yZGVyQmxvY2spO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdvcmRlcjpwbGFjZWQnLCBvcmRlclJlc3VsdC5vcmRlcklkLCBzaWduYWwuc3ltYm9sLCBlbnRyeVByaWNlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgUG9zdC1Pbmx5IG9yZGVyIHBsYWNlZDogJHtzaWduYWwuc3ltYm9sfSBAICR7ZW50cnlQcmljZX0gKElEOiAke29yZGVyUmVzdWx0Lm9yZGVySWR9KWApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIG9yZGVySWQ6IG9yZGVyUmVzdWx0Lm9yZGVySWQsXG4gICAgICAgICAgcG9zaXRpb25TaXplLFxuICAgICAgICAgIHN0b3BMb3NzLFxuICAgICAgICAgIHRha2VQcm9maXRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnT3JkZXIgcGxhY2VtZW50IGZhaWxlZCAtIG5vIG9yZGVyIElEIHJldHVybmVkJ1xuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1zZyA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBwbGFjZSBQb3N0LU9ubHkgb3JkZXIgZm9yICR7c2lnbmFsLnN5bWJvbH06YCwgZXJyb3JNc2cpO1xuICAgICAgXG4gICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGlvbjplcnJvcicsIGVycm9yIGFzIEVycm9yLCB7IHNpZ25hbCwgb3JkZXJCbG9jayB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvck1zZ1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9uaXRvciBvcmRlciB3aXRoIDYwLXNlY29uZCB0aW1lb3V0XG4gICAqIEBwYXJhbSBvcmRlcklkIC0gT3JkZXIgSUQgdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gc3ltYm9sIC0gVHJhZGluZyBzeW1ib2xcbiAgICogQHBhcmFtIGVudHJ5UHJpY2UgLSBFeHBlY3RlZCBlbnRyeSBwcmljZVxuICAgKiBAcGFyYW0gb3JkZXJCbG9jayAtIE9yZGVyIEJsb2NrIHJlZmVyZW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGFydE9yZGVyTW9uaXRvcmluZyhcbiAgICBvcmRlcklkOiBzdHJpbmcsIFxuICAgIHN5bWJvbDogc3RyaW5nLCBcbiAgICBlbnRyeVByaWNlOiBudW1iZXIsIFxuICAgIG9yZGVyQmxvY2s6IE9yZGVyQmxvY2tcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgbW9uaXRvcmluZ1N0YXRlOiBPcmRlck1vbml0b3JpbmdTdGF0ZSA9IHtcbiAgICAgIG9yZGVySWQsXG4gICAgICBzeW1ib2wsXG4gICAgICBlbnRyeVByaWNlLFxuICAgICAgb3JkZXJCbG9jayxcbiAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgIGNhbmNlbGxlZDogZmFsc2UsXG4gICAgICBmaWxsZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuYWN0aXZlT3JkZXJzLnNldChvcmRlcklkLCBtb25pdG9yaW5nU3RhdGUpO1xuICAgIGNvbnNvbGUubG9nKGDwn5GB77iPIFN0YXJ0ZWQgbW9uaXRvcmluZyBvcmRlciAke29yZGVySWR9IGZvciAke3N5bWJvbH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb25pdG9yIG9yZGVyIGFuZCBjYW5jZWwgaWYgcHJpY2UgbW92ZXMgYXdheSA+IDAuMiVcbiAgICogQHBhcmFtIG9yZGVySWQgLSBPcmRlciBJRCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjdXJyZW50UHJpY2UgLSBDdXJyZW50IG1hcmtldCBwcmljZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggY2FuY2VsbGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNhbmNlbElmUHJpY2VNb3ZlcyhvcmRlcklkOiBzdHJpbmcsIGN1cnJlbnRQcmljZTogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qgb3JkZXJTdGF0ZSA9IHRoaXMuYWN0aXZlT3JkZXJzLmdldChvcmRlcklkKTtcbiAgICBpZiAoIW9yZGVyU3RhdGUgfHwgb3JkZXJTdGF0ZS5jYW5jZWxsZWQgfHwgb3JkZXJTdGF0ZS5maWxsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgcHJpY2UgbW92ZW1lbnQgZnJvbSBlbnRyeSBsZXZlbFxuICAgIGNvbnN0IHByaWNlTW92ZSA9IE1hdGguYWJzKGN1cnJlbnRQcmljZSAtIG9yZGVyU3RhdGUuZW50cnlQcmljZSkgLyBvcmRlclN0YXRlLmVudHJ5UHJpY2U7XG4gICAgXG4gICAgaWYgKHByaWNlTW92ZSA+IHRoaXMuY29uZmlnLnByaWNlTW92ZUNhbmNlbFRocmVzaG9sZCkge1xuICAgICAgY29uc29sZS5sb2coYPCfk4kgUHJpY2UgbW92ZWQgJHsocHJpY2VNb3ZlICogMTAwKS50b0ZpeGVkKDIpfSUgYXdheSBmcm9tICR7b3JkZXJTdGF0ZS5zeW1ib2x9IG9yZGVyLCBjYW5jZWxsaW5nYCk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLmJ5Yml0Q2xpZW50LmNhbmNlbE9yZGVyKG9yZGVySWQsIG9yZGVyU3RhdGUuc3ltYm9sKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgb3JkZXJTdGF0ZS5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYWN0aXZlT3JkZXJzLnNldChvcmRlcklkLCBvcmRlclN0YXRlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ29yZGVyOmNhbmNlbGxlZCcsIG9yZGVySWQsICdQUklDRV9NT1ZFRF9BV0FZJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBPcmRlciBjYW5jZWxsZWQgZHVlIHRvIHByaWNlIG1vdmVtZW50OiAke29yZGVySWR9YCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gY2FuY2VsIG9yZGVyICR7b3JkZXJJZH06YCwgZXJyb3IpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGlvbjplcnJvcicsIGVycm9yIGFzIEVycm9yLCB7IG9yZGVySWQsIHJlYXNvbjogJ0NBTkNFTF9GQUlMRUQnIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgb3JkZXIgd2hlbiBwcmljZSB3aWNrcyB0aHJvdWdoIE9yZGVyIEJsb2NrID4gMC41JVxuICAgKiBAcGFyYW0gb3JkZXJJZCAtIE9yZGVyIElEIHRvIG1vbml0b3JcbiAgICogQHBhcmFtIGN1cnJlbnRDYW5kbGUgLSBDdXJyZW50IE9ITENWIGNhbmRsZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggY2FuY2VsbGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNhbmNlbElmTGV2ZWxGYWlscyhvcmRlcklkOiBzdHJpbmcsIGN1cnJlbnRDYW5kbGU6IE9ITENWKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qgb3JkZXJTdGF0ZSA9IHRoaXMuYWN0aXZlT3JkZXJzLmdldChvcmRlcklkKTtcbiAgICBpZiAoIW9yZGVyU3RhdGUgfHwgb3JkZXJTdGF0ZS5jYW5jZWxsZWQgfHwgb3JkZXJTdGF0ZS5maWxsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvcmRlckJsb2NrID0gb3JkZXJTdGF0ZS5vcmRlckJsb2NrO1xuICAgIGxldCB3aWNrVGhyb3VnaCA9IGZhbHNlO1xuICAgIGxldCB3aWNrUGVyY2VudCA9IDA7XG5cbiAgICBpZiAob3JkZXJCbG9jay50eXBlID09PSAnQlVMTElTSCcpIHtcbiAgICAgIC8vIEZvciBidWxsaXNoIE9CLCBjaGVjayBpZiBwcmljZSB3aWNrZWQgYmVsb3cgT0IgbG93XG4gICAgICBpZiAoY3VycmVudENhbmRsZS5sb3cgPCBvcmRlckJsb2NrLmxvdykge1xuICAgICAgICB3aWNrUGVyY2VudCA9IChvcmRlckJsb2NrLmxvdyAtIGN1cnJlbnRDYW5kbGUubG93KSAvIG9yZGVyQmxvY2subG93O1xuICAgICAgICB3aWNrVGhyb3VnaCA9IHdpY2tQZXJjZW50ID4gdGhpcy5jb25maWcubGV2ZWxGYWlsVGhyZXNob2xkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYmVhcmlzaCBPQiwgY2hlY2sgaWYgcHJpY2Ugd2lja2VkIGFib3ZlIE9CIGhpZ2hcbiAgICAgIGlmIChjdXJyZW50Q2FuZGxlLmhpZ2ggPiBvcmRlckJsb2NrLmhpZ2gpIHtcbiAgICAgICAgd2lja1BlcmNlbnQgPSAoY3VycmVudENhbmRsZS5oaWdoIC0gb3JkZXJCbG9jay5oaWdoKSAvIG9yZGVyQmxvY2suaGlnaDtcbiAgICAgICAgd2lja1Rocm91Z2ggPSB3aWNrUGVyY2VudCA+IHRoaXMuY29uZmlnLmxldmVsRmFpbFRocmVzaG9sZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lja1Rocm91Z2gpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5KlIE9yZGVyIEJsb2NrIGxldmVsIGZhaWxlZCBmb3IgJHtvcmRlclN0YXRlLnN5bWJvbH0gKCR7KHdpY2tQZXJjZW50ICogMTAwKS50b0ZpeGVkKDIpfSUgd2ljayksIGNhbmNlbGxpbmdgKTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuYnliaXRDbGllbnQuY2FuY2VsT3JkZXIob3JkZXJJZCwgb3JkZXJTdGF0ZS5zeW1ib2wpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBvcmRlclN0YXRlLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hY3RpdmVPcmRlcnMuc2V0KG9yZGVySWQsIG9yZGVyU3RhdGUpO1xuICAgICAgICAgIHRoaXMuZW1pdCgnb3JkZXI6Y2FuY2VsbGVkJywgb3JkZXJJZCwgJ0xFVkVMX0ZBSUxFRCcpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgT3JkZXIgY2FuY2VsbGVkIGR1ZSB0byBsZXZlbCBmYWlsdXJlOiAke29yZGVySWR9YCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gY2FuY2VsIG9yZGVyICR7b3JkZXJJZH06YCwgZXJyb3IpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGlvbjplcnJvcicsIGVycm9yIGFzIEVycm9yLCB7IG9yZGVySWQsIHJlYXNvbjogJ0NBTkNFTF9GQUlMRUQnIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgcG9zaXRpb24gc2l6ZSB1c2luZyBWb2xhdGlsaXR5LUFkanVzdGVkIFNpemluZ1xuICAgKiBAcGFyYW0gc3ltYm9sIC0gVHJhZGluZyBzeW1ib2xcbiAgICogQHBhcmFtIGVudHJ5UHJpY2UgLSBFbnRyeSBwcmljZVxuICAgKiBAcGFyYW0gZXF1aXR5IC0gQWNjb3VudCBlcXVpdHlcbiAgICogQHBhcmFtIGxldmVyYWdlIC0gTGV2ZXJhZ2UgbXVsdGlwbGllclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcG9zaXRpb24gc2l6ZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNhbGNQb3NpdGlvblNpemUoXG4gICAgc3ltYm9sOiBzdHJpbmcsIFxuICAgIGVudHJ5UHJpY2U6IG51bWJlciwgXG4gICAgZXF1aXR5OiBudW1iZXIsIFxuICAgIGxldmVyYWdlOiBudW1iZXJcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggcmVjZW50IE9ITENWIGRhdGEgZm9yIEFUUiBjYWxjdWxhdGlvblxuICAgICAgY29uc3QgY2FuZGxlcyA9IGF3YWl0IHRoaXMuYnliaXRDbGllbnQuZmV0Y2hPSExDVihzeW1ib2wsICcxaCcsIHRoaXMuY29uZmlnLmF0clBlcmlvZCArIDEwKTtcbiAgICAgIFxuICAgICAgaWYgKGNhbmRsZXMubGVuZ3RoIDwgdGhpcy5jb25maWcuYXRyUGVyaW9kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGNhbmRsZSBkYXRhIGZvciBBVFIgY2FsY3VsYXRpb246ICR7Y2FuZGxlcy5sZW5ndGh9IDwgJHt0aGlzLmNvbmZpZy5hdHJQZXJpb2R9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBBVFIgKEF2ZXJhZ2UgVHJ1ZSBSYW5nZSlcbiAgICAgIGNvbnN0IGF0ciA9IHRoaXMuY2FsY3VsYXRlQVRSKGNhbmRsZXMsIHRoaXMuY29uZmlnLmF0clBlcmlvZCk7XG4gICAgICBcbiAgICAgIC8vIFJpc2sgYW1vdW50ICgyJSBvZiBlcXVpdHkgYnkgZGVmYXVsdClcbiAgICAgIGNvbnN0IHJpc2tQZXJjZW50ID0gMC4wMjsgLy8gMiUgcmlzayBwZXIgdHJhZGVcbiAgICAgIGNvbnN0IHJpc2tBbW91bnQgPSBlcXVpdHkgKiByaXNrUGVyY2VudDtcbiAgICAgIFxuICAgICAgLy8gU3RvcCBkaXN0YW5jZSBpbiBwcmljZSB0ZXJtc1xuICAgICAgY29uc3Qgc3RvcERpc3RhbmNlID0gZW50cnlQcmljZSAqIHRoaXMuY29uZmlnLnN0b3BMb3NzUGVyY2VudDtcbiAgICAgIFxuICAgICAgLy8gVm9sYXRpbGl0eS1BZGp1c3RlZCBTaXppbmc6IFJpc2tfRG9sbGFycyAvIChBVFIgKiBTdG9wX0Rpc3RhbmNlX011bHRpcGxpZXIpXG4gICAgICAvLyBVc2UgQVRSIGFzIHZvbGF0aWxpdHkgYWRqdXN0bWVudCBmYWN0b3JcbiAgICAgIGNvbnN0IHZvbGF0aWxpdHlBZGp1c3RtZW50ID0gYXRyIC8gZW50cnlQcmljZTsgLy8gQVRSIGFzICUgb2YgcHJpY2VcbiAgICAgIGNvbnN0IGFkanVzdGVkU3RvcERpc3RhbmNlID0gc3RvcERpc3RhbmNlICogKDEgKyB2b2xhdGlsaXR5QWRqdXN0bWVudCk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBiYXNlIHBvc2l0aW9uIHNpemVcbiAgICAgIGNvbnN0IGJhc2VQb3NpdGlvblNpemUgPSByaXNrQW1vdW50IC8gYWRqdXN0ZWRTdG9wRGlzdGFuY2U7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IGxldmVyYWdlIChidXQgY2FwIGF0IHJlYXNvbmFibGUgbGV2ZWxzKVxuICAgICAgY29uc3QgbWF4TGV2ZXJhZ2VNdWx0aXBsaWVyID0gTWF0aC5taW4obGV2ZXJhZ2UsIDUpOyAvLyBDYXAgYXQgNXggZm9yIHNhZmV0eVxuICAgICAgY29uc3QgcG9zaXRpb25TaXplID0gYmFzZVBvc2l0aW9uU2l6ZSAqIG1heExldmVyYWdlTXVsdGlwbGllcjtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIG1pbmltdW0gcG9zaXRpb24gc2l6ZSAoMC4wMDEgZm9yIG1vc3Qgc3ltYm9scylcbiAgICAgIGNvbnN0IG1pblBvc2l0aW9uU2l6ZSA9IDAuMDAxO1xuICAgICAgY29uc3QgZmluYWxQb3NpdGlvblNpemUgPSBNYXRoLm1heChwb3NpdGlvblNpemUsIG1pblBvc2l0aW9uU2l6ZSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFBvc2l0aW9uIHNpemluZyBmb3IgJHtzeW1ib2x9OmApO1xuICAgICAgY29uc29sZS5sb2coYCAgIEFUUjogJHthdHIudG9GaXhlZCg0KX0gKCR7KHZvbGF0aWxpdHlBZGp1c3RtZW50ICogMTAwKS50b0ZpeGVkKDIpfSUpYCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgUmlzayBBbW91bnQ6ICQke3Jpc2tBbW91bnQudG9GaXhlZCgyKX1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgICBTdG9wIERpc3RhbmNlOiAke3N0b3BEaXN0YW5jZS50b0ZpeGVkKDQpfSAoJHsodGhpcy5jb25maWcuc3RvcExvc3NQZXJjZW50ICogMTAwKS50b0ZpeGVkKDEpfSUpYCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgUG9zaXRpb24gU2l6ZTogJHtmaW5hbFBvc2l0aW9uU2l6ZS50b0ZpeGVkKDQpfWApO1xuICAgICAgXG4gICAgICByZXR1cm4gZmluYWxQb3NpdGlvblNpemU7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBjYWxjdWxhdGUgcG9zaXRpb24gc2l6ZSBmb3IgJHtzeW1ib2x9OmAsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zaXRpb24gc2l6ZSBjYWxjdWxhdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzdG9wIGxvc3MgYW5kIHRha2UgcHJvZml0IHdpdGggMS41JSBzdG9wLCA0LjUlIHRhcmdldCAoMzoxIFI6UilcbiAgICogQHBhcmFtIGVudHJ5UHJpY2UgLSBFbnRyeSBwcmljZVxuICAgKiBAcGFyYW0gZGlyZWN0aW9uIC0gVHJhZGUgZGlyZWN0aW9uXG4gICAqIEByZXR1cm5zIFN0b3AgbG9zcyBhbmQgdGFrZSBwcm9maXQgcHJpY2VzXG4gICAqL1xuICBwdWJsaWMgc2V0U3RvcEFuZFRhcmdldChlbnRyeVByaWNlOiBudW1iZXIsIGRpcmVjdGlvbjogJ0xPTkcnIHwgJ1NIT1JUJyk6IHtcbiAgICBzdG9wTG9zczogbnVtYmVyO1xuICAgIHRha2VQcm9maXQ6IG51bWJlcjtcbiAgfSB7XG4gICAgY29uc3Qgc3RvcERpc3RhbmNlID0gZW50cnlQcmljZSAqIHRoaXMuY29uZmlnLnN0b3BMb3NzUGVyY2VudDtcbiAgICBjb25zdCB0YXJnZXREaXN0YW5jZSA9IGVudHJ5UHJpY2UgKiB0aGlzLmNvbmZpZy50YWtlUHJvZml0UGVyY2VudDtcblxuICAgIGxldCBzdG9wTG9zczogbnVtYmVyO1xuICAgIGxldCB0YWtlUHJvZml0OiBudW1iZXI7XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSAnTE9ORycpIHtcbiAgICAgIHN0b3BMb3NzID0gZW50cnlQcmljZSAtIHN0b3BEaXN0YW5jZTsgICAvLyAxLjUlIGJlbG93IGVudHJ5XG4gICAgICB0YWtlUHJvZml0ID0gZW50cnlQcmljZSArIHRhcmdldERpc3RhbmNlOyAvLyA0LjUlIGFib3ZlIGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3BMb3NzID0gZW50cnlQcmljZSArIHN0b3BEaXN0YW5jZTsgICAvLyAxLjUlIGFib3ZlIGVudHJ5XG4gICAgICB0YWtlUHJvZml0ID0gZW50cnlQcmljZSAtIHRhcmdldERpc3RhbmNlOyAvLyA0LjUlIGJlbG93IGVudHJ5XG4gICAgfVxuXG4gICAgY29uc3Qgcmlza1Jld2FyZCA9IHRhcmdldERpc3RhbmNlIC8gc3RvcERpc3RhbmNlO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn46vIFN0b3AgJiBUYXJnZXQgZm9yICR7ZGlyZWN0aW9ufSBAICR7ZW50cnlQcmljZS50b0ZpeGVkKDQpfTpgKTtcbiAgICBjb25zb2xlLmxvZyhgICAgU3RvcCBMb3NzOiAke3N0b3BMb3NzLnRvRml4ZWQoNCl9ICgtJHsodGhpcy5jb25maWcuc3RvcExvc3NQZXJjZW50ICogMTAwKS50b0ZpeGVkKDEpfSUpYCk7XG4gICAgY29uc29sZS5sb2coYCAgIFRha2UgUHJvZml0OiAke3Rha2VQcm9maXQudG9GaXhlZCg0KX0gKCskeyh0aGlzLmNvbmZpZy50YWtlUHJvZml0UGVyY2VudCAqIDEwMCkudG9GaXhlZCgxKX0lKWApO1xuICAgIGNvbnNvbGUubG9nKGAgICBSaXNrOlJld2FyZCA9IDE6JHtyaXNrUmV3YXJkLnRvRml4ZWQoMSl9YCk7XG5cbiAgICByZXR1cm4geyBzdG9wTG9zcywgdGFrZVByb2ZpdCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBBdmVyYWdlIFRydWUgUmFuZ2UgKEFUUilcbiAgICogQHBhcmFtIGNhbmRsZXMgLSBPSExDViBjYW5kbGUgZGF0YVxuICAgKiBAcGFyYW0gcGVyaW9kIC0gQVRSIHBlcmlvZCAoZGVmYXVsdDogMTQpXG4gICAqIEByZXR1cm5zIEFUUiB2YWx1ZVxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBVFIoY2FuZGxlczogT0hMQ1ZbXSwgcGVyaW9kOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChjYW5kbGVzLmxlbmd0aCA8IHBlcmlvZCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGRhdGEgZm9yIEFUUiBjYWxjdWxhdGlvbjogbmVlZCAke3BlcmlvZCArIDF9LCBnb3QgJHtjYW5kbGVzLmxlbmd0aH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cnVlUmFuZ2VzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgLy8gQ2FsY3VsYXRlIFRydWUgUmFuZ2UgZm9yIGVhY2ggY2FuZGxlIChzdGFydGluZyBmcm9tIGluZGV4IDEpXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjYW5kbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gY2FuZGxlc1tpXTtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gY2FuZGxlc1tpIC0gMV07XG5cbiAgICAgIC8vIFRydWUgUmFuZ2UgPSBtYXgoaGlnaC1sb3csIHxoaWdoLXByZXZDbG9zZXwsIHxsb3ctcHJldkNsb3NlfClcbiAgICAgIGNvbnN0IGhpZ2hMb3cgPSBjdXJyZW50LmhpZ2ggLSBjdXJyZW50LmxvdztcbiAgICAgIGNvbnN0IGhpZ2hQcmV2Q2xvc2UgPSBNYXRoLmFicyhjdXJyZW50LmhpZ2ggLSBwcmV2aW91cy5jbG9zZSk7XG4gICAgICBjb25zdCBsb3dQcmV2Q2xvc2UgPSBNYXRoLmFicyhjdXJyZW50LmxvdyAtIHByZXZpb3VzLmNsb3NlKTtcblxuICAgICAgY29uc3QgdHJ1ZVJhbmdlID0gTWF0aC5tYXgoaGlnaExvdywgaGlnaFByZXZDbG9zZSwgbG93UHJldkNsb3NlKTtcbiAgICAgIHRydWVSYW5nZXMucHVzaCh0cnVlUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBBVFIgYXMgU2ltcGxlIE1vdmluZyBBdmVyYWdlIG9mIFRydWUgUmFuZ2VzXG4gICAgY29uc3QgcmVjZW50VHJ1ZVJhbmdlcyA9IHRydWVSYW5nZXMuc2xpY2UoLXBlcmlvZCk7XG4gICAgY29uc3QgYXRyID0gcmVjZW50VHJ1ZVJhbmdlcy5yZWR1Y2UoKHN1bSwgdHIpID0+IHN1bSArIHRyLCAwKSAvIHBlcmlvZDtcblxuICAgIHJldHVybiBhdHI7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbW9uaXRvcmluZyBhbGwgYWN0aXZlIG9yZGVyc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGFydE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKTtcbiAgICB9XG5cbiAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMubW9uaXRvckFjdGl2ZU9yZGVycygpO1xuICAgIH0sIHRoaXMuTU9OSVRPUklOR19GUkVRVUVOQ1kpO1xuXG4gICAgY29uc29sZS5sb2coYPCfkYHvuI8gTGltaXQgT3JkZXIgRXhlY3V0b3I6IFN0YXJ0ZWQgbW9uaXRvcmluZyAoJHt0aGlzLk1PTklUT1JJTkdfRlJFUVVFTkNZfW1zIGludGVydmFsKWApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vbml0b3IgYWxsIGFjdGl2ZSBvcmRlcnMgZm9yIHRpbWVvdXQsIGZpbGxzLCBhbmQgY2FuY2VsbGF0aW9uIGNvbmRpdGlvbnNcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbW9uaXRvckFjdGl2ZU9yZGVycygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBhY3RpdmVPcmRlcklkcyA9IEFycmF5LmZyb20odGhpcy5hY3RpdmVPcmRlcnMua2V5cygpKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IG9yZGVySWQgb2YgYWN0aXZlT3JkZXJJZHMpIHtcbiAgICAgIGNvbnN0IG9yZGVyU3RhdGUgPSB0aGlzLmFjdGl2ZU9yZGVycy5nZXQob3JkZXJJZCk7XG4gICAgICBpZiAoIW9yZGVyU3RhdGUgfHwgb3JkZXJTdGF0ZS5jYW5jZWxsZWQgfHwgb3JkZXJTdGF0ZS5maWxsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGZvciB0aW1lb3V0ICg2MCBzZWNvbmRzKVxuICAgICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIG9yZGVyU3RhdGUuc3RhcnRUaW1lO1xuICAgICAgICBpZiAoZWxhcHNlZCA+IHRoaXMuY29uZmlnLm9yZGVyVGltZW91dCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlT3JkZXJUaW1lb3V0KG9yZGVySWQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgb3JkZXIgc3RhdHVzXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuYnliaXRDbGllbnQuZ2V0T3JkZXJTdGF0dXMob3JkZXJJZCwgb3JkZXJTdGF0ZS5zeW1ib2wpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ0ZJTExFRCcpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZU9yZGVyRmlsbGVkKG9yZGVySWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gJ0NBTkNFTExFRCcpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZU9yZGVyQ2FuY2VsbGVkKG9yZGVySWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9yZGVyIHN0aWxsIGFjdGl2ZSwgY2hlY2sgY2FuY2VsbGF0aW9uIGNvbmRpdGlvbnNcbiAgICAgICAgICBhd2FpdCB0aGlzLmNoZWNrQ2FuY2VsbGF0aW9uQ29uZGl0aW9ucyhvcmRlcklkKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgbW9uaXRvcmluZyBvcmRlciAke29yZGVySWR9OmAsIGVycm9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRpb246ZXJyb3InLCBlcnJvciBhcyBFcnJvciwgeyBvcmRlcklkLCBhY3Rpb246ICdNT05JVE9SSU5HJyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG9yZGVyIHRpbWVvdXQgKDYwIHNlY29uZHMpXG4gICAqIEBwYXJhbSBvcmRlcklkIC0gT3JkZXIgSUQgdGhhdCB0aW1lZCBvdXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlT3JkZXJUaW1lb3V0KG9yZGVySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG9yZGVyU3RhdGUgPSB0aGlzLmFjdGl2ZU9yZGVycy5nZXQob3JkZXJJZCk7XG4gICAgaWYgKCFvcmRlclN0YXRlKSByZXR1cm47XG5cbiAgICBjb25zb2xlLmxvZyhg4o+wIE9yZGVyIHRpbWVvdXQgZm9yICR7b3JkZXJTdGF0ZS5zeW1ib2x9OiAke29yZGVySWR9YCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ2FuY2VsIHRoZSB0aW1lZC1vdXQgb3JkZXJcbiAgICAgIGF3YWl0IHRoaXMuYnliaXRDbGllbnQuY2FuY2VsT3JkZXIob3JkZXJJZCwgb3JkZXJTdGF0ZS5zeW1ib2wpO1xuICAgICAgXG4gICAgICBvcmRlclN0YXRlLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICB0aGlzLmFjdGl2ZU9yZGVycy5zZXQob3JkZXJJZCwgb3JkZXJTdGF0ZSk7XG4gICAgICBcbiAgICAgIHRoaXMuZW1pdCgnb3JkZXI6dGltZW91dCcsIG9yZGVySWQpO1xuICAgICAgdGhpcy5lbWl0KCdvcmRlcjpjYW5jZWxsZWQnLCBvcmRlcklkLCAnVElNRU9VVCcpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFRpbWVkLW91dCBvcmRlciBjYW5jZWxsZWQ6ICR7b3JkZXJJZH1gKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIGNhbmNlbCB0aW1lZC1vdXQgb3JkZXIgJHtvcmRlcklkfTpgLCBlcnJvcik7XG4gICAgICB0aGlzLmVtaXQoJ2V4ZWN1dGlvbjplcnJvcicsIGVycm9yIGFzIEVycm9yLCB7IG9yZGVySWQsIHJlYXNvbjogJ1RJTUVPVVRfQ0FOQ0VMX0ZBSUxFRCcgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBvcmRlciBmaWxsZWRcbiAgICogQHBhcmFtIG9yZGVySWQgLSBPcmRlciBJRCB0aGF0IHdhcyBmaWxsZWRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlT3JkZXJGaWxsZWQob3JkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3JkZXJTdGF0ZSA9IHRoaXMuYWN0aXZlT3JkZXJzLmdldChvcmRlcklkKTtcbiAgICBpZiAoIW9yZGVyU3RhdGUpIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKGDinIUgT3JkZXIgZmlsbGVkOiAke29yZGVyU3RhdGUuc3ltYm9sfSBAICR7b3JkZXJTdGF0ZS5lbnRyeVByaWNlfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBmaWxsIGRldGFpbHMgKHRoaXMgd291bGQgbmVlZCB0byBiZSBpbXBsZW1lbnRlZCBpbiBCeWJpdFBlcnBzQ2xpZW50KVxuICAgICAgY29uc3QgZmlsbFByaWNlID0gb3JkZXJTdGF0ZS5lbnRyeVByaWNlOyAvLyBTaW1wbGlmaWVkIC0gc2hvdWxkIGdldCBhY3R1YWwgZmlsbCBwcmljZVxuICAgICAgXG4gICAgICBvcmRlclN0YXRlLmZpbGxlZCA9IHRydWU7XG4gICAgICB0aGlzLmFjdGl2ZU9yZGVycy5zZXQob3JkZXJJZCwgb3JkZXJTdGF0ZSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBzaXplICh0aGlzIHNob3VsZCBiZSBzdG9yZWQgZnJvbSBvcmlnaW5hbCBvcmRlcilcbiAgICAgIGNvbnN0IHBvc2l0aW9uU2l6ZSA9IDAuMTsgLy8gU2ltcGxpZmllZCAtIHNob3VsZCBnZXQgYWN0dWFsIGZpbGwgcXVhbnRpdHlcbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCdvcmRlcjpmaWxsZWQnLCBvcmRlcklkLCBmaWxsUHJpY2UsIHBvc2l0aW9uU2l6ZSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBwb3NpdGlvbiBvYmplY3QgZm9yIHBvc2l0aW9uIG1hbmFnZXJcbiAgICAgIGNvbnN0IHsgc3RvcExvc3MsIHRha2VQcm9maXQgfSA9IHRoaXMuc2V0U3RvcEFuZFRhcmdldChcbiAgICAgICAgZmlsbFByaWNlLCBcbiAgICAgICAgb3JkZXJTdGF0ZS5zeW1ib2wuaW5jbHVkZXMoJ0xPTkcnKSA/ICdMT05HJyA6ICdTSE9SVCcgLy8gU2ltcGxpZmllZCBkaXJlY3Rpb24gZGV0ZWN0aW9uXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbjogUG9zaXRpb24gPSB7XG4gICAgICAgIGlkOiBvcmRlcklkLFxuICAgICAgICBzeW1ib2w6IG9yZGVyU3RhdGUuc3ltYm9sLFxuICAgICAgICBzaWRlOiBvcmRlclN0YXRlLnN5bWJvbC5pbmNsdWRlcygnTE9ORycpID8gJ0xPTkcnIDogJ1NIT1JUJywgLy8gU2ltcGxpZmllZFxuICAgICAgICBlbnRyeVByaWNlOiBmaWxsUHJpY2UsXG4gICAgICAgIGN1cnJlbnRQcmljZTogZmlsbFByaWNlLFxuICAgICAgICBxdWFudGl0eTogcG9zaXRpb25TaXplLFxuICAgICAgICBsZXZlcmFnZTogMywgLy8gRGVmYXVsdCBsZXZlcmFnZVxuICAgICAgICBzdG9wTG9zcyxcbiAgICAgICAgdGFrZVByb2ZpdCxcbiAgICAgICAgdW5yZWFsaXplZFBuTDogMCxcbiAgICAgICAgcmVhbGl6ZWRQbkw6IDAsXG4gICAgICAgIGVudHJ5VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgc3RhdHVzOiAnT1BFTicsXG4gICAgICAgIHJWYWx1ZTogMCxcbiAgICAgICAgYXRyOiBhd2FpdCB0aGlzLmdldEFUUkZvclN5bWJvbChvcmRlclN0YXRlLnN5bWJvbClcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZW1pdCgncG9zaXRpb246Y3JlYXRlZCcsIHBvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGZyb20gYWN0aXZlIG1vbml0b3JpbmdcbiAgICAgIHRoaXMuYWN0aXZlT3JkZXJzLmRlbGV0ZShvcmRlcklkKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgaGFuZGxpbmcgZmlsbGVkIG9yZGVyICR7b3JkZXJJZH06YCwgZXJyb3IpO1xuICAgICAgdGhpcy5lbWl0KCdleGVjdXRpb246ZXJyb3InLCBlcnJvciBhcyBFcnJvciwgeyBvcmRlcklkLCByZWFzb246ICdGSUxMX0hBTkRMSU5HX0ZBSUxFRCcgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBvcmRlciBjYW5jZWxsZWRcbiAgICogQHBhcmFtIG9yZGVySWQgLSBPcmRlciBJRCB0aGF0IHdhcyBjYW5jZWxsZWRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlT3JkZXJDYW5jZWxsZWQob3JkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3JkZXJTdGF0ZSA9IHRoaXMuYWN0aXZlT3JkZXJzLmdldChvcmRlcklkKTtcbiAgICBpZiAoIW9yZGVyU3RhdGUpIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKGDinYwgT3JkZXIgY2FuY2VsbGVkOiAke29yZGVyU3RhdGUuc3ltYm9sfSAoJHtvcmRlcklkfSlgKTtcblxuICAgIG9yZGVyU3RhdGUuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmFjdGl2ZU9yZGVycy5zZXQob3JkZXJJZCwgb3JkZXJTdGF0ZSk7XG4gICAgXG4gICAgdGhpcy5lbWl0KCdvcmRlcjpjYW5jZWxsZWQnLCBvcmRlcklkLCAnRVhURVJOQUxfQ0FOQ0VMJyk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGZyb20gYWN0aXZlIG1vbml0b3JpbmdcbiAgICB0aGlzLmFjdGl2ZU9yZGVycy5kZWxldGUob3JkZXJJZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgY2FuY2VsbGF0aW9uIGNvbmRpdGlvbnMgZm9yIGFjdGl2ZSBvcmRlclxuICAgKiBAcGFyYW0gb3JkZXJJZCAtIE9yZGVyIElEIHRvIGNoZWNrXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNoZWNrQ2FuY2VsbGF0aW9uQ29uZGl0aW9ucyhvcmRlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBvcmRlclN0YXRlID0gdGhpcy5hY3RpdmVPcmRlcnMuZ2V0KG9yZGVySWQpO1xuICAgIGlmICghb3JkZXJTdGF0ZSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IHByaWNlXG4gICAgICBjb25zdCBjdXJyZW50UHJpY2UgPSBhd2FpdCB0aGlzLmJ5Yml0Q2xpZW50LmdldEN1cnJlbnRQcmljZShvcmRlclN0YXRlLnN5bWJvbCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHByaWNlIG1vdmVkIGF3YXkgPiAwLjIlXG4gICAgICBhd2FpdCB0aGlzLmNhbmNlbElmUHJpY2VNb3ZlcyhvcmRlcklkLCBjdXJyZW50UHJpY2UpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBsZXZlbCBmYWlsZWQgKHdvdWxkIG5lZWQgY3VycmVudCBjYW5kbGUgZGF0YSlcbiAgICAgIC8vIFRoaXMgaXMgc2ltcGxpZmllZCAtIGluIHByYWN0aWNlLCB5b3UnZCBuZWVkIHJlYWwtdGltZSBjYW5kbGUgZGF0YVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBjaGVja2luZyBjYW5jZWxsYXRpb24gY29uZGl0aW9ucyBmb3IgJHtvcmRlcklkfTpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBBVFIgZm9yIHN5bWJvbCAoaGVscGVyIG1ldGhvZClcbiAgICogQHBhcmFtIHN5bWJvbCAtIFRyYWRpbmcgc3ltYm9sXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBBVFIgdmFsdWVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0QVRSRm9yU3ltYm9sKHN5bWJvbDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FuZGxlcyA9IGF3YWl0IHRoaXMuYnliaXRDbGllbnQuZmV0Y2hPSExDVihzeW1ib2wsICcxaCcsIHRoaXMuY29uZmlnLmF0clBlcmlvZCArIDEwKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUFUUihjYW5kbGVzLCB0aGlzLmNvbmZpZy5hdHJQZXJpb2QpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIGdldCBBVFIgZm9yICR7c3ltYm9sfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gMC4wMDE7IC8vIERlZmF1bHQgQVRSXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhY3RpdmUgb3JkZXJzIGNvdW50XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiBhY3RpdmUgb3JkZXJzXG4gICAqL1xuICBwdWJsaWMgZ2V0QWN0aXZlT3JkZXJzQ291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVPcmRlcnMuc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWN0aXZlIG9yZGVyc1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBhY3RpdmUgb3JkZXIgc3RhdGVzXG4gICAqL1xuICBwdWJsaWMgZ2V0QWN0aXZlT3JkZXJzKCk6IE9yZGVyTW9uaXRvcmluZ1N0YXRlW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuYWN0aXZlT3JkZXJzLnZhbHVlcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYWxsIGFjdGl2ZSBvcmRlcnNcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGNhbmNlbGxhdGlvbiByZXN1bHRzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY2FuY2VsQWxsT3JkZXJzKCk6IFByb21pc2U8eyBzdWNjZXNzOiBudW1iZXI7IGZhaWxlZDogbnVtYmVyIH0+IHtcbiAgICBjb25zb2xlLmxvZyhg8J+aqCBDYW5jZWxsaW5nIGFsbCBhY3RpdmUgb3JkZXJzYCk7XG4gICAgXG4gICAgY29uc3Qgb3JkZXJJZHMgPSBBcnJheS5mcm9tKHRoaXMuYWN0aXZlT3JkZXJzLmtleXMoKSk7XG4gICAgbGV0IHN1Y2Nlc3MgPSAwO1xuICAgIGxldCBmYWlsZWQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBvcmRlcklkIG9mIG9yZGVySWRzKSB7XG4gICAgICBjb25zdCBvcmRlclN0YXRlID0gdGhpcy5hY3RpdmVPcmRlcnMuZ2V0KG9yZGVySWQpO1xuICAgICAgaWYgKCFvcmRlclN0YXRlKSBjb250aW51ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ieWJpdENsaWVudC5jYW5jZWxPcmRlcihvcmRlcklkLCBvcmRlclN0YXRlLnN5bWJvbCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBzdWNjZXNzKys7XG4gICAgICAgICAgb3JkZXJTdGF0ZS5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYWN0aXZlT3JkZXJzLnNldChvcmRlcklkLCBvcmRlclN0YXRlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ29yZGVyOmNhbmNlbGxlZCcsIG9yZGVySWQsICdNQU5VQUxfQ0FOQ0VMX0FMTCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhaWxlZCsrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIGNhbmNlbCBvcmRlciAke29yZGVySWR9OmAsIGVycm9yKTtcbiAgICAgICAgZmFpbGVkKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYPCfmqggQ2FuY2VsIGFsbCBjb21wbGV0ZTogJHtzdWNjZXNzfSBzdWNjZXNzLCAke2ZhaWxlZH0gZmFpbGVkYCk7XG4gICAgcmV0dXJuIHsgc3VjY2VzcywgZmFpbGVkIH07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjb25maWd1cmF0aW9uXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29uZmlnKG5ld0NvbmZpZzogUGFydGlhbDxMaW1pdE9yZGVyQ29uZmlnPik6IHZvaWQge1xuICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4ubmV3Q29uZmlnIH07XG4gICAgY29uc29sZS5sb2coYPCfjq8gTGltaXQgT3JkZXIgRXhlY3V0b3I6IENvbmZpZ3VyYXRpb24gdXBkYXRlZGApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbW9uaXRvcmluZyBhbmQgY2xlYW51cFxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKTtcbiAgICAgIHRoaXMubW9uaXRvcmluZ0ludGVydmFsID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5hY3RpdmVPcmRlcnMuY2xlYXIoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn46vIExpbWl0IE9yZGVyIEV4ZWN1dG9yOiBEZXN0cm95ZWRgKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgZXZlbnQgaW50ZXJmYWNlIGZvciBUeXBlU2NyaXB0XG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTGltaXRPcmRlckV4ZWN1dG9yIHtcbiAgb248VSBleHRlbmRzIGtleW9mIExpbWl0T3JkZXJFeGVjdXRvckV2ZW50cz4oZXZlbnQ6IFUsIGxpc3RlbmVyOiBMaW1pdE9yZGVyRXhlY3V0b3JFdmVudHNbVV0pOiB0aGlzO1xuICBlbWl0PFUgZXh0ZW5kcyBrZXlvZiBMaW1pdE9yZGVyRXhlY3V0b3JFdmVudHM+KGV2ZW50OiBVLCAuLi5hcmdzOiBQYXJhbWV0ZXJzPExpbWl0T3JkZXJFeGVjdXRvckV2ZW50c1tVXT4pOiBib29sZWFuO1xufSJdLCJ2ZXJzaW9uIjozfQ==