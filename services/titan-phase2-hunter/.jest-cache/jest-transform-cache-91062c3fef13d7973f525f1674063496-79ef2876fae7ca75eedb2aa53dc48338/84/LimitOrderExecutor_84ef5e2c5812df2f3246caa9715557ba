4d9fcff5adb2ea04ec5162464c5d6a02
"use strict";
/**
 * Limit Order Executor (The Sniper) for Titan Phase 2 - The Hunter
 *
 * Implements passive execution strategy using Post-Only Limit Orders at Order Blocks.
 * Designed for Bulgaria (200ms latency) - orders wait at pre-calculated levels.
 *
 * Key Features:
 * - Post-Only orders at Order Block top/bottom (earn Maker rebates)
 * - 60-second order timeout with price movement cancellation
 * - Volatility-Adjusted Position Sizing using ATR
 * - 3:1 Risk-Reward ratio (1.5% stop, 4.5% target)
 * - Smart cancellation logic (price moves >0.2%, level fails >0.5%)
 *
 * Requirements: 7.1-7.7 (Execution)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitOrderExecutor = void 0;
const events_1 = require("events");
const Logger_1 = require("../logging/Logger");
class LimitOrderExecutor extends events_1.EventEmitter {
    bybitClient;
    config;
    activeOrders = new Map();
    monitoringInterval = null;
    MONITORING_FREQUENCY = 1000; // 1 second
    constructor(bybitClient, config) {
        super();
        this.bybitClient = bybitClient;
        this.config = {
            orderTimeout: 60000, // 60 seconds
            priceMoveCancelThreshold: 0.002, // 0.2%
            levelFailThreshold: 0.005, // 0.5%
            stopLossPercent: 0.015, // 1.5%
            takeProfitPercent: 0.045, // 4.5%
            atrPeriod: 14,
            maxRetries: 2,
            retryDelay: 1000,
            ...config
        };
        // Start order monitoring
        this.startMonitoring();
    }
    /**
     * Place Post-Only Limit Order at Order Block top/bottom
     * @param signal - Signal data with entry details
     * @param orderBlock - Order Block for entry level
     * @param equity - Current account equity for position sizing
     * @returns Promise with execution result
     */
    async placePostOnlyOrder(signal, orderBlock, equity) {
        try {
            console.log(`üéØ Placing Post-Only order for ${signal.symbol} ${signal.direction}`);
            // Calculate entry price at Order Block level
            const entryPrice = signal.direction === 'LONG'
                ? orderBlock.low // Enter at OB bottom for longs
                : orderBlock.high; // Enter at OB top for shorts
            // Calculate position size using Volatility-Adjusted Sizing
            const positionSize = await this.calcPositionSize(signal.symbol, entryPrice, equity, signal.leverage);
            if (positionSize <= 0) {
                return {
                    success: false,
                    error: 'Position size calculation failed or too small'
                };
            }
            // Calculate stop loss and take profit
            const { stopLoss, takeProfit } = this.setStopAndTarget(entryPrice, signal.direction);
            // Prepare order parameters
            const orderParams = {
                phase: 'phase2',
                symbol: signal.symbol,
                side: signal.direction === 'LONG' ? 'Buy' : 'Sell',
                type: 'POST_ONLY',
                price: entryPrice,
                qty: positionSize,
                leverage: signal.leverage,
                stopLoss,
                takeProfit
            };
            // Place order with retry logic
            const orderResult = await this.bybitClient.placeOrderWithRetry(orderParams, this.config.maxRetries);
            if (orderResult.orderId) {
                // Start monitoring the order
                this.startOrderMonitoring(orderResult.orderId, signal.symbol, entryPrice, orderBlock, signal.timestamp.toString());
                this.emit('order:placed', orderResult.orderId, signal.symbol, entryPrice);
                console.log(`‚úÖ Post-Only order placed: ${signal.symbol} @ ${entryPrice} (ID: ${orderResult.orderId})`);
                return {
                    success: true,
                    orderId: orderResult.orderId,
                    positionSize,
                    stopLoss,
                    takeProfit
                };
            }
            return {
                success: false,
                error: 'Order placement failed - no order ID returned'
            };
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : 'Unknown error';
            console.error(`‚ùå Failed to place Post-Only order for ${signal.symbol}:`, errorMsg);
            (0, Logger_1.logError)('ERROR', `Failed to place Post-Only order for ${signal.symbol}`, {
                symbol: signal.symbol,
                component: 'LimitOrderExecutor',
                function: 'placePostOnlyOrder',
                stack: error.stack,
                data: { signal, orderBlock }
            });
            this.emit('execution:error', error, { signal, orderBlock });
            return {
                success: false,
                error: errorMsg
            };
        }
    }
    /**
     * Monitor order with 60-second timeout
     * @param orderId - Order ID to monitor
     * @param symbol - Trading symbol
     * @param entryPrice - Expected entry price
     * @param orderBlock - Order Block reference
     */
    startOrderMonitoring(orderId, symbol, entryPrice, orderBlock, signalId) {
        const monitoringState = {
            orderId,
            symbol,
            entryPrice,
            orderBlock,
            startTime: Date.now(),
            cancelled: false,
            filled: false,
            signalId
        };
        this.activeOrders.set(orderId, monitoringState);
        console.log(`üëÅÔ∏è Started monitoring order ${orderId} for ${symbol}`);
    }
    /**
     * Monitor order and cancel if price moves away > 0.2%
     * @param orderId - Order ID to monitor
     * @param currentPrice - Current market price
     * @returns Promise with cancellation result
     */
    async cancelIfPriceMoves(orderId, currentPrice) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState || orderState.cancelled || orderState.filled) {
            return false;
        }
        // Calculate price movement from entry level
        const priceMove = Math.abs(currentPrice - orderState.entryPrice) / orderState.entryPrice;
        if (priceMove > this.config.priceMoveCancelThreshold) {
            console.log(`üìâ Price moved ${(priceMove * 100).toFixed(2)}% away from ${orderState.symbol} order, cancelling`);
            try {
                const success = await this.bybitClient.cancelOrder(orderId, orderState.symbol);
                if (success) {
                    orderState.cancelled = true;
                    this.activeOrders.set(orderId, orderState);
                    this.emit('order:cancelled', orderId, 'PRICE_MOVED_AWAY');
                    console.log(`‚úÖ Order cancelled due to price movement: ${orderId}`);
                    return true;
                }
            }
            catch (error) {
                console.error(`‚ùå Failed to cancel order ${orderId}:`, error);
                this.emit('execution:error', error, { orderId, reason: 'CANCEL_FAILED' });
            }
        }
        return false;
    }
    /**
     * Cancel order when price wicks through Order Block > 0.5%
     * @param orderId - Order ID to monitor
     * @param currentCandle - Current OHLCV candle
     * @returns Promise with cancellation result
     */
    async cancelIfLevelFails(orderId, currentCandle) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState || orderState.cancelled || orderState.filled) {
            return false;
        }
        const orderBlock = orderState.orderBlock;
        let wickThrough = false;
        let wickPercent = 0;
        if (orderBlock.type === 'BULLISH') {
            // For bullish OB, check if price wicked below OB low
            if (currentCandle.low < orderBlock.low) {
                wickPercent = (orderBlock.low - currentCandle.low) / orderBlock.low;
                wickThrough = wickPercent > this.config.levelFailThreshold;
            }
        }
        else {
            // For bearish OB, check if price wicked above OB high
            if (currentCandle.high > orderBlock.high) {
                wickPercent = (currentCandle.high - orderBlock.high) / orderBlock.high;
                wickThrough = wickPercent > this.config.levelFailThreshold;
            }
        }
        if (wickThrough) {
            console.log(`üí• Order Block level failed for ${orderState.symbol} (${(wickPercent * 100).toFixed(2)}% wick), cancelling`);
            try {
                const success = await this.bybitClient.cancelOrder(orderId, orderState.symbol);
                if (success) {
                    orderState.cancelled = true;
                    this.activeOrders.set(orderId, orderState);
                    this.emit('order:cancelled', orderId, 'LEVEL_FAILED');
                    console.log(`‚úÖ Order cancelled due to level failure: ${orderId}`);
                    return true;
                }
            }
            catch (error) {
                console.error(`‚ùå Failed to cancel order ${orderId}:`, error);
                this.emit('execution:error', error, { orderId, reason: 'CANCEL_FAILED' });
            }
        }
        return false;
    }
    /**
     * Calculate position size using Volatility-Adjusted Sizing
     * @param symbol - Trading symbol
     * @param entryPrice - Entry price
     * @param equity - Account equity
     * @param leverage - Leverage multiplier
     * @returns Promise with position size
     */
    async calcPositionSize(symbol, entryPrice, equity, leverage) {
        try {
            // Fetch recent OHLCV data for ATR calculation
            const candles = await this.bybitClient.fetchOHLCV(symbol, '1h', this.config.atrPeriod + 10);
            if (candles.length < this.config.atrPeriod) {
                throw new Error(`Insufficient candle data for ATR calculation: ${candles.length} < ${this.config.atrPeriod}`);
            }
            // Calculate ATR (Average True Range)
            const atr = this.calculateATR(candles, this.config.atrPeriod);
            // Risk amount (2% of equity by default)
            const riskPercent = 0.02; // 2% risk per trade
            const riskAmount = equity * riskPercent;
            // Stop distance in price terms
            const stopDistance = entryPrice * this.config.stopLossPercent;
            // Volatility-Adjusted Sizing: Risk_Dollars / (ATR * Stop_Distance_Multiplier)
            // Use ATR as volatility adjustment factor
            const volatilityAdjustment = atr / entryPrice; // ATR as % of price
            const adjustedStopDistance = stopDistance * (1 + volatilityAdjustment);
            // Calculate base position size
            const basePositionSize = riskAmount / adjustedStopDistance;
            // Apply leverage (but cap at reasonable levels)
            const maxLeverageMultiplier = Math.min(leverage, 5); // Cap at 5x for safety
            const positionSize = basePositionSize * maxLeverageMultiplier;
            // Ensure minimum position size (0.001 for most symbols)
            const minPositionSize = 0.001;
            const finalPositionSize = Math.max(positionSize, minPositionSize);
            console.log(`üìä Position sizing for ${symbol}:`);
            console.log(`   ATR: ${atr.toFixed(4)} (${(volatilityAdjustment * 100).toFixed(2)}%)`);
            console.log(`   Risk Amount: $${riskAmount.toFixed(2)}`);
            console.log(`   Stop Distance: ${stopDistance.toFixed(4)} (${(this.config.stopLossPercent * 100).toFixed(1)}%)`);
            console.log(`   Position Size: ${finalPositionSize.toFixed(4)}`);
            return finalPositionSize;
        }
        catch (error) {
            console.error(`‚ùå Failed to calculate position size for ${symbol}:`, error);
            throw new Error(`Position size calculation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    /**
     * Set stop loss and take profit with 1.5% stop, 4.5% target (3:1 R:R)
     * @param entryPrice - Entry price
     * @param direction - Trade direction
     * @returns Stop loss and take profit prices
     */
    setStopAndTarget(entryPrice, direction) {
        const stopDistance = entryPrice * this.config.stopLossPercent;
        const targetDistance = entryPrice * this.config.takeProfitPercent;
        let stopLoss;
        let takeProfit;
        if (direction === 'LONG') {
            stopLoss = entryPrice - stopDistance; // 1.5% below entry
            takeProfit = entryPrice + targetDistance; // 4.5% above entry
        }
        else {
            stopLoss = entryPrice + stopDistance; // 1.5% above entry
            takeProfit = entryPrice - targetDistance; // 4.5% below entry
        }
        const riskReward = targetDistance / stopDistance;
        console.log(`üéØ Stop & Target for ${direction} @ ${entryPrice.toFixed(4)}:`);
        console.log(`   Stop Loss: ${stopLoss.toFixed(4)} (-${(this.config.stopLossPercent * 100).toFixed(1)}%)`);
        console.log(`   Take Profit: ${takeProfit.toFixed(4)} (+${(this.config.takeProfitPercent * 100).toFixed(1)}%)`);
        console.log(`   Risk:Reward = 1:${riskReward.toFixed(1)}`);
        return { stopLoss, takeProfit };
    }
    /**
     * Calculate Average True Range (ATR)
     * @param candles - OHLCV candle data
     * @param period - ATR period (default: 14)
     * @returns ATR value
     */
    calculateATR(candles, period) {
        if (candles.length < period + 1) {
            throw new Error(`Insufficient data for ATR calculation: need ${period + 1}, got ${candles.length}`);
        }
        const trueRanges = [];
        // Calculate True Range for each candle (starting from index 1)
        for (let i = 1; i < candles.length; i++) {
            const current = candles[i];
            const previous = candles[i - 1];
            // True Range = max(high-low, |high-prevClose|, |low-prevClose|)
            const highLow = current.high - current.low;
            const highPrevClose = Math.abs(current.high - previous.close);
            const lowPrevClose = Math.abs(current.low - previous.close);
            const trueRange = Math.max(highLow, highPrevClose, lowPrevClose);
            trueRanges.push(trueRange);
        }
        // Calculate ATR as Simple Moving Average of True Ranges
        const recentTrueRanges = trueRanges.slice(-period);
        const atr = recentTrueRanges.reduce((sum, tr) => sum + tr, 0) / period;
        return atr;
    }
    /**
     * Start monitoring all active orders
     */
    startMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
        }
        this.monitoringInterval = setInterval(async () => {
            await this.monitorActiveOrders();
        }, this.MONITORING_FREQUENCY);
        console.log(`üëÅÔ∏è Limit Order Executor: Started monitoring (${this.MONITORING_FREQUENCY}ms interval)`);
    }
    /**
     * Monitor all active orders for timeout, fills, and cancellation conditions
     */
    async monitorActiveOrders() {
        const activeOrderIds = Array.from(this.activeOrders.keys());
        for (const orderId of activeOrderIds) {
            const orderState = this.activeOrders.get(orderId);
            if (!orderState || orderState.cancelled || orderState.filled) {
                continue;
            }
            try {
                // Check for timeout (60 seconds)
                const elapsed = Date.now() - orderState.startTime;
                if (elapsed > this.config.orderTimeout) {
                    await this.handleOrderTimeout(orderId);
                    continue;
                }
                // Check order status
                const status = await this.bybitClient.getOrderStatus(orderId, orderState.symbol);
                if (status === 'FILLED') {
                    await this.handleOrderFilled(orderId);
                }
                else if (status === 'CANCELLED') {
                    await this.handleOrderCancelled(orderId);
                }
                else {
                    // Order still active, check cancellation conditions
                    await this.checkCancellationConditions(orderId);
                }
            }
            catch (error) {
                console.error(`‚ùå Error monitoring order ${orderId}:`, error);
                this.emit('execution:error', error, { orderId, action: 'MONITORING' });
            }
        }
    }
    /**
     * Handle order timeout (60 seconds)
     * @param orderId - Order ID that timed out
     */
    async handleOrderTimeout(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        console.log(`‚è∞ Order timeout for ${orderState.symbol}: ${orderId}`);
        try {
            // Cancel the timed-out order
            await this.bybitClient.cancelOrder(orderId, orderState.symbol);
            orderState.cancelled = true;
            this.activeOrders.set(orderId, orderState);
            this.emit('order:timeout', orderId);
            this.emit('order:cancelled', orderId, 'TIMEOUT');
            console.log(`‚úÖ Timed-out order cancelled: ${orderId}`);
        }
        catch (error) {
            console.error(`‚ùå Failed to cancel timed-out order ${orderId}:`, error);
            this.emit('execution:error', error, { orderId, reason: 'TIMEOUT_CANCEL_FAILED' });
        }
    }
    /**
     * Handle order filled
     * @param orderId - Order ID that was filled
     */
    async handleOrderFilled(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        console.log(`‚úÖ Order filled: ${orderState.symbol} @ ${orderState.entryPrice}`);
        try {
            // Get fill details (this would need to be implemented in BybitPerpsClient)
            const fillPrice = orderState.entryPrice; // Simplified - should get actual fill price
            orderState.filled = true;
            this.activeOrders.set(orderId, orderState);
            // Calculate position size (this should be stored from original order)
            const positionSize = 0.1; // Simplified - should get actual fill quantity
            // Calculate slippage
            const expectedPrice = orderState.entryPrice;
            const slippage = Math.abs(fillPrice - expectedPrice) / expectedPrice;
            this.emit('order:filled', orderId, fillPrice, positionSize);
            // Log execution to structured logger
            const orderResult = {
                orderId,
                symbol: orderState.symbol,
                side: orderState.symbol.includes('LONG') ? 'Buy' : 'Sell',
                qty: positionSize,
                price: fillPrice,
                status: 'FILLED',
                timestamp: Date.now()
            };
            (0, Logger_1.logExecution)(orderResult, slippage, orderState.signalId);
            // Create position object for position manager
            const { stopLoss, takeProfit } = this.setStopAndTarget(fillPrice, orderState.symbol.includes('LONG') ? 'LONG' : 'SHORT' // Simplified direction detection
            );
            const position = {
                id: orderId,
                symbol: orderState.symbol,
                side: orderState.symbol.includes('LONG') ? 'LONG' : 'SHORT', // Simplified
                entryPrice: fillPrice,
                currentPrice: fillPrice,
                quantity: positionSize,
                leverage: 3, // Default leverage
                stopLoss,
                takeProfit,
                unrealizedPnL: 0,
                realizedPnL: 0,
                entryTime: Date.now(),
                status: 'OPEN',
                rValue: 0,
                atr: await this.getATRForSymbol(orderState.symbol)
            };
            this.emit('position:created', position);
            // Remove from active monitoring
            this.activeOrders.delete(orderId);
        }
        catch (error) {
            console.error(`‚ùå Error handling filled order ${orderId}:`, error);
            this.emit('execution:error', error, { orderId, reason: 'FILL_HANDLING_FAILED' });
        }
    }
    /**
     * Handle order cancelled
     * @param orderId - Order ID that was cancelled
     */
    async handleOrderCancelled(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        console.log(`‚ùå Order cancelled: ${orderState.symbol} (${orderId})`);
        orderState.cancelled = true;
        this.activeOrders.set(orderId, orderState);
        this.emit('order:cancelled', orderId, 'EXTERNAL_CANCEL');
        // Remove from active monitoring
        this.activeOrders.delete(orderId);
    }
    /**
     * Check cancellation conditions for active order
     * @param orderId - Order ID to check
     */
    async checkCancellationConditions(orderId) {
        const orderState = this.activeOrders.get(orderId);
        if (!orderState)
            return;
        try {
            // Get current price
            const currentPrice = await this.bybitClient.getCurrentPrice(orderState.symbol);
            // Check if price moved away > 0.2%
            await this.cancelIfPriceMoves(orderId, currentPrice);
            // Check if level failed (would need current candle data)
            // This is simplified - in practice, you'd need real-time candle data
        }
        catch (error) {
            console.error(`‚ùå Error checking cancellation conditions for ${orderId}:`, error);
        }
    }
    /**
     * Get ATR for symbol (helper method)
     * @param symbol - Trading symbol
     * @returns Promise with ATR value
     */
    async getATRForSymbol(symbol) {
        try {
            const candles = await this.bybitClient.fetchOHLCV(symbol, '1h', this.config.atrPeriod + 10);
            return this.calculateATR(candles, this.config.atrPeriod);
        }
        catch (error) {
            console.error(`‚ùå Failed to get ATR for ${symbol}:`, error);
            return 0.001; // Default ATR
        }
    }
    /**
     * Get active orders count
     * @returns Number of active orders
     */
    getActiveOrdersCount() {
        return this.activeOrders.size;
    }
    /**
     * Get active orders
     * @returns Array of active order states
     */
    getActiveOrders() {
        return Array.from(this.activeOrders.values());
    }
    /**
     * Cancel all active orders
     * @returns Promise with cancellation results
     */
    async cancelAllOrders() {
        console.log(`üö® Cancelling all active orders`);
        const orderIds = Array.from(this.activeOrders.keys());
        let success = 0;
        let failed = 0;
        for (const orderId of orderIds) {
            const orderState = this.activeOrders.get(orderId);
            if (!orderState)
                continue;
            try {
                const result = await this.bybitClient.cancelOrder(orderId, orderState.symbol);
                if (result) {
                    success++;
                    orderState.cancelled = true;
                    this.activeOrders.set(orderId, orderState);
                    this.emit('order:cancelled', orderId, 'MANUAL_CANCEL_ALL');
                }
                else {
                    failed++;
                }
            }
            catch (error) {
                console.error(`‚ùå Failed to cancel order ${orderId}:`, error);
                failed++;
            }
        }
        console.log(`üö® Cancel all complete: ${success} success, ${failed} failed`);
        return { success, failed };
    }
    /**
     * Update configuration
     * @param newConfig - New configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        console.log(`üéØ Limit Order Executor: Configuration updated`);
    }
    /**
     * Stop monitoring and cleanup
     */
    destroy() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
        this.activeOrders.clear();
        this.removeAllListeners();
        console.log(`üéØ Limit Order Executor: Destroyed`);
    }
}
exports.LimitOrderExecutor = LimitOrderExecutor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLXBoYXNlMi1odW50ZXIvc3JjL2V4ZWN1dGlvbi9MaW1pdE9yZGVyRXhlY3V0b3IudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7OztHQWNHOzs7QUFFSCxtQ0FBc0M7QUFZdEMsOENBQTJEO0FBNEMzRCxNQUFhLGtCQUFtQixTQUFRLHFCQUFZO0lBQzFDLFdBQVcsQ0FBbUI7SUFDOUIsTUFBTSxDQUFtQjtJQUN6QixZQUFZLEdBQXNDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDNUQsa0JBQWtCLEdBQTBCLElBQUksQ0FBQztJQUN4QyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsQ0FBQyxXQUFXO0lBRXpELFlBQVksV0FBNkIsRUFBRSxNQUFrQztRQUMzRSxLQUFLLEVBQUUsQ0FBQztRQUVSLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxNQUFNLEdBQUc7WUFDWixZQUFZLEVBQUUsS0FBSyxFQUFFLGFBQWE7WUFDbEMsd0JBQXdCLEVBQUUsS0FBSyxFQUFFLE9BQU87WUFDeEMsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLE9BQU87WUFDbEMsZUFBZSxFQUFFLEtBQUssRUFBRSxPQUFPO1lBQy9CLGlCQUFpQixFQUFFLEtBQUssRUFBRSxPQUFPO1lBQ2pDLFNBQVMsRUFBRSxFQUFFO1lBQ2IsVUFBVSxFQUFFLENBQUM7WUFDYixVQUFVLEVBQUUsSUFBSTtZQUNoQixHQUFHLE1BQU07U0FDVixDQUFDO1FBRUYseUJBQXlCO1FBQ3pCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksS0FBSyxDQUFDLGtCQUFrQixDQUM3QixNQUFrQixFQUNsQixVQUFzQixFQUN0QixNQUFjO1FBRWQsSUFBSSxDQUFDO1lBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQ0FBa0MsTUFBTSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsU0FB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a0JBQWtCLENBQUMsQ0FBQztZQUN2QyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO1FBQ2pDLENBQUM7UUFFRCxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBRTFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUNwRCxDQUFDO0NBQ0Y7QUF4cEJELGdEQXdwQkMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLXBoYXNlMi1odW50ZXIvc3JjL2V4ZWN1dGlvbi9MaW1pdE9yZGVyRXhlY3V0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaW1pdCBPcmRlciBFeGVjdXRvciAoVGhlIFNuaXBlcikgZm9yIFRpdGFuIFBoYXNlIDIgLSBUaGUgSHVudGVyXG4gKiBcbiAqIEltcGxlbWVudHMgcGFzc2l2ZSBleGVjdXRpb24gc3RyYXRlZ3kgdXNpbmcgUG9zdC1Pbmx5IExpbWl0IE9yZGVycyBhdCBPcmRlciBCbG9ja3MuXG4gKiBEZXNpZ25lZCBmb3IgQnVsZ2FyaWEgKDIwMG1zIGxhdGVuY3kpIC0gb3JkZXJzIHdhaXQgYXQgcHJlLWNhbGN1bGF0ZWQgbGV2ZWxzLlxuICogXG4gKiBLZXkgRmVhdHVyZXM6XG4gKiAtIFBvc3QtT25seSBvcmRlcnMgYXQgT3JkZXIgQmxvY2sgdG9wL2JvdHRvbSAoZWFybiBNYWtlciByZWJhdGVzKVxuICogLSA2MC1zZWNvbmQgb3JkZXIgdGltZW91dCB3aXRoIHByaWNlIG1vdmVtZW50IGNhbmNlbGxhdGlvblxuICogLSBWb2xhdGlsaXR5LUFkanVzdGVkIFBvc2l0aW9uIFNpemluZyB1c2luZyBBVFJcbiAqIC0gMzoxIFJpc2stUmV3YXJkIHJhdGlvICgxLjUlIHN0b3AsIDQuNSUgdGFyZ2V0KVxuICogLSBTbWFydCBjYW5jZWxsYXRpb24gbG9naWMgKHByaWNlIG1vdmVzID4wLjIlLCBsZXZlbCBmYWlscyA+MC41JSlcbiAqIFxuICogUmVxdWlyZW1lbnRzOiA3LjEtNy43IChFeGVjdXRpb24pXG4gKi9cblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IFxuICBPcmRlclBhcmFtcywgXG4gIE9yZGVyUmVzdWx0LCBcbiAgT3JkZXJTdGF0dXMsIFxuICBTaWduYWxEYXRhLCBcbiAgRXhlY3V0aW9uRGF0YSxcbiAgT0hMQ1YsXG4gIE9yZGVyQmxvY2ssXG4gIFBvc2l0aW9uXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEJ5Yml0UGVycHNDbGllbnQgfSBmcm9tICcuLi9leGNoYW5nZXMvQnliaXRQZXJwc0NsaWVudCc7XG5pbXBvcnQgeyBsb2dFeGVjdXRpb24sIGxvZ0Vycm9yIH0gZnJvbSAnLi4vbG9nZ2luZy9Mb2dnZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbWl0T3JkZXJDb25maWcge1xuICBvcmRlclRpbWVvdXQ6IG51bWJlcjsgLy8gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDYwMDAwKVxuICBwcmljZU1vdmVDYW5jZWxUaHJlc2hvbGQ6IG51bWJlcjsgLy8gUHJpY2UgbW92ZSAlIHRvIGNhbmNlbCAoZGVmYXVsdDogMC4wMDIgPSAwLjIlKVxuICBsZXZlbEZhaWxUaHJlc2hvbGQ6IG51bWJlcjsgLy8gV2ljayAlIHRvIGNhbmNlbCAoZGVmYXVsdDogMC4wMDUgPSAwLjUlKVxuICBzdG9wTG9zc1BlcmNlbnQ6IG51bWJlcjsgLy8gU3RvcCBsb3NzICUgZnJvbSBlbnRyeSAoZGVmYXVsdDogMC4wMTUgPSAxLjUlKVxuICB0YWtlUHJvZml0UGVyY2VudDogbnVtYmVyOyAvLyBUYWtlIHByb2ZpdCAlIGZyb20gZW50cnkgKGRlZmF1bHQ6IDAuMDQ1ID0gNC41JSlcbiAgYXRyUGVyaW9kOiBudW1iZXI7IC8vIEFUUiBjYWxjdWxhdGlvbiBwZXJpb2QgKGRlZmF1bHQ6IDE0KVxuICBtYXhSZXRyaWVzOiBudW1iZXI7IC8vIE1heGltdW0gb3JkZXIgcmV0cnkgYXR0ZW1wdHMgKGRlZmF1bHQ6IDIpXG4gIHJldHJ5RGVsYXk6IG51bWJlcjsgLy8gRGVsYXkgYmV0d2VlbiByZXRyaWVzIGluIG1zIChkZWZhdWx0OiAxMDAwKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvblJlc3VsdCB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIG9yZGVySWQ/OiBzdHJpbmc7XG4gIGZpbGxQcmljZT86IG51bWJlcjtcbiAgcG9zaXRpb25TaXplPzogbnVtYmVyO1xuICBzdG9wTG9zcz86IG51bWJlcjtcbiAgdGFrZVByb2ZpdD86IG51bWJlcjtcbiAgcmVhc29uPzogc3RyaW5nO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcmRlck1vbml0b3JpbmdTdGF0ZSB7XG4gIG9yZGVySWQ6IHN0cmluZztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIGVudHJ5UHJpY2U6IG51bWJlcjtcbiAgb3JkZXJCbG9jazogT3JkZXJCbG9jaztcbiAgc3RhcnRUaW1lOiBudW1iZXI7XG4gIGNhbmNlbGxlZDogYm9vbGVhbjtcbiAgZmlsbGVkOiBib29sZWFuO1xuICBzaWduYWxJZD86IHN0cmluZzsgLy8gT3B0aW9uYWwgc2lnbmFsIElEIGZvciBsb2dnaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGltaXRPcmRlckV4ZWN1dG9yRXZlbnRzIHtcbiAgJ29yZGVyOnBsYWNlZCc6IChvcmRlcklkOiBzdHJpbmcsIHN5bWJvbDogc3RyaW5nLCBwcmljZTogbnVtYmVyKSA9PiB2b2lkO1xuICAnb3JkZXI6ZmlsbGVkJzogKG9yZGVySWQ6IHN0cmluZywgZmlsbFByaWNlOiBudW1iZXIsIHBvc2l0aW9uU2l6ZTogbnVtYmVyKSA9PiB2b2lkO1xuICAnb3JkZXI6Y2FuY2VsbGVkJzogKG9yZGVySWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpID0+IHZvaWQ7XG4gICdvcmRlcjp0aW1lb3V0JzogKG9yZGVySWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgJ3Bvc2l0aW9uOmNyZWF0ZWQnOiAocG9zaXRpb246IFBvc2l0aW9uKSA9PiB2b2lkO1xuICAnZXhlY3V0aW9uOmVycm9yJzogKGVycm9yOiBFcnJvciwgY29udGV4dDogYW55KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgTGltaXRPcmRlckV4ZWN1dG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBieWJpdENsaWVudDogQnliaXRQZXJwc0NsaWVudDtcbiAgcHJpdmF0ZSBjb25maWc6IExpbWl0T3JkZXJDb25maWc7XG4gIHByaXZhdGUgYWN0aXZlT3JkZXJzOiBNYXA8c3RyaW5nLCBPcmRlck1vbml0b3JpbmdTdGF0ZT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgbW9uaXRvcmluZ0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlYWRvbmx5IE1PTklUT1JJTkdfRlJFUVVFTkNZID0gMTAwMDsgLy8gMSBzZWNvbmRcblxuICBjb25zdHJ1Y3RvcihieWJpdENsaWVudDogQnliaXRQZXJwc0NsaWVudCwgY29uZmlnPzogUGFydGlhbDxMaW1pdE9yZGVyQ29uZmlnPikge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy5ieWJpdENsaWVudCA9IGJ5Yml0Q2xpZW50O1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgb3JkZXJUaW1lb3V0OiA2MDAwMCwgLy8gNjAgc2Vjb25kc1xuICAgICAgcHJpY2VNb3ZlQ2FuY2VsVGhyZXNob2xkOiAwLjAwMiwgLy8gMC4yJVxuICAgICAgbGV2ZWxGYWlsVGhyZXNob2xkOiAwLjAwNSwgLy8gMC41JVxuICAgICAgc3RvcExvc3NQZXJjZW50OiAwLjAxNSwgLy8gMS41JVxuICAgICAgdGFrZVByb2ZpdFBlcmNlbnQ6IDAuMDQ1LCAvLyA0LjUlXG4gICAgICBhdHJQZXJpb2Q6IDE0LFxuICAgICAgbWF4UmV0cmllczogMixcbiAgICAgIHJldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuXG4gICAgLy8gU3RhcnQgb3JkZXIgbW9uaXRvcmluZ1xuICAgIHRoaXMuc3RhcnRNb25pdG9yaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogUGxhY2UgUG9zdC1Pbmx5IExpbWl0IE9yZGVyIGF0IE9yZGVyIEJsb2NrIHRvcC9ib3R0b21cbiAgICogQHBhcmFtIHNpZ25hbCAtIFNpZ25hbCBkYXRhIHdpdGggZW50cnkgZGV0YWlsc1xuICAgKiBAcGFyYW0gb3JkZXJCbG9jayAtIE9yZGVyIEJsb2NrIGZvciBlbnRyeSBsZXZlbFxuICAgKiBAcGFyYW0gZXF1aXR5IC0gQ3VycmVudCBhY2NvdW50IGVxdWl0eSBmb3IgcG9zaXRpb24gc2l6aW5nXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBleGVjdXRpb24gcmVzdWx0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcGxhY2VQb3N0T25seU9yZGVyKFxuICAgIHNpZ25hbDogU2lnbmFsRGF0YSwgXG4gICAgb3JkZXJCbG9jazogT3JkZXJCbG9jaywgXG4gICAgZXF1aXR5OiBudW1iZXJcbiAgKTogUHJvbWlzZTxFeGVjdXRpb25SZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gUGxhY2luZyBQb3N0LU9ubHkgb3JkZXIgZm9yICR7c2lnbmFsLnN5bWJvbH0gJHtzaWduYWwuZGlyZWN0aW9ufWApO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgZW50cnkgcHJpY2UgYXQgT3JkZXIgQmxvY2sgbGV2ZWxcbiAgICAgIGNvbnN0IGVudHJ5UHJpY2UgPSBzaWduYWwuZGlyZWN0aW9uID09PSAnTE9ORycgXG4gICAgICAgID8gb3JkZXJCbG9jay5sb3cgIC8vIEVudGVyIGF0IE9CIGJvdHRvbSBmb3IgbG9uZ3NcbiAgICAgICAgOiBvcmRlckJsb2NrLmhpZ2g7IC8vIEVudGVyIGF0IE9CIHRvcCBmb3Igc2hvcnRzXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBzaXplIHVzaW5nIFZvbGF0aWxpdHktQWRqdXN0ZWQgU2l6aW5nXG4gICAgICBjb25zdCBwb3NpdGlvblNpemUgPSBhd2FpdCB0aGlzLmNhbGNQb3NpdGlvblNpemUoXG4gICAgICAgIHNpZ25hbC5zeW1ib2wsIFxuICAgICAgICBlbnRyeVByaWNlLCBcbiAgICAgICAgZXF1aXR5LCBcbiAgICAgICAgc2lnbmFsLmxldmVyYWdlXG4gICAgICApO1xuXG4gICAgICBpZiAocG9zaXRpb25TaXplIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ1Bvc2l0aW9uIHNpemUgY2FsY3VsYXRpb24gZmFpbGVkIG9yIHRvbyBzbWFsbCdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHN0b3AgbG9zcyBhbmQgdGFrZSBwcm9maXRcbiAgICAgIGNvbnN0IHsgc3RvcExvc3MsIHRha2VQcm9maXQgfSA9IHRoaXMuc2V0U3RvcEFuZFRhcmdldChlbnRyeVByaWNlLCBzaWduYWwuZGlyZWN0aW9uKTtcblxuICAgICAgLy8gUHJlcGFyZSBvcmRlciBwYXJhbWV0ZXJzXG4gICAgICBjb25zdCBvcmRlclBhcmFtczogT3JkZXJQYXJhbXMgPSB7XG4gICAgICAgIHBoYXNlOiAncGhhc2UyJyxcbiAgICAgICAgc3ltYm9sOiBzaWduYWwuc3ltYm9sLFxuICAgICAgICBzaWRlOiBzaWduYWwuZGlyZWN0aW9uID09PSAnTE9ORycgPyAnQnV5JyA6ICdTZWxsJyxcbiAgICAgICAgdHlwZTogJ1BPU1RfT05MWScsXG4gICAgICAgIHByaWNlOiBlbnRyeVByaWNlLFxuICAgICAgICBxdHk6IHBvc2l0aW9uU2l6ZSxcbiAgICAgICAgbGV2ZXJhZ2U6IHNpZ25hbC5sZXZlcmFnZSxcbiAgICAgICAgc3RvcExvc3MsXG4gICAgICAgIHRha2VQcm9maXRcbiAgICAgIH07XG5cbiAgICAgIC8vIFBsYWNlIG9yZGVyIHdpdGggcmV0cnkgbG9naWNcbiAgICAgIGNvbnN0IG9yZGVyUmVzdWx0ID0gYXdhaXQgdGhpcy5ieWJpdENsaWVudC5wbGFjZU9yZGVyV2l0aFJldHJ5KFxuICAgICAgICBvcmRlclBhcmFtcywgXG4gICAgICAgIHRoaXMuY29uZmlnLm1heFJldHJpZXNcbiAgICAgICk7XG5cbiAgICAgIGlmIChvcmRlclJlc3VsdC5vcmRlcklkKSB7XG4gICAgICAgIC8vIFN0YXJ0IG1vbml0b3JpbmcgdGhlIG9yZGVyXG4gICAgICAgIHRoaXMuc3RhcnRPcmRlck1vbml0b3Jpbmcob3JkZXJSZXN1bHQub3JkZXJJZCwgc2lnbmFsLnN5bWJvbCwgZW50cnlQcmljZSwgb3JkZXJCbG9jaywgc2lnbmFsLnRpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZW1pdCgnb3JkZXI6cGxhY2VkJywgb3JkZXJSZXN1bHQub3JkZXJJZCwgc2lnbmFsLnN5bWJvbCwgZW50cnlQcmljZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFBvc3QtT25seSBvcmRlciBwbGFjZWQ6ICR7c2lnbmFsLnN5bWJvbH0gQCAke2VudHJ5UHJpY2V9IChJRDogJHtvcmRlclJlc3VsdC5vcmRlcklkfSlgKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBvcmRlcklkOiBvcmRlclJlc3VsdC5vcmRlcklkLFxuICAgICAgICAgIHBvc2l0aW9uU2l6ZSxcbiAgICAgICAgICBzdG9wTG9zcyxcbiAgICAgICAgICB0YWtlUHJvZml0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ09yZGVyIHBsYWNlbWVudCBmYWlsZWQgLSBubyBvcmRlciBJRCByZXR1cm5lZCdcbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gcGxhY2UgUG9zdC1Pbmx5IG9yZGVyIGZvciAke3NpZ25hbC5zeW1ib2x9OmAsIGVycm9yTXNnKTtcbiAgICAgIFxuICAgICAgbG9nRXJyb3IoJ0VSUk9SJywgYEZhaWxlZCB0byBwbGFjZSBQb3N0LU9ubHkgb3JkZXIgZm9yICR7c2lnbmFsLnN5bWJvbH1gLCB7XG4gICAgICAgIHN5bWJvbDogc2lnbmFsLnN5bWJvbCxcbiAgICAgICAgY29tcG9uZW50OiAnTGltaXRPcmRlckV4ZWN1dG9yJyxcbiAgICAgICAgZnVuY3Rpb246ICdwbGFjZVBvc3RPbmx5T3JkZXInLFxuICAgICAgICBzdGFjazogKGVycm9yIGFzIEVycm9yKS5zdGFjayxcbiAgICAgICAgZGF0YTogeyBzaWduYWwsIG9yZGVyQmxvY2sgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHRoaXMuZW1pdCgnZXhlY3V0aW9uOmVycm9yJywgZXJyb3IgYXMgRXJyb3IsIHsgc2lnbmFsLCBvcmRlckJsb2NrIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yTXNnXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb25pdG9yIG9yZGVyIHdpdGggNjAtc2Vjb25kIHRpbWVvdXRcbiAgICogQHBhcmFtIG9yZGVySWQgLSBPcmRlciBJRCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBzeW1ib2wgLSBUcmFkaW5nIHN5bWJvbFxuICAgKiBAcGFyYW0gZW50cnlQcmljZSAtIEV4cGVjdGVkIGVudHJ5IHByaWNlXG4gICAqIEBwYXJhbSBvcmRlckJsb2NrIC0gT3JkZXIgQmxvY2sgcmVmZXJlbmNlXG4gICAqL1xuICBwcml2YXRlIHN0YXJ0T3JkZXJNb25pdG9yaW5nKFxuICAgIG9yZGVySWQ6IHN0cmluZywgXG4gICAgc3ltYm9sOiBzdHJpbmcsIFxuICAgIGVudHJ5UHJpY2U6IG51bWJlciwgXG4gICAgb3JkZXJCbG9jazogT3JkZXJCbG9jayxcbiAgICBzaWduYWxJZD86IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICBjb25zdCBtb25pdG9yaW5nU3RhdGU6IE9yZGVyTW9uaXRvcmluZ1N0YXRlID0ge1xuICAgICAgb3JkZXJJZCxcbiAgICAgIHN5bWJvbCxcbiAgICAgIGVudHJ5UHJpY2UsXG4gICAgICBvcmRlckJsb2NrLFxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGZpbGxlZDogZmFsc2UsXG4gICAgICBzaWduYWxJZFxuICAgIH07XG5cbiAgICB0aGlzLmFjdGl2ZU9yZGVycy5zZXQob3JkZXJJZCwgbW9uaXRvcmluZ1N0YXRlKTtcbiAgICBjb25zb2xlLmxvZyhg8J+Rge+4jyBTdGFydGVkIG1vbml0b3Jpbmcgb3JkZXIgJHtvcmRlcklkfSBmb3IgJHtzeW1ib2x9YCk7XG4gIH1cblxuICAvKipcbiAgICogTW9uaXRvciBvcmRlciBhbmQgY2FuY2VsIGlmIHByaWNlIG1vdmVzIGF3YXkgPiAwLjIlXG4gICAqIEBwYXJhbSBvcmRlcklkIC0gT3JkZXIgSUQgdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY3VycmVudFByaWNlIC0gQ3VycmVudCBtYXJrZXQgcHJpY2VcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGNhbmNlbGxhdGlvbiByZXN1bHRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjYW5jZWxJZlByaWNlTW92ZXMob3JkZXJJZDogc3RyaW5nLCBjdXJyZW50UHJpY2U6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IG9yZGVyU3RhdGUgPSB0aGlzLmFjdGl2ZU9yZGVycy5nZXQob3JkZXJJZCk7XG4gICAgaWYgKCFvcmRlclN0YXRlIHx8IG9yZGVyU3RhdGUuY2FuY2VsbGVkIHx8IG9yZGVyU3RhdGUuZmlsbGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHByaWNlIG1vdmVtZW50IGZyb20gZW50cnkgbGV2ZWxcbiAgICBjb25zdCBwcmljZU1vdmUgPSBNYXRoLmFicyhjdXJyZW50UHJpY2UgLSBvcmRlclN0YXRlLmVudHJ5UHJpY2UpIC8gb3JkZXJTdGF0ZS5lbnRyeVByaWNlO1xuICAgIFxuICAgIGlmIChwcmljZU1vdmUgPiB0aGlzLmNvbmZpZy5wcmljZU1vdmVDYW5jZWxUaHJlc2hvbGQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OJIFByaWNlIG1vdmVkICR7KHByaWNlTW92ZSAqIDEwMCkudG9GaXhlZCgyKX0lIGF3YXkgZnJvbSAke29yZGVyU3RhdGUuc3ltYm9sfSBvcmRlciwgY2FuY2VsbGluZ2ApO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5ieWJpdENsaWVudC5jYW5jZWxPcmRlcihvcmRlcklkLCBvcmRlclN0YXRlLnN5bWJvbCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIG9yZGVyU3RhdGUuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFjdGl2ZU9yZGVycy5zZXQob3JkZXJJZCwgb3JkZXJTdGF0ZSk7XG4gICAgICAgICAgdGhpcy5lbWl0KCdvcmRlcjpjYW5jZWxsZWQnLCBvcmRlcklkLCAnUFJJQ0VfTU9WRURfQVdBWScpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgT3JkZXIgY2FuY2VsbGVkIGR1ZSB0byBwcmljZSBtb3ZlbWVudDogJHtvcmRlcklkfWApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIGNhbmNlbCBvcmRlciAke29yZGVySWR9OmAsIGVycm9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRpb246ZXJyb3InLCBlcnJvciBhcyBFcnJvciwgeyBvcmRlcklkLCByZWFzb246ICdDQU5DRUxfRkFJTEVEJyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIG9yZGVyIHdoZW4gcHJpY2Ugd2lja3MgdGhyb3VnaCBPcmRlciBCbG9jayA+IDAuNSVcbiAgICogQHBhcmFtIG9yZGVySWQgLSBPcmRlciBJRCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjdXJyZW50Q2FuZGxlIC0gQ3VycmVudCBPSExDViBjYW5kbGVcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGNhbmNlbGxhdGlvbiByZXN1bHRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjYW5jZWxJZkxldmVsRmFpbHMob3JkZXJJZDogc3RyaW5nLCBjdXJyZW50Q2FuZGxlOiBPSExDVik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IG9yZGVyU3RhdGUgPSB0aGlzLmFjdGl2ZU9yZGVycy5nZXQob3JkZXJJZCk7XG4gICAgaWYgKCFvcmRlclN0YXRlIHx8IG9yZGVyU3RhdGUuY2FuY2VsbGVkIHx8IG9yZGVyU3RhdGUuZmlsbGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JkZXJCbG9jayA9IG9yZGVyU3RhdGUub3JkZXJCbG9jaztcbiAgICBsZXQgd2lja1Rocm91Z2ggPSBmYWxzZTtcbiAgICBsZXQgd2lja1BlcmNlbnQgPSAwO1xuXG4gICAgaWYgKG9yZGVyQmxvY2sudHlwZSA9PT0gJ0JVTExJU0gnKSB7XG4gICAgICAvLyBGb3IgYnVsbGlzaCBPQiwgY2hlY2sgaWYgcHJpY2Ugd2lja2VkIGJlbG93IE9CIGxvd1xuICAgICAgaWYgKGN1cnJlbnRDYW5kbGUubG93IDwgb3JkZXJCbG9jay5sb3cpIHtcbiAgICAgICAgd2lja1BlcmNlbnQgPSAob3JkZXJCbG9jay5sb3cgLSBjdXJyZW50Q2FuZGxlLmxvdykgLyBvcmRlckJsb2NrLmxvdztcbiAgICAgICAgd2lja1Rocm91Z2ggPSB3aWNrUGVyY2VudCA+IHRoaXMuY29uZmlnLmxldmVsRmFpbFRocmVzaG9sZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGJlYXJpc2ggT0IsIGNoZWNrIGlmIHByaWNlIHdpY2tlZCBhYm92ZSBPQiBoaWdoXG4gICAgICBpZiAoY3VycmVudENhbmRsZS5oaWdoID4gb3JkZXJCbG9jay5oaWdoKSB7XG4gICAgICAgIHdpY2tQZXJjZW50ID0gKGN1cnJlbnRDYW5kbGUuaGlnaCAtIG9yZGVyQmxvY2suaGlnaCkgLyBvcmRlckJsb2NrLmhpZ2g7XG4gICAgICAgIHdpY2tUaHJvdWdoID0gd2lja1BlcmNlbnQgPiB0aGlzLmNvbmZpZy5sZXZlbEZhaWxUaHJlc2hvbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpY2tUaHJvdWdoKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+SpSBPcmRlciBCbG9jayBsZXZlbCBmYWlsZWQgZm9yICR7b3JkZXJTdGF0ZS5zeW1ib2x9ICgkeyh3aWNrUGVyY2VudCAqIDEwMCkudG9GaXhlZCgyKX0lIHdpY2spLCBjYW5jZWxsaW5nYCk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLmJ5Yml0Q2xpZW50LmNhbmNlbE9yZGVyKG9yZGVySWQsIG9yZGVyU3RhdGUuc3ltYm9sKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgb3JkZXJTdGF0ZS5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYWN0aXZlT3JkZXJzLnNldChvcmRlcklkLCBvcmRlclN0YXRlKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ29yZGVyOmNhbmNlbGxlZCcsIG9yZGVySWQsICdMRVZFTF9GQUlMRUQnKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIE9yZGVyIGNhbmNlbGxlZCBkdWUgdG8gbGV2ZWwgZmFpbHVyZTogJHtvcmRlcklkfWApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIGNhbmNlbCBvcmRlciAke29yZGVySWR9OmAsIGVycm9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdleGVjdXRpb246ZXJyb3InLCBlcnJvciBhcyBFcnJvciwgeyBvcmRlcklkLCByZWFzb246ICdDQU5DRUxfRkFJTEVEJyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHBvc2l0aW9uIHNpemUgdXNpbmcgVm9sYXRpbGl0eS1BZGp1c3RlZCBTaXppbmdcbiAgICogQHBhcmFtIHN5bWJvbCAtIFRyYWRpbmcgc3ltYm9sXG4gICAqIEBwYXJhbSBlbnRyeVByaWNlIC0gRW50cnkgcHJpY2VcbiAgICogQHBhcmFtIGVxdWl0eSAtIEFjY291bnQgZXF1aXR5XG4gICAqIEBwYXJhbSBsZXZlcmFnZSAtIExldmVyYWdlIG11bHRpcGxpZXJcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHBvc2l0aW9uIHNpemVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjYWxjUG9zaXRpb25TaXplKFxuICAgIHN5bWJvbDogc3RyaW5nLCBcbiAgICBlbnRyeVByaWNlOiBudW1iZXIsIFxuICAgIGVxdWl0eTogbnVtYmVyLCBcbiAgICBsZXZlcmFnZTogbnVtYmVyXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIHJlY2VudCBPSExDViBkYXRhIGZvciBBVFIgY2FsY3VsYXRpb25cbiAgICAgIGNvbnN0IGNhbmRsZXMgPSBhd2FpdCB0aGlzLmJ5Yml0Q2xpZW50LmZldGNoT0hMQ1Yoc3ltYm9sLCAnMWgnLCB0aGlzLmNvbmZpZy5hdHJQZXJpb2QgKyAxMCk7XG4gICAgICBcbiAgICAgIGlmIChjYW5kbGVzLmxlbmd0aCA8IHRoaXMuY29uZmlnLmF0clBlcmlvZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBjYW5kbGUgZGF0YSBmb3IgQVRSIGNhbGN1bGF0aW9uOiAke2NhbmRsZXMubGVuZ3RofSA8ICR7dGhpcy5jb25maWcuYXRyUGVyaW9kfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgQVRSIChBdmVyYWdlIFRydWUgUmFuZ2UpXG4gICAgICBjb25zdCBhdHIgPSB0aGlzLmNhbGN1bGF0ZUFUUihjYW5kbGVzLCB0aGlzLmNvbmZpZy5hdHJQZXJpb2QpO1xuICAgICAgXG4gICAgICAvLyBSaXNrIGFtb3VudCAoMiUgb2YgZXF1aXR5IGJ5IGRlZmF1bHQpXG4gICAgICBjb25zdCByaXNrUGVyY2VudCA9IDAuMDI7IC8vIDIlIHJpc2sgcGVyIHRyYWRlXG4gICAgICBjb25zdCByaXNrQW1vdW50ID0gZXF1aXR5ICogcmlza1BlcmNlbnQ7XG4gICAgICBcbiAgICAgIC8vIFN0b3AgZGlzdGFuY2UgaW4gcHJpY2UgdGVybXNcbiAgICAgIGNvbnN0IHN0b3BEaXN0YW5jZSA9IGVudHJ5UHJpY2UgKiB0aGlzLmNvbmZpZy5zdG9wTG9zc1BlcmNlbnQ7XG4gICAgICBcbiAgICAgIC8vIFZvbGF0aWxpdHktQWRqdXN0ZWQgU2l6aW5nOiBSaXNrX0RvbGxhcnMgLyAoQVRSICogU3RvcF9EaXN0YW5jZV9NdWx0aXBsaWVyKVxuICAgICAgLy8gVXNlIEFUUiBhcyB2b2xhdGlsaXR5IGFkanVzdG1lbnQgZmFjdG9yXG4gICAgICBjb25zdCB2b2xhdGlsaXR5QWRqdXN0bWVudCA9IGF0ciAvIGVudHJ5UHJpY2U7IC8vIEFUUiBhcyAlIG9mIHByaWNlXG4gICAgICBjb25zdCBhZGp1c3RlZFN0b3BEaXN0YW5jZSA9IHN0b3BEaXN0YW5jZSAqICgxICsgdm9sYXRpbGl0eUFkanVzdG1lbnQpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgYmFzZSBwb3NpdGlvbiBzaXplXG4gICAgICBjb25zdCBiYXNlUG9zaXRpb25TaXplID0gcmlza0Ftb3VudCAvIGFkanVzdGVkU3RvcERpc3RhbmNlO1xuICAgICAgXG4gICAgICAvLyBBcHBseSBsZXZlcmFnZSAoYnV0IGNhcCBhdCByZWFzb25hYmxlIGxldmVscylcbiAgICAgIGNvbnN0IG1heExldmVyYWdlTXVsdGlwbGllciA9IE1hdGgubWluKGxldmVyYWdlLCA1KTsgLy8gQ2FwIGF0IDV4IGZvciBzYWZldHlcbiAgICAgIGNvbnN0IHBvc2l0aW9uU2l6ZSA9IGJhc2VQb3NpdGlvblNpemUgKiBtYXhMZXZlcmFnZU11bHRpcGxpZXI7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBtaW5pbXVtIHBvc2l0aW9uIHNpemUgKDAuMDAxIGZvciBtb3N0IHN5bWJvbHMpXG4gICAgICBjb25zdCBtaW5Qb3NpdGlvblNpemUgPSAwLjAwMTtcbiAgICAgIGNvbnN0IGZpbmFsUG9zaXRpb25TaXplID0gTWF0aC5tYXgocG9zaXRpb25TaXplLCBtaW5Qb3NpdGlvblNpemUpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBQb3NpdGlvbiBzaXppbmcgZm9yICR7c3ltYm9sfTpgKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgICBBVFI6ICR7YXRyLnRvRml4ZWQoNCl9ICgkeyh2b2xhdGlsaXR5QWRqdXN0bWVudCAqIDEwMCkudG9GaXhlZCgyKX0lKWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIFJpc2sgQW1vdW50OiAkJHtyaXNrQW1vdW50LnRvRml4ZWQoMil9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgICAgU3RvcCBEaXN0YW5jZTogJHtzdG9wRGlzdGFuY2UudG9GaXhlZCg0KX0gKCR7KHRoaXMuY29uZmlnLnN0b3BMb3NzUGVyY2VudCAqIDEwMCkudG9GaXhlZCgxKX0lKWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIFBvc2l0aW9uIFNpemU6ICR7ZmluYWxQb3NpdGlvblNpemUudG9GaXhlZCg0KX1gKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZpbmFsUG9zaXRpb25TaXplO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIHNpemUgZm9yICR7c3ltYm9sfTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2l0aW9uIHNpemUgY2FsY3VsYXRpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc3RvcCBsb3NzIGFuZCB0YWtlIHByb2ZpdCB3aXRoIDEuNSUgc3RvcCwgNC41JSB0YXJnZXQgKDM6MSBSOlIpXG4gICAqIEBwYXJhbSBlbnRyeVByaWNlIC0gRW50cnkgcHJpY2VcbiAgICogQHBhcmFtIGRpcmVjdGlvbiAtIFRyYWRlIGRpcmVjdGlvblxuICAgKiBAcmV0dXJucyBTdG9wIGxvc3MgYW5kIHRha2UgcHJvZml0IHByaWNlc1xuICAgKi9cbiAgcHVibGljIHNldFN0b3BBbmRUYXJnZXQoZW50cnlQcmljZTogbnVtYmVyLCBkaXJlY3Rpb246ICdMT05HJyB8ICdTSE9SVCcpOiB7XG4gICAgc3RvcExvc3M6IG51bWJlcjtcbiAgICB0YWtlUHJvZml0OiBudW1iZXI7XG4gIH0ge1xuICAgIGNvbnN0IHN0b3BEaXN0YW5jZSA9IGVudHJ5UHJpY2UgKiB0aGlzLmNvbmZpZy5zdG9wTG9zc1BlcmNlbnQ7XG4gICAgY29uc3QgdGFyZ2V0RGlzdGFuY2UgPSBlbnRyeVByaWNlICogdGhpcy5jb25maWcudGFrZVByb2ZpdFBlcmNlbnQ7XG5cbiAgICBsZXQgc3RvcExvc3M6IG51bWJlcjtcbiAgICBsZXQgdGFrZVByb2ZpdDogbnVtYmVyO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ0xPTkcnKSB7XG4gICAgICBzdG9wTG9zcyA9IGVudHJ5UHJpY2UgLSBzdG9wRGlzdGFuY2U7ICAgLy8gMS41JSBiZWxvdyBlbnRyeVxuICAgICAgdGFrZVByb2ZpdCA9IGVudHJ5UHJpY2UgKyB0YXJnZXREaXN0YW5jZTsgLy8gNC41JSBhYm92ZSBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wTG9zcyA9IGVudHJ5UHJpY2UgKyBzdG9wRGlzdGFuY2U7ICAgLy8gMS41JSBhYm92ZSBlbnRyeVxuICAgICAgdGFrZVByb2ZpdCA9IGVudHJ5UHJpY2UgLSB0YXJnZXREaXN0YW5jZTsgLy8gNC41JSBiZWxvdyBlbnRyeVxuICAgIH1cblxuICAgIGNvbnN0IHJpc2tSZXdhcmQgPSB0YXJnZXREaXN0YW5jZSAvIHN0b3BEaXN0YW5jZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+OryBTdG9wICYgVGFyZ2V0IGZvciAke2RpcmVjdGlvbn0gQCAke2VudHJ5UHJpY2UudG9GaXhlZCg0KX06YCk7XG4gICAgY29uc29sZS5sb2coYCAgIFN0b3AgTG9zczogJHtzdG9wTG9zcy50b0ZpeGVkKDQpfSAoLSR7KHRoaXMuY29uZmlnLnN0b3BMb3NzUGVyY2VudCAqIDEwMCkudG9GaXhlZCgxKX0lKWApO1xuICAgIGNvbnNvbGUubG9nKGAgICBUYWtlIFByb2ZpdDogJHt0YWtlUHJvZml0LnRvRml4ZWQoNCl9ICgrJHsodGhpcy5jb25maWcudGFrZVByb2ZpdFBlcmNlbnQgKiAxMDApLnRvRml4ZWQoMSl9JSlgKTtcbiAgICBjb25zb2xlLmxvZyhgICAgUmlzazpSZXdhcmQgPSAxOiR7cmlza1Jld2FyZC50b0ZpeGVkKDEpfWApO1xuXG4gICAgcmV0dXJuIHsgc3RvcExvc3MsIHRha2VQcm9maXQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgQXZlcmFnZSBUcnVlIFJhbmdlIChBVFIpXG4gICAqIEBwYXJhbSBjYW5kbGVzIC0gT0hMQ1YgY2FuZGxlIGRhdGFcbiAgICogQHBhcmFtIHBlcmlvZCAtIEFUUiBwZXJpb2QgKGRlZmF1bHQ6IDE0KVxuICAgKiBAcmV0dXJucyBBVFIgdmFsdWVcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlQVRSKGNhbmRsZXM6IE9ITENWW10sIHBlcmlvZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoY2FuZGxlcy5sZW5ndGggPCBwZXJpb2QgKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBkYXRhIGZvciBBVFIgY2FsY3VsYXRpb246IG5lZWQgJHtwZXJpb2QgKyAxfSwgZ290ICR7Y2FuZGxlcy5sZW5ndGh9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJ1ZVJhbmdlczogbnVtYmVyW10gPSBbXTtcblxuICAgIC8vIENhbGN1bGF0ZSBUcnVlIFJhbmdlIGZvciBlYWNoIGNhbmRsZSAoc3RhcnRpbmcgZnJvbSBpbmRleCAxKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY2FuZGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudCA9IGNhbmRsZXNbaV07XG4gICAgICBjb25zdCBwcmV2aW91cyA9IGNhbmRsZXNbaSAtIDFdO1xuXG4gICAgICAvLyBUcnVlIFJhbmdlID0gbWF4KGhpZ2gtbG93LCB8aGlnaC1wcmV2Q2xvc2V8LCB8bG93LXByZXZDbG9zZXwpXG4gICAgICBjb25zdCBoaWdoTG93ID0gY3VycmVudC5oaWdoIC0gY3VycmVudC5sb3c7XG4gICAgICBjb25zdCBoaWdoUHJldkNsb3NlID0gTWF0aC5hYnMoY3VycmVudC5oaWdoIC0gcHJldmlvdXMuY2xvc2UpO1xuICAgICAgY29uc3QgbG93UHJldkNsb3NlID0gTWF0aC5hYnMoY3VycmVudC5sb3cgLSBwcmV2aW91cy5jbG9zZSk7XG5cbiAgICAgIGNvbnN0IHRydWVSYW5nZSA9IE1hdGgubWF4KGhpZ2hMb3csIGhpZ2hQcmV2Q2xvc2UsIGxvd1ByZXZDbG9zZSk7XG4gICAgICB0cnVlUmFuZ2VzLnB1c2godHJ1ZVJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgQVRSIGFzIFNpbXBsZSBNb3ZpbmcgQXZlcmFnZSBvZiBUcnVlIFJhbmdlc1xuICAgIGNvbnN0IHJlY2VudFRydWVSYW5nZXMgPSB0cnVlUmFuZ2VzLnNsaWNlKC1wZXJpb2QpO1xuICAgIGNvbnN0IGF0ciA9IHJlY2VudFRydWVSYW5nZXMucmVkdWNlKChzdW0sIHRyKSA9PiBzdW0gKyB0ciwgMCkgLyBwZXJpb2Q7XG5cbiAgICByZXR1cm4gYXRyO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG1vbml0b3JpbmcgYWxsIGFjdGl2ZSBvcmRlcnNcbiAgICovXG4gIHByaXZhdGUgc3RhcnRNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgdGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLm1vbml0b3JBY3RpdmVPcmRlcnMoKTtcbiAgICB9LCB0aGlzLk1PTklUT1JJTkdfRlJFUVVFTkNZKTtcblxuICAgIGNvbnNvbGUubG9nKGDwn5GB77iPIExpbWl0IE9yZGVyIEV4ZWN1dG9yOiBTdGFydGVkIG1vbml0b3JpbmcgKCR7dGhpcy5NT05JVE9SSU5HX0ZSRVFVRU5DWX1tcyBpbnRlcnZhbClgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb25pdG9yIGFsbCBhY3RpdmUgb3JkZXJzIGZvciB0aW1lb3V0LCBmaWxscywgYW5kIGNhbmNlbGxhdGlvbiBjb25kaXRpb25zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIG1vbml0b3JBY3RpdmVPcmRlcnMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgYWN0aXZlT3JkZXJJZHMgPSBBcnJheS5mcm9tKHRoaXMuYWN0aXZlT3JkZXJzLmtleXMoKSk7XG4gICAgXG4gICAgZm9yIChjb25zdCBvcmRlcklkIG9mIGFjdGl2ZU9yZGVySWRzKSB7XG4gICAgICBjb25zdCBvcmRlclN0YXRlID0gdGhpcy5hY3RpdmVPcmRlcnMuZ2V0KG9yZGVySWQpO1xuICAgICAgaWYgKCFvcmRlclN0YXRlIHx8IG9yZGVyU3RhdGUuY2FuY2VsbGVkIHx8IG9yZGVyU3RhdGUuZmlsbGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgdGltZW91dCAoNjAgc2Vjb25kcylcbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBvcmRlclN0YXRlLnN0YXJ0VGltZTtcbiAgICAgICAgaWYgKGVsYXBzZWQgPiB0aGlzLmNvbmZpZy5vcmRlclRpbWVvdXQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZU9yZGVyVGltZW91dChvcmRlcklkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG9yZGVyIHN0YXR1c1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLmJ5Yml0Q2xpZW50LmdldE9yZGVyU3RhdHVzKG9yZGVySWQsIG9yZGVyU3RhdGUuc3ltYm9sKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdGSUxMRUQnKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVPcmRlckZpbGxlZChvcmRlcklkKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdDQU5DRUxMRUQnKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVPcmRlckNhbmNlbGxlZChvcmRlcklkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPcmRlciBzdGlsbCBhY3RpdmUsIGNoZWNrIGNhbmNlbGxhdGlvbiBjb25kaXRpb25zXG4gICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0NhbmNlbGxhdGlvbkNvbmRpdGlvbnMob3JkZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIG1vbml0b3Jpbmcgb3JkZXIgJHtvcmRlcklkfTpgLCBlcnJvcik7XG4gICAgICAgIHRoaXMuZW1pdCgnZXhlY3V0aW9uOmVycm9yJywgZXJyb3IgYXMgRXJyb3IsIHsgb3JkZXJJZCwgYWN0aW9uOiAnTU9OSVRPUklORycgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBvcmRlciB0aW1lb3V0ICg2MCBzZWNvbmRzKVxuICAgKiBAcGFyYW0gb3JkZXJJZCAtIE9yZGVyIElEIHRoYXQgdGltZWQgb3V0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZU9yZGVyVGltZW91dChvcmRlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBvcmRlclN0YXRlID0gdGhpcy5hY3RpdmVPcmRlcnMuZ2V0KG9yZGVySWQpO1xuICAgIGlmICghb3JkZXJTdGF0ZSkgcmV0dXJuO1xuXG4gICAgY29uc29sZS5sb2coYOKPsCBPcmRlciB0aW1lb3V0IGZvciAke29yZGVyU3RhdGUuc3ltYm9sfTogJHtvcmRlcklkfWApO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENhbmNlbCB0aGUgdGltZWQtb3V0IG9yZGVyXG4gICAgICBhd2FpdCB0aGlzLmJ5Yml0Q2xpZW50LmNhbmNlbE9yZGVyKG9yZGVySWQsIG9yZGVyU3RhdGUuc3ltYm9sKTtcbiAgICAgIFxuICAgICAgb3JkZXJTdGF0ZS5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hY3RpdmVPcmRlcnMuc2V0KG9yZGVySWQsIG9yZGVyU3RhdGUpO1xuICAgICAgXG4gICAgICB0aGlzLmVtaXQoJ29yZGVyOnRpbWVvdXQnLCBvcmRlcklkKTtcbiAgICAgIHRoaXMuZW1pdCgnb3JkZXI6Y2FuY2VsbGVkJywgb3JkZXJJZCwgJ1RJTUVPVVQnKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYOKchSBUaW1lZC1vdXQgb3JkZXIgY2FuY2VsbGVkOiAke29yZGVySWR9YCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBjYW5jZWwgdGltZWQtb3V0IG9yZGVyICR7b3JkZXJJZH06YCwgZXJyb3IpO1xuICAgICAgdGhpcy5lbWl0KCdleGVjdXRpb246ZXJyb3InLCBlcnJvciBhcyBFcnJvciwgeyBvcmRlcklkLCByZWFzb246ICdUSU1FT1VUX0NBTkNFTF9GQUlMRUQnIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgb3JkZXIgZmlsbGVkXG4gICAqIEBwYXJhbSBvcmRlcklkIC0gT3JkZXIgSUQgdGhhdCB3YXMgZmlsbGVkXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZU9yZGVyRmlsbGVkKG9yZGVySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG9yZGVyU3RhdGUgPSB0aGlzLmFjdGl2ZU9yZGVycy5nZXQob3JkZXJJZCk7XG4gICAgaWYgKCFvcmRlclN0YXRlKSByZXR1cm47XG5cbiAgICBjb25zb2xlLmxvZyhg4pyFIE9yZGVyIGZpbGxlZDogJHtvcmRlclN0YXRlLnN5bWJvbH0gQCAke29yZGVyU3RhdGUuZW50cnlQcmljZX1gKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgZmlsbCBkZXRhaWxzICh0aGlzIHdvdWxkIG5lZWQgdG8gYmUgaW1wbGVtZW50ZWQgaW4gQnliaXRQZXJwc0NsaWVudClcbiAgICAgIGNvbnN0IGZpbGxQcmljZSA9IG9yZGVyU3RhdGUuZW50cnlQcmljZTsgLy8gU2ltcGxpZmllZCAtIHNob3VsZCBnZXQgYWN0dWFsIGZpbGwgcHJpY2VcbiAgICAgIFxuICAgICAgb3JkZXJTdGF0ZS5maWxsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hY3RpdmVPcmRlcnMuc2V0KG9yZGVySWQsIG9yZGVyU3RhdGUpO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gc2l6ZSAodGhpcyBzaG91bGQgYmUgc3RvcmVkIGZyb20gb3JpZ2luYWwgb3JkZXIpXG4gICAgICBjb25zdCBwb3NpdGlvblNpemUgPSAwLjE7IC8vIFNpbXBsaWZpZWQgLSBzaG91bGQgZ2V0IGFjdHVhbCBmaWxsIHF1YW50aXR5XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBzbGlwcGFnZVxuICAgICAgY29uc3QgZXhwZWN0ZWRQcmljZSA9IG9yZGVyU3RhdGUuZW50cnlQcmljZTtcbiAgICAgIGNvbnN0IHNsaXBwYWdlID0gTWF0aC5hYnMoZmlsbFByaWNlIC0gZXhwZWN0ZWRQcmljZSkgLyBleHBlY3RlZFByaWNlO1xuICAgICAgXG4gICAgICB0aGlzLmVtaXQoJ29yZGVyOmZpbGxlZCcsIG9yZGVySWQsIGZpbGxQcmljZSwgcG9zaXRpb25TaXplKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIGV4ZWN1dGlvbiB0byBzdHJ1Y3R1cmVkIGxvZ2dlclxuICAgICAgY29uc3Qgb3JkZXJSZXN1bHQ6IE9yZGVyUmVzdWx0ID0ge1xuICAgICAgICBvcmRlcklkLFxuICAgICAgICBzeW1ib2w6IG9yZGVyU3RhdGUuc3ltYm9sLFxuICAgICAgICBzaWRlOiBvcmRlclN0YXRlLnN5bWJvbC5pbmNsdWRlcygnTE9ORycpID8gJ0J1eScgOiAnU2VsbCcsXG4gICAgICAgIHF0eTogcG9zaXRpb25TaXplLFxuICAgICAgICBwcmljZTogZmlsbFByaWNlLFxuICAgICAgICBzdGF0dXM6ICdGSUxMRUQnLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGxvZ0V4ZWN1dGlvbihvcmRlclJlc3VsdCwgc2xpcHBhZ2UsIG9yZGVyU3RhdGUuc2lnbmFsSWQpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgcG9zaXRpb24gb2JqZWN0IGZvciBwb3NpdGlvbiBtYW5hZ2VyXG4gICAgICBjb25zdCB7IHN0b3BMb3NzLCB0YWtlUHJvZml0IH0gPSB0aGlzLnNldFN0b3BBbmRUYXJnZXQoXG4gICAgICAgIGZpbGxQcmljZSwgXG4gICAgICAgIG9yZGVyU3RhdGUuc3ltYm9sLmluY2x1ZGVzKCdMT05HJykgPyAnTE9ORycgOiAnU0hPUlQnIC8vIFNpbXBsaWZpZWQgZGlyZWN0aW9uIGRldGVjdGlvblxuICAgICAgKTtcblxuICAgICAgY29uc3QgcG9zaXRpb246IFBvc2l0aW9uID0ge1xuICAgICAgICBpZDogb3JkZXJJZCxcbiAgICAgICAgc3ltYm9sOiBvcmRlclN0YXRlLnN5bWJvbCxcbiAgICAgICAgc2lkZTogb3JkZXJTdGF0ZS5zeW1ib2wuaW5jbHVkZXMoJ0xPTkcnKSA/ICdMT05HJyA6ICdTSE9SVCcsIC8vIFNpbXBsaWZpZWRcbiAgICAgICAgZW50cnlQcmljZTogZmlsbFByaWNlLFxuICAgICAgICBjdXJyZW50UHJpY2U6IGZpbGxQcmljZSxcbiAgICAgICAgcXVhbnRpdHk6IHBvc2l0aW9uU2l6ZSxcbiAgICAgICAgbGV2ZXJhZ2U6IDMsIC8vIERlZmF1bHQgbGV2ZXJhZ2VcbiAgICAgICAgc3RvcExvc3MsXG4gICAgICAgIHRha2VQcm9maXQsXG4gICAgICAgIHVucmVhbGl6ZWRQbkw6IDAsXG4gICAgICAgIHJlYWxpemVkUG5MOiAwLFxuICAgICAgICBlbnRyeVRpbWU6IERhdGUubm93KCksXG4gICAgICAgIHN0YXR1czogJ09QRU4nLFxuICAgICAgICByVmFsdWU6IDAsXG4gICAgICAgIGF0cjogYXdhaXQgdGhpcy5nZXRBVFJGb3JTeW1ib2wob3JkZXJTdGF0ZS5zeW1ib2wpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmVtaXQoJ3Bvc2l0aW9uOmNyZWF0ZWQnLCBwb3NpdGlvbik7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGFjdGl2ZSBtb25pdG9yaW5nXG4gICAgICB0aGlzLmFjdGl2ZU9yZGVycy5kZWxldGUob3JkZXJJZCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIGhhbmRsaW5nIGZpbGxlZCBvcmRlciAke29yZGVySWR9OmAsIGVycm9yKTtcbiAgICAgIHRoaXMuZW1pdCgnZXhlY3V0aW9uOmVycm9yJywgZXJyb3IgYXMgRXJyb3IsIHsgb3JkZXJJZCwgcmVhc29uOiAnRklMTF9IQU5ETElOR19GQUlMRUQnIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgb3JkZXIgY2FuY2VsbGVkXG4gICAqIEBwYXJhbSBvcmRlcklkIC0gT3JkZXIgSUQgdGhhdCB3YXMgY2FuY2VsbGVkXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZU9yZGVyQ2FuY2VsbGVkKG9yZGVySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG9yZGVyU3RhdGUgPSB0aGlzLmFjdGl2ZU9yZGVycy5nZXQob3JkZXJJZCk7XG4gICAgaWYgKCFvcmRlclN0YXRlKSByZXR1cm47XG5cbiAgICBjb25zb2xlLmxvZyhg4p2MIE9yZGVyIGNhbmNlbGxlZDogJHtvcmRlclN0YXRlLnN5bWJvbH0gKCR7b3JkZXJJZH0pYCk7XG5cbiAgICBvcmRlclN0YXRlLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgdGhpcy5hY3RpdmVPcmRlcnMuc2V0KG9yZGVySWQsIG9yZGVyU3RhdGUpO1xuICAgIFxuICAgIHRoaXMuZW1pdCgnb3JkZXI6Y2FuY2VsbGVkJywgb3JkZXJJZCwgJ0VYVEVSTkFMX0NBTkNFTCcpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIGFjdGl2ZSBtb25pdG9yaW5nXG4gICAgdGhpcy5hY3RpdmVPcmRlcnMuZGVsZXRlKG9yZGVySWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGNhbmNlbGxhdGlvbiBjb25kaXRpb25zIGZvciBhY3RpdmUgb3JkZXJcbiAgICogQHBhcmFtIG9yZGVySWQgLSBPcmRlciBJRCB0byBjaGVja1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0NhbmNlbGxhdGlvbkNvbmRpdGlvbnMob3JkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgb3JkZXJTdGF0ZSA9IHRoaXMuYWN0aXZlT3JkZXJzLmdldChvcmRlcklkKTtcbiAgICBpZiAoIW9yZGVyU3RhdGUpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBwcmljZVxuICAgICAgY29uc3QgY3VycmVudFByaWNlID0gYXdhaXQgdGhpcy5ieWJpdENsaWVudC5nZXRDdXJyZW50UHJpY2Uob3JkZXJTdGF0ZS5zeW1ib2wpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBwcmljZSBtb3ZlZCBhd2F5ID4gMC4yJVxuICAgICAgYXdhaXQgdGhpcy5jYW5jZWxJZlByaWNlTW92ZXMob3JkZXJJZCwgY3VycmVudFByaWNlKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgbGV2ZWwgZmFpbGVkICh3b3VsZCBuZWVkIGN1cnJlbnQgY2FuZGxlIGRhdGEpXG4gICAgICAvLyBUaGlzIGlzIHNpbXBsaWZpZWQgLSBpbiBwcmFjdGljZSwgeW91J2QgbmVlZCByZWFsLXRpbWUgY2FuZGxlIGRhdGFcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgY2hlY2tpbmcgY2FuY2VsbGF0aW9uIGNvbmRpdGlvbnMgZm9yICR7b3JkZXJJZH06YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQVRSIGZvciBzeW1ib2wgKGhlbHBlciBtZXRob2QpXG4gICAqIEBwYXJhbSBzeW1ib2wgLSBUcmFkaW5nIHN5bWJvbFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggQVRSIHZhbHVlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEFUUkZvclN5bWJvbChzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbmRsZXMgPSBhd2FpdCB0aGlzLmJ5Yml0Q2xpZW50LmZldGNoT0hMQ1Yoc3ltYm9sLCAnMWgnLCB0aGlzLmNvbmZpZy5hdHJQZXJpb2QgKyAxMCk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVBVFIoY2FuZGxlcywgdGhpcy5jb25maWcuYXRyUGVyaW9kKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBnZXQgQVRSIGZvciAke3N5bWJvbH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIDAuMDAxOyAvLyBEZWZhdWx0IEFUUlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWN0aXZlIG9yZGVycyBjb3VudFxuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgYWN0aXZlIG9yZGVyc1xuICAgKi9cbiAgcHVibGljIGdldEFjdGl2ZU9yZGVyc0NvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlT3JkZXJzLnNpemU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjdGl2ZSBvcmRlcnNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgYWN0aXZlIG9yZGVyIHN0YXRlc1xuICAgKi9cbiAgcHVibGljIGdldEFjdGl2ZU9yZGVycygpOiBPcmRlck1vbml0b3JpbmdTdGF0ZVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmFjdGl2ZU9yZGVycy52YWx1ZXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFsbCBhY3RpdmUgb3JkZXJzXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBjYW5jZWxsYXRpb24gcmVzdWx0c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGNhbmNlbEFsbE9yZGVycygpOiBQcm9taXNlPHsgc3VjY2VzczogbnVtYmVyOyBmYWlsZWQ6IG51bWJlciB9PiB7XG4gICAgY29uc29sZS5sb2coYPCfmqggQ2FuY2VsbGluZyBhbGwgYWN0aXZlIG9yZGVyc2ApO1xuICAgIFxuICAgIGNvbnN0IG9yZGVySWRzID0gQXJyYXkuZnJvbSh0aGlzLmFjdGl2ZU9yZGVycy5rZXlzKCkpO1xuICAgIGxldCBzdWNjZXNzID0gMDtcbiAgICBsZXQgZmFpbGVkID0gMDtcblxuICAgIGZvciAoY29uc3Qgb3JkZXJJZCBvZiBvcmRlcklkcykge1xuICAgICAgY29uc3Qgb3JkZXJTdGF0ZSA9IHRoaXMuYWN0aXZlT3JkZXJzLmdldChvcmRlcklkKTtcbiAgICAgIGlmICghb3JkZXJTdGF0ZSkgY29udGludWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYnliaXRDbGllbnQuY2FuY2VsT3JkZXIob3JkZXJJZCwgb3JkZXJTdGF0ZS5zeW1ib2wpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgc3VjY2VzcysrO1xuICAgICAgICAgIG9yZGVyU3RhdGUuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFjdGl2ZU9yZGVycy5zZXQob3JkZXJJZCwgb3JkZXJTdGF0ZSk7XG4gICAgICAgICAgdGhpcy5lbWl0KCdvcmRlcjpjYW5jZWxsZWQnLCBvcmRlcklkLCAnTUFOVUFMX0NBTkNFTF9BTEwnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWlsZWQrKztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBjYW5jZWwgb3JkZXIgJHtvcmRlcklkfTpgLCBlcnJvcik7XG4gICAgICAgIGZhaWxlZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDwn5qoIENhbmNlbCBhbGwgY29tcGxldGU6ICR7c3VjY2Vzc30gc3VjY2VzcywgJHtmYWlsZWR9IGZhaWxlZGApO1xuICAgIHJldHVybiB7IHN1Y2Nlc3MsIGZhaWxlZCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBuZXdDb25maWcgLSBOZXcgY29uZmlndXJhdGlvblxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUNvbmZpZyhuZXdDb25maWc6IFBhcnRpYWw8TGltaXRPcmRlckNvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLm5ld0NvbmZpZyB9O1xuICAgIGNvbnNvbGUubG9nKGDwn46vIExpbWl0IE9yZGVyIEV4ZWN1dG9yOiBDb25maWd1cmF0aW9uIHVwZGF0ZWRgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIG1vbml0b3JpbmcgYW5kIGNsZWFudXBcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCk7XG4gICAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuYWN0aXZlT3JkZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+OryBMaW1pdCBPcmRlciBFeGVjdXRvcjogRGVzdHJveWVkYCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IGV2ZW50IGludGVyZmFjZSBmb3IgVHlwZVNjcmlwdFxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIExpbWl0T3JkZXJFeGVjdXRvciB7XG4gIG9uPFUgZXh0ZW5kcyBrZXlvZiBMaW1pdE9yZGVyRXhlY3V0b3JFdmVudHM+KGV2ZW50OiBVLCBsaXN0ZW5lcjogTGltaXRPcmRlckV4ZWN1dG9yRXZlbnRzW1VdKTogdGhpcztcbiAgZW1pdDxVIGV4dGVuZHMga2V5b2YgTGltaXRPcmRlckV4ZWN1dG9yRXZlbnRzPihldmVudDogVSwgLi4uYXJnczogUGFyYW1ldGVyczxMaW1pdE9yZGVyRXhlY3V0b3JFdmVudHNbVV0+KTogYm9vbGVhbjtcbn0iXSwidmVyc2lvbiI6M30=