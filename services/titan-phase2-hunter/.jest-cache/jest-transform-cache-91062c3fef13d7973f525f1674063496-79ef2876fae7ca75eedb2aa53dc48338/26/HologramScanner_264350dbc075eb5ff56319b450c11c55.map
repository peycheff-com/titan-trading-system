{"file":"/Users/ivan/Code/trading/titan/services/titan-phase2-hunter/src/engine/HologramScanner.ts","mappings":"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","names":[],"sources":["/Users/ivan/Code/trading/titan/services/titan-phase2-hunter/src/engine/HologramScanner.ts"],"sourcesContent":["/**\n * HologramScanner - Continuous Symbol Scanning Engine\n * \n * Scans top 100 symbols by volume, ranks by alignment score, and selects top 20\n * for monitoring. Implements parallel processing and scan duration monitoring.\n * \n * Core Logic:\n * 1. Fetch top 100 symbols by 24h volume from Bybit\n * 2. Analyze each symbol using HologramEngine (parallel processing)\n * 3. Rank symbols by alignment score (A+ > B > CONFLICT > NO_PLAY)\n * 4. Select top 20 symbols for active monitoring\n * 5. Emit warning if scan takes > 30 seconds\n * \n * Requirements: 9.1-9.7 (Hologram Scanning Engine)\n */\n\nimport { EventEmitter } from 'events';\nimport { HologramState, HologramStatus } from '../types';\nimport { HologramEngine } from './HologramEngine';\nimport { BybitPerpsClient } from '../exchanges/BybitPerpsClient';\n\nexport interface ScanResult {\n  symbols: HologramState[];\n  top20: HologramState[];\n  scanDuration: number;\n  timestamp: number;\n  totalSymbols: number;\n  successCount: number;\n  errorCount: number;\n}\n\nexport interface ScanStats {\n  totalScans: number;\n  averageDuration: number;\n  lastScanDuration: number;\n  successRate: number;\n  slowScans: number; // Scans > 30s\n}\n\nexport class HologramScanner extends EventEmitter {\n  private hologramEngine: HologramEngine;\n  private bybitClient: BybitPerpsClient;\n  private isScanning = false;\n  private scanStats: ScanStats = {\n    totalScans: 0,\n    averageDuration: 0,\n    lastScanDuration: 0,\n    successRate: 0,\n    slowScans: 0\n  };\n  private readonly SCAN_WARNING_THRESHOLD = 30000; // 30 seconds\n  private readonly MAX_PARALLEL_REQUESTS = 10; // Limit concurrent API calls\n  private readonly SCAN_TIMEOUT = 60000; // 60 seconds max scan time\n\n  constructor(bybitClient: BybitPerpsClient) {\n    super();\n    this.bybitClient = bybitClient;\n    this.hologramEngine = new HologramEngine(bybitClient);\n  }\n\n  /**\n   * Scan top 100 symbols and return ranked results\n   * Implements parallel processing with concurrency limits\n   * \n   * @returns Promise with scan results including top 20 symbols\n   */\n  public async scan(): Promise<ScanResult> {\n    if (this.isScanning) {\n      throw new Error('Scan already in progress');\n    }\n\n    this.isScanning = true;\n    const startTime = Date.now();\n    let symbols: string[] = [];\n    let holograms: HologramState[] = [];\n    let successCount = 0;\n    let errorCount = 0;\n\n    try {\n      console.log('üîç Starting hologram scan...');\n      \n      // Step 1: Fetch top 100 symbols by volume\n      symbols = await this.fetchTopSymbols();\n      console.log(`üìä Fetched ${symbols.length} symbols for analysis`);\n\n      // Step 2: Analyze symbols in parallel with concurrency control\n      holograms = await this.analyzeSymbolsParallel(symbols);\n      \n      // Count successes and errors\n      successCount = holograms.length;\n      errorCount = symbols.length - successCount;\n\n      // Step 3: Rank symbols by alignment score\n      const rankedSymbols = this.rankByAlignment(holograms);\n\n      // Step 4: Select top 20 for monitoring\n      const top20 = this.selectTop20(rankedSymbols);\n\n      // Calculate scan duration\n      const scanDuration = Date.now() - startTime;\n\n      // Step 5: Check for slow scan warning\n      if (scanDuration > this.SCAN_WARNING_THRESHOLD) {\n        this.scanStats.slowScans++;\n        this.emit('scanSlow', {\n          duration: scanDuration,\n          threshold: this.SCAN_WARNING_THRESHOLD,\n          symbolCount: symbols.length\n        });\n        console.warn(`‚ö†Ô∏è Slow scan detected: ${scanDuration}ms (threshold: ${this.SCAN_WARNING_THRESHOLD}ms)`);\n      }\n\n      // Update statistics\n      this.updateScanStats(scanDuration, successCount, symbols.length);\n\n      const result: ScanResult = {\n        symbols: rankedSymbols,\n        top20,\n        scanDuration,\n        timestamp: Date.now(),\n        totalSymbols: symbols.length,\n        successCount,\n        errorCount\n      };\n\n      // Emit scan complete event\n      this.emit('scanComplete', result);\n      \n      console.log(`‚úÖ Hologram scan complete: ${successCount}/${symbols.length} symbols analyzed in ${scanDuration}ms`);\n      console.log(`üéØ Top 20 symbols selected: ${top20.map(h => `${h.symbol}(${h.status})`).join(', ')}`);\n\n      return result;\n    } catch (error) {\n      const scanDuration = Date.now() - startTime;\n      this.updateScanStats(scanDuration, successCount, symbols.length);\n      \n      this.emit('scanError', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: scanDuration,\n        symbolsProcessed: successCount,\n        totalSymbols: symbols.length\n      });\n      \n      throw new Error(`Hologram scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    } finally {\n      this.isScanning = false;\n    }\n  }\n\n  /**\n   * Rank symbols by alignment score in descending order\n   * Priority: A+ > B > CONFLICT > NO_PLAY\n   * Within same status, sort by alignment score\n   * \n   * @param holograms - Array of hologram states\n   * @returns Sorted array with highest alignment first\n   */\n  public rankByAlignment(holograms: HologramState[]): HologramState[] {\n    // Define status priority (lower number = higher priority)\n    const statusPriority: { [key in HologramStatus]: number } = {\n      'A+': 1,\n      'B': 2,\n      'CONFLICT': 3,\n      'NO_PLAY': 4\n    };\n\n    return holograms.sort((a, b) => {\n      // First sort by status priority\n      const statusDiff = statusPriority[a.status] - statusPriority[b.status];\n      if (statusDiff !== 0) {\n        return statusDiff;\n      }\n\n      // Within same status, sort by alignment score (descending)\n      const scoreDiff = b.alignmentScore - a.alignmentScore;\n      if (scoreDiff !== 0) {\n        return scoreDiff;\n      }\n\n      // If alignment scores are equal, sort by RS score (descending)\n      return Math.abs(b.rsScore) - Math.abs(a.rsScore);\n    });\n  }\n\n  /**\n   * Select top 20 symbols for monitoring\n   * Filters for tradeable symbols (A+ and B status)\n   * Falls back to best available if < 20 tradeable symbols\n   * \n   * @param rankedSymbols - Symbols ranked by alignment\n   * @returns Top 20 symbols for monitoring\n   */\n  public selectTop20(rankedSymbols: HologramState[]): HologramState[] {\n    // First, try to get 20 tradeable symbols (A+ and B)\n    const tradeableSymbols = rankedSymbols.filter(h => h.status === 'A+' || h.status === 'B');\n    \n    if (tradeableSymbols.length >= 20) {\n      return tradeableSymbols.slice(0, 20);\n    }\n\n    // If we don't have 20 tradeable symbols, take the best available\n    console.warn(`‚ö†Ô∏è Only ${tradeableSymbols.length} tradeable symbols found, selecting top 20 overall`);\n    return rankedSymbols.slice(0, 20);\n  }\n\n  /**\n   * Fetch top 100 symbols by 24h volume from Bybit\n   * Uses BybitPerpsClient with caching\n   * \n   * @returns Promise with array of symbol names\n   */\n  private async fetchTopSymbols(): Promise<string[]> {\n    try {\n      const symbols = await this.bybitClient.fetchTopSymbols();\n      \n      if (symbols.length === 0) {\n        throw new Error('No symbols returned from exchange');\n      }\n\n      // Ensure we have exactly 100 symbols (or less if exchange returns fewer)\n      return symbols.slice(0, 100);\n    } catch (error) {\n      throw new Error(`Failed to fetch top symbols: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Analyze symbols in parallel with concurrency control\n   * Processes symbols in batches to avoid overwhelming the API\n   * \n   * @param symbols - Array of symbol names to analyze\n   * @returns Promise with array of successful hologram states\n   */\n  private async analyzeSymbolsParallel(symbols: string[]): Promise<HologramState[]> {\n    const results: HologramState[] = [];\n    const errors: string[] = [];\n\n    // Process symbols in batches to control concurrency\n    for (let i = 0; i < symbols.length; i += this.MAX_PARALLEL_REQUESTS) {\n      const batch = symbols.slice(i, i + this.MAX_PARALLEL_REQUESTS);\n      \n      console.log(`üìà Analyzing batch ${Math.floor(i / this.MAX_PARALLEL_REQUESTS) + 1}/${Math.ceil(symbols.length / this.MAX_PARALLEL_REQUESTS)} (${batch.length} symbols)`);\n\n      // Create promises for this batch with timeout\n      const batchPromises = batch.map(async (symbol) => {\n        try {\n          // Add timeout to individual symbol analysis\n          const timeoutPromise = new Promise<never>((_, reject) => {\n            setTimeout(() => reject(new Error(`Analysis timeout for ${symbol}`)), 10000);\n          });\n\n          const analysisPromise = this.hologramEngine.analyze(symbol);\n          const hologram = await Promise.race([analysisPromise, timeoutPromise]);\n          \n          return { success: true, hologram, symbol };\n        } catch (error) {\n          const errorMsg = `${symbol}: ${error instanceof Error ? error.message : 'Unknown error'}`;\n          errors.push(errorMsg);\n          return { success: false, error: errorMsg, symbol };\n        }\n      });\n\n      // Wait for batch to complete\n      const batchResults = await Promise.all(batchPromises);\n\n      // Collect successful results\n      for (const result of batchResults) {\n        if (result.success && 'hologram' in result && result.hologram) {\n          results.push(result.hologram);\n        }\n      }\n\n      // Add small delay between batches to be respectful to API\n      if (i + this.MAX_PARALLEL_REQUESTS < symbols.length) {\n        await this.sleep(100); // 100ms delay between batches\n      }\n    }\n\n    // Log errors if any\n    if (errors.length > 0) {\n      console.warn(`‚ö†Ô∏è ${errors.length} symbols failed analysis:`);\n      errors.slice(0, 5).forEach(error => console.warn(`  - ${error}`));\n      if (errors.length > 5) {\n        console.warn(`  ... and ${errors.length - 5} more`);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Update scan statistics\n   * Tracks performance metrics for monitoring\n   * \n   * @param duration - Scan duration in milliseconds\n   * @param successCount - Number of successful analyses\n   * @param totalCount - Total number of symbols attempted\n   */\n  private updateScanStats(duration: number, successCount: number, totalCount: number): void {\n    this.scanStats.totalScans++;\n    this.scanStats.lastScanDuration = duration;\n    \n    // Update average duration (rolling average)\n    this.scanStats.averageDuration = \n      (this.scanStats.averageDuration * (this.scanStats.totalScans - 1) + duration) / this.scanStats.totalScans;\n    \n    // Update success rate (simple calculation based on current scan)\n    if (totalCount > 0) {\n      this.scanStats.successRate = successCount / totalCount;\n    }\n  }\n\n  /**\n   * Get current scan statistics\n   * @returns Current scan performance statistics\n   */\n  public getScanStats(): ScanStats {\n    return { ...this.scanStats };\n  }\n\n  /**\n   * Check if scanner is currently running\n   * @returns true if scan is in progress\n   */\n  public getIsScanning(): boolean {\n    return this.isScanning;\n  }\n\n  /**\n   * Reset scan statistics\n   * Useful for testing or performance monitoring reset\n   */\n  public resetStats(): void {\n    this.scanStats = {\n      totalScans: 0,\n      averageDuration: 0,\n      lastScanDuration: 0,\n      successRate: 0,\n      slowScans: 0\n    };\n  }\n\n  /**\n   * Get hologram summary for a symbol\n   * Convenience method for logging and debugging\n   * \n   * @param symbol - Symbol to analyze\n   * @returns Promise with hologram summary string\n   */\n  public async getSymbolSummary(symbol: string): Promise<string> {\n    try {\n      const hologram = await this.hologramEngine.analyze(symbol);\n      return HologramEngine.getHologramSummary(hologram);\n    } catch (error) {\n      return `‚ùå ${symbol}: Analysis failed - ${error instanceof Error ? error.message : 'Unknown error'}`;\n    }\n  }\n\n  /**\n   * Sleep for specified milliseconds\n   * @param ms - Milliseconds to sleep\n   * @returns Promise that resolves after delay\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Cleanup resources\n   * Should be called when scanner is no longer needed\n   */\n  public cleanup(): void {\n    this.removeAllListeners();\n    this.hologramEngine.clearCache();\n  }\n}"],"version":3}