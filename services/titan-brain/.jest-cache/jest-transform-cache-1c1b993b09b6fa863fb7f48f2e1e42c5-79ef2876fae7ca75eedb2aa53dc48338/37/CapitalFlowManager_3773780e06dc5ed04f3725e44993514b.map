{"file":"/Users/ivan/Code/trading/titan/services/titan-brain/src/engine/CapitalFlowManager.ts","mappings":"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","names":[],"sources":["/Users/ivan/Code/trading/titan/services/titan-brain/src/engine/CapitalFlowManager.ts"],"sourcesContent":["/**\n * CapitalFlowManager - Manages profit sweeping from futures to spot wallet\n * Implements ratchet mechanism to lock in profits\n * \n * Requirements: 4.1, 4.2, 4.3, 4.4, 4.5\n */\n\nimport {\n  SweepDecision,\n  SweepResult,\n  TreasuryStatus,\n  TreasuryOperation,\n  CapitalFlowConfig,\n} from '../types/index.js';\nimport { DatabaseManager } from '../db/DatabaseManager.js';\n\n/**\n * Exchange API interface for wallet operations\n * This interface should be implemented by the actual exchange adapter\n */\nexport interface ExchangeWalletAPI {\n  /** Get futures wallet balance */\n  getFuturesBalance(): Promise<number>;\n  /** Get spot wallet balance */\n  getSpotBalance(): Promise<number>;\n  /** Transfer funds from futures to spot wallet */\n  transferToSpot(amount: number): Promise<{ success: boolean; transactionId?: string; error?: string }>;\n}\n\n/**\n * Interface for sweep notification callback\n */\nexport interface SweepNotifier {\n  sendSweepNotification(\n    amount: number,\n    fromWallet: string,\n    toWallet: string,\n    reason: string,\n    newBalance: number\n  ): Promise<void>;\n}\n\n/**\n * CapitalFlowManager manages profit sweeping from the risky futures wallet\n * to the safe spot wallet using a ratchet mechanism.\n */\nexport class CapitalFlowManager {\n  private readonly config: CapitalFlowConfig;\n  private readonly db: DatabaseManager | null;\n  private readonly exchangeAPI: ExchangeWalletAPI | null;\n  \n  /** Cached high watermark value */\n  private highWatermark: number = 0;\n  /** Cached total swept amount */\n  private totalSwept: number = 0;\n  /** Target allocation for futures wallet (set externally) */\n  private targetAllocation: number = 0;\n  /** Sweep notifier */\n  private sweepNotifier: SweepNotifier | null = null;\n\n  constructor(\n    config: CapitalFlowConfig,\n    db?: DatabaseManager,\n    exchangeAPI?: ExchangeWalletAPI\n  ) {\n    this.config = config;\n    this.db = db ?? null;\n    this.exchangeAPI = exchangeAPI ?? null;\n  }\n\n  /**\n   * Set the sweep notifier\n   */\n  setSweepNotifier(notifier: SweepNotifier): void {\n    this.sweepNotifier = notifier;\n  }\n\n  /**\n   * Initialize the manager by loading state from database\n   */\n  async initialize(): Promise<void> {\n    if (this.db) {\n      await this.loadHighWatermark();\n      await this.loadTotalSwept();\n    }\n  }\n\n\n  /**\n   * Load high watermark from database\n   */\n  private async loadHighWatermark(): Promise<void> {\n    if (!this.db) return;\n\n    const result = await this.db.query<{ value: string }>(\n      `SELECT value FROM high_watermark ORDER BY updated_at DESC LIMIT 1`\n    );\n\n    if (result.rows.length > 0) {\n      this.highWatermark = parseFloat(result.rows[0].value);\n    }\n  }\n\n  /**\n   * Load total swept amount from database\n   */\n  private async loadTotalSwept(): Promise<void> {\n    if (!this.db) return;\n\n    const result = await this.db.query<{ total: string }>(\n      `SELECT COALESCE(SUM(amount), 0) as total \n       FROM treasury_operations \n       WHERE operation_type = 'SWEEP' AND to_wallet = 'SPOT'`\n    );\n\n    if (result.rows.length > 0) {\n      this.totalSwept = parseFloat(result.rows[0].total);\n    }\n  }\n\n  /**\n   * Set the target allocation for futures wallet\n   * This is typically set by the Brain based on current equity and allocation\n   * \n   * @param amount - Target allocation in USD\n   */\n  setTargetAllocation(amount: number): void {\n    this.targetAllocation = Math.max(0, amount);\n  }\n\n  /**\n   * Get the current high watermark\n   * \n   * @returns High watermark value in USD\n   */\n  getHighWatermark(): number {\n    return this.highWatermark;\n  }\n\n  /**\n   * Set high watermark value (for state recovery)\n   * \n   * @param value - High watermark value in USD\n   */\n  async setHighWatermark(value: number): Promise<void> {\n    if (value <= 0) {\n      console.warn(`Invalid high watermark value: ${value}`);\n      return;\n    }\n\n    this.highWatermark = value;\n\n    // Persist to database\n    if (this.db) {\n      await this.db.query(\n        `INSERT INTO high_watermark (value, updated_at) VALUES ($1, $2)`,\n        [value, Date.now()]\n      );\n    }\n\n    console.log(`High watermark set to $${value}`);\n  }\n\n  /**\n   * Update the high watermark if equity exceeds current watermark\n   * Requirement 4.1: Track High Watermark for Futures Wallet balance\n   * \n   * Property 10: High Watermark Monotonicity - watermark should never decrease\n   * \n   * @param equity - Current equity in USD\n   * @returns true if watermark was updated\n   */\n  async updateHighWatermark(equity: number): Promise<boolean> {\n    // Only update if new equity exceeds current watermark\n    if (equity <= this.highWatermark) {\n      return false;\n    }\n\n    const previousWatermark = this.highWatermark;\n    this.highWatermark = equity;\n\n    // Persist to database\n    if (this.db) {\n      await this.db.query(\n        `INSERT INTO high_watermark (value, updated_at) VALUES ($1, $2)`,\n        [equity, Date.now()]\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if sweep conditions are met\n   * Requirement 4.2: Sweep when Futures Wallet exceeds Target Allocation by 20%\n   * \n   * @returns SweepDecision with sweep details\n   */\n  async checkSweepConditions(): Promise<SweepDecision> {\n    // Get current futures balance\n    const futuresBalance = await this.getFuturesBalance();\n    \n    // Calculate threshold (target allocation * sweep threshold)\n    const sweepTriggerLevel = this.targetAllocation * this.config.sweepThreshold;\n    \n    // Check if we exceed the threshold\n    if (futuresBalance <= sweepTriggerLevel) {\n      return {\n        shouldSweep: false,\n        amount: 0,\n        reason: 'Futures balance does not exceed sweep threshold',\n        futuresBalance,\n        targetAllocation: this.targetAllocation,\n      };\n    }\n\n    // Requirement 4.3: Calculate excess profit\n    const excessAmount = futuresBalance - sweepTriggerLevel;\n    \n    // Requirement 4.5: Ensure reserve limit is maintained\n    // Property 5: Reserve Limit Protection - remaining balance >= reserveLimit\n    const maxSweepable = futuresBalance - this.config.reserveLimit;\n    \n    if (maxSweepable <= 0) {\n      return {\n        shouldSweep: false,\n        amount: 0,\n        reason: `Cannot sweep: would violate reserve limit of $${this.config.reserveLimit}`,\n        futuresBalance,\n        targetAllocation: this.targetAllocation,\n      };\n    }\n\n    // Sweep amount is the minimum of excess and max sweepable\n    const sweepAmount = Math.min(excessAmount, maxSweepable);\n    \n    if (sweepAmount <= 0) {\n      return {\n        shouldSweep: false,\n        amount: 0,\n        reason: 'No excess to sweep after reserve limit',\n        futuresBalance,\n        targetAllocation: this.targetAllocation,\n      };\n    }\n\n    return {\n      shouldSweep: true,\n      amount: sweepAmount,\n      reason: `Excess of $${sweepAmount.toFixed(2)} detected (${((futuresBalance / this.targetAllocation - 1) * 100).toFixed(1)}% over target)`,\n      futuresBalance,\n      targetAllocation: this.targetAllocation,\n    };\n  }\n\n\n  /**\n   * Execute a profit sweep from futures to spot wallet\n   * Requirement 4.4: Transfer excess USDT to Spot Wallet\n   * Requirement 4.8: Retry up to 3 times with exponential backoff\n   * \n   * Property 4: Sweep Monotonicity - totalSwept should only increase\n   * \n   * @param amount - Amount to sweep in USD\n   * @returns SweepResult with transaction details\n   */\n  async executeSweep(amount: number): Promise<SweepResult> {\n    const timestamp = Date.now();\n\n    // Validate amount\n    if (amount <= 0) {\n      return {\n        success: false,\n        amount: 0,\n        error: 'Invalid sweep amount: must be positive',\n        timestamp,\n      };\n    }\n\n    // Check reserve limit before sweep\n    const futuresBalance = await this.getFuturesBalance();\n    const remainingAfterSweep = futuresBalance - amount;\n    \n    if (remainingAfterSweep < this.config.reserveLimit) {\n      return {\n        success: false,\n        amount: 0,\n        error: `Sweep would violate reserve limit: $${remainingAfterSweep.toFixed(2)} < $${this.config.reserveLimit}`,\n        timestamp,\n      };\n    }\n\n    // Execute transfer with retry logic\n    let lastError: string | undefined;\n    \n    for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        const result = await this.executeTransfer(amount);\n        \n        if (result.success) {\n          // Update total swept (monotonically increasing)\n          this.totalSwept += amount;\n          \n          // Log the operation\n          await this.logTreasuryOperation({\n            timestamp,\n            operationType: 'SWEEP',\n            amount,\n            fromWallet: 'FUTURES',\n            toWallet: 'SPOT',\n            reason: `Automated profit sweep (attempt ${attempt})`,\n            highWatermark: this.highWatermark,\n          });\n\n          // Send sweep notification\n          if (this.sweepNotifier) {\n            try {\n              const newBalance = await this.getFuturesBalance();\n              await this.sweepNotifier.sendSweepNotification(\n                amount,\n                'FUTURES',\n                'SPOT',\n                `Automated profit sweep (attempt ${attempt})`,\n                newBalance\n              );\n            } catch (error) {\n              console.error('Failed to send sweep notification:', error);\n            }\n          }\n\n          return {\n            success: true,\n            amount,\n            transactionId: result.transactionId,\n            timestamp,\n          };\n        }\n        \n        lastError = result.error;\n      } catch (error) {\n        lastError = error instanceof Error ? error.message : 'Unknown error';\n      }\n\n      // Exponential backoff before retry\n      if (attempt < this.config.maxRetries) {\n        const delay = this.config.retryBaseDelay * Math.pow(2, attempt - 1);\n        await this.sleep(delay);\n      }\n    }\n\n    return {\n      success: false,\n      amount: 0,\n      error: `Sweep failed after ${this.config.maxRetries} attempts: ${lastError}`,\n      timestamp,\n    };\n  }\n\n  /**\n   * Execute the actual transfer via exchange API\n   */\n  private async executeTransfer(\n    amount: number\n  ): Promise<{ success: boolean; transactionId?: string; error?: string }> {\n    if (!this.exchangeAPI) {\n      // Mock success for testing without exchange API\n      return {\n        success: true,\n        transactionId: `mock-${Date.now()}`,\n      };\n    }\n\n    return this.exchangeAPI.transferToSpot(amount);\n  }\n\n  /**\n   * Get current treasury status\n   * Requirement 8.1-8.7: Treasury management visibility\n   * \n   * @returns TreasuryStatus with all wallet balances and metrics\n   */\n  async getTreasuryStatus(): Promise<TreasuryStatus> {\n    const futuresWallet = await this.getFuturesBalance();\n    const spotWallet = await this.getSpotBalance();\n\n    return {\n      futuresWallet,\n      spotWallet,\n      totalSwept: this.totalSwept,\n      highWatermark: this.highWatermark,\n      lockedProfit: this.totalSwept, // Locked profit equals total swept\n      riskCapital: futuresWallet, // Risk capital is futures balance\n    };\n  }\n\n  /**\n   * Get futures wallet balance\n   */\n  private async getFuturesBalance(): Promise<number> {\n    if (!this.exchangeAPI) {\n      // Return 0 if no exchange API configured\n      return 0;\n    }\n    return this.exchangeAPI.getFuturesBalance();\n  }\n\n  /**\n   * Get spot wallet balance\n   */\n  private async getSpotBalance(): Promise<number> {\n    if (!this.exchangeAPI) {\n      // Return 0 if no exchange API configured\n      return 0;\n    }\n    return this.exchangeAPI.getSpotBalance();\n  }\n\n\n  /**\n   * Log a treasury operation to the database\n   * Requirement 4.7: Log all sweep transactions\n   */\n  private async logTreasuryOperation(operation: TreasuryOperation): Promise<void> {\n    if (!this.db) return;\n\n    await this.db.query(\n      `INSERT INTO treasury_operations \n       (timestamp, operation_type, amount, from_wallet, to_wallet, reason, high_watermark)\n       VALUES ($1, $2, $3, $4, $5, $6, $7)`,\n      [\n        operation.timestamp,\n        operation.operationType,\n        operation.amount,\n        operation.fromWallet,\n        operation.toWallet,\n        operation.reason ?? null,\n        operation.highWatermark,\n      ]\n    );\n  }\n\n  /**\n   * Get sweep history from database\n   * \n   * @param limit - Maximum number of records to return\n   * @returns Array of treasury operations\n   */\n  async getSweepHistory(limit: number = 100): Promise<TreasuryOperation[]> {\n    if (!this.db) return [];\n\n    const result = await this.db.query<{\n      id: number;\n      timestamp: string;\n      operation_type: string;\n      amount: string;\n      from_wallet: string;\n      to_wallet: string;\n      reason: string | null;\n      high_watermark: string;\n    }>(\n      `SELECT id, timestamp, operation_type, amount, from_wallet, to_wallet, reason, high_watermark\n       FROM treasury_operations\n       WHERE operation_type = 'SWEEP'\n       ORDER BY timestamp DESC\n       LIMIT $1`,\n      [limit]\n    );\n\n    return result.rows.map((row) => ({\n      id: row.id,\n      timestamp: parseInt(row.timestamp, 10),\n      operationType: row.operation_type as 'SWEEP' | 'MANUAL_TRANSFER',\n      amount: parseFloat(row.amount),\n      fromWallet: row.from_wallet as 'FUTURES' | 'SPOT',\n      toWallet: row.to_wallet as 'FUTURES' | 'SPOT',\n      reason: row.reason ?? undefined,\n      highWatermark: parseFloat(row.high_watermark),\n    }));\n  }\n\n  /**\n   * Calculate the next sweep trigger level\n   * \n   * @returns The futures balance level that would trigger a sweep\n   */\n  getNextSweepTriggerLevel(): number {\n    return this.targetAllocation * this.config.sweepThreshold;\n  }\n\n  /**\n   * Get the total amount swept since inception\n   * \n   * @returns Total swept amount in USD\n   */\n  getTotalSwept(): number {\n    return this.totalSwept;\n  }\n\n  /**\n   * Get the current target allocation\n   * \n   * @returns Target allocation in USD\n   */\n  getTargetAllocation(): number {\n    return this.targetAllocation;\n  }\n\n  /**\n   * Get the reserve limit\n   * \n   * @returns Reserve limit in USD\n   */\n  getReserveLimit(): number {\n    return this.config.reserveLimit;\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): CapitalFlowConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Sleep utility for retry delays\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Check if a sweep should be triggered based on equity increase\n   * Requirement 4.6: Sweep after trades that increase equity by > 10%\n   * \n   * @param previousEquity - Equity before the trade\n   * @param currentEquity - Equity after the trade\n   * @returns true if equity increased by more than 10%\n   */\n  shouldTriggerSweepOnEquityIncrease(\n    previousEquity: number,\n    currentEquity: number\n  ): boolean {\n    if (previousEquity <= 0) return false;\n    \n    const percentIncrease = (currentEquity - previousEquity) / previousEquity;\n    return percentIncrease > 0.10; // 10% threshold\n  }\n\n  /**\n   * Perform a full sweep check and execution if conditions are met\n   * Convenience method that combines checkSweepConditions and executeSweep\n   * \n   * @returns SweepResult if sweep was attempted, null if conditions not met\n   */\n  async performSweepIfNeeded(): Promise<SweepResult | null> {\n    const decision = await this.checkSweepConditions();\n    \n    if (!decision.shouldSweep) {\n      return null;\n    }\n\n    return this.executeSweep(decision.amount);\n  }\n}\n"],"version":3}