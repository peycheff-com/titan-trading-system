d27c9d9eadf8a91a7f77fe747c1bb00c
"use strict";
/**
 * Property-Based Tests for PerformanceTracker
 *
 * Tests universal properties that should hold across all inputs
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const fc = __importStar(require("fast-check"));
const PerformanceTracker_1 = require("../../src/engine/PerformanceTracker");
// Test configuration
const testConfig = {
    windowDays: 7,
    minTradeCount: 10,
    malusThreshold: 0,
    bonusThreshold: 2.0,
    malusMultiplier: 0.5,
    bonusMultiplier: 1.2
};
describe('PerformanceTracker Property Tests', () => {
    let tracker;
    beforeEach(() => {
        tracker = new PerformanceTracker_1.PerformanceTracker(testConfig);
    });
    describe('Property 3: Performance Modifier Bounds', () => {
        /**
         * **Validates: Requirements 2.3, 2.4**
         *
         * For any Sharpe ratio value, the performance modifier should always be within bounds:
         * - Minimum: malusMultiplier (0.5)
         * - Maximum: bonusMultiplier (1.2)
         * - Never outside the range [0.5, 1.2]
         */
        it('should always return modifier within bounds [0.5, 1.2]', () => {
            fc.assert(fc.property(fc.float({ min: Math.fround(-10), max: Math.fround(10), noNaN: true }), (sharpeRatio) => {
                const modifier = tracker.calculateModifier(sharpeRatio);
                // Property: Modifier must be within bounds
                expect(modifier).toBeGreaterThanOrEqual(testConfig.malusMultiplier);
                expect(modifier).toBeLessThanOrEqual(testConfig.bonusMultiplier);
                // Property: Modifier must be one of three values
                const validModifiers = [
                    testConfig.malusMultiplier, // 0.5
                    1.0, // Normal
                    testConfig.bonusMultiplier // 1.2
                ];
                expect(validModifiers).toContain(modifier);
            }), { numRuns: 1000 });
        });
        /**
         * **Validates: Requirements 2.3**
         *
         * For any Sharpe ratio below the malus threshold (0),
         * the modifier should always be the malus multiplier (0.5)
         */
        it('should apply malus multiplier for all negative Sharpe ratios', () => {
            fc.assert(fc.property(fc.float({ min: Math.fround(-100), max: Math.fround(-0.001), noNaN: true }), (negativeSharpe) => {
                const modifier = tracker.calculateModifier(negativeSharpe);
                // Property: All negative Sharpe ratios get malus penalty
                expect(modifier).toBe(testConfig.malusMultiplier);
            }), { numRuns: 500 });
        });
        /**
         * **Validates: Requirements 2.4**
         *
         * For any Sharpe ratio above the bonus threshold (2.0),
         * the modifier should always be the bonus multiplier (1.2)
         */
        it('should apply bonus multiplier for all high Sharpe ratios', () => {
            fc.assert(fc.property(fc.float({ min: Math.fround(2.001), max: Math.fround(100), noNaN: true }), (highSharpe) => {
                const modifier = tracker.calculateModifier(highSharpe);
                // Property: All high Sharpe ratios get bonus multiplier
                expect(modifier).toBe(testConfig.bonusMultiplier);
            }), { numRuns: 500 });
        });
        /**
         * **Validates: Requirements 2.3, 2.4**
         *
         * For any Sharpe ratio in the normal range [0, 2.0],
         * the modifier should always be 1.0 (no modification)
         */
        it('should return 1.0 for normal Sharpe ratios', () => {
            fc.assert(fc.property(fc.float({ min: Math.fround(0), max: Math.fround(2.0), noNaN: true }), (normalSharpe) => {
                const modifier = tracker.calculateModifier(normalSharpe);
                // Property: Normal Sharpe ratios get no modification
                expect(modifier).toBe(1.0);
            }), { numRuns: 500 });
        });
        /**
         * **Validates: Requirements 2.3, 2.4**
         *
         * The modifier function should be monotonic in the sense that:
         * - All values below threshold get same (minimum) modifier
         * - All values above threshold get same (maximum) modifier
         * - All values in between get same (normal) modifier
         */
        it('should be piecewise constant with correct thresholds', () => {
            fc.assert(fc.property(fc.tuple(fc.float({ min: Math.fround(-10), max: Math.fround(10), noNaN: true }), fc.float({ min: Math.fround(-10), max: Math.fround(10), noNaN: true })), ([sharpe1, sharpe2]) => {
                const modifier1 = tracker.calculateModifier(sharpe1);
                const modifier2 = tracker.calculateModifier(sharpe2);
                // Property: Same category should give same modifier
                const category1 = sharpe1 < 0 ? 'malus' : sharpe1 > 2.0 ? 'bonus' : 'normal';
                const category2 = sharpe2 < 0 ? 'malus' : sharpe2 > 2.0 ? 'bonus' : 'normal';
                if (category1 === category2) {
                    expect(modifier1).toBe(modifier2);
                }
            }), { numRuns: 1000 });
        });
        /**
         * **Validates: Requirements 2.3, 2.4**
         *
         * Test boundary conditions at exactly the threshold values
         */
        it('should handle boundary conditions correctly', () => {
            // Exactly at malus threshold (0)
            expect(tracker.calculateModifier(0)).toBe(1.0);
            expect(tracker.calculateModifier(-0.0)).toBe(1.0);
            // Just below malus threshold
            expect(tracker.calculateModifier(-0.000001)).toBe(testConfig.malusMultiplier);
            // Exactly at bonus threshold (2.0)
            expect(tracker.calculateModifier(2.0)).toBe(1.0);
            // Just above bonus threshold
            expect(tracker.calculateModifier(2.000001)).toBe(testConfig.bonusMultiplier);
        });
        /**
         * **Validates: Requirements 2.3, 2.4**
         *
         * Test extreme values to ensure no overflow or underflow
         */
        it('should handle extreme Sharpe ratio values', () => {
            const extremeValues = [
                -Infinity, -1000, -100, -10,
                10, 100, 1000, Infinity
            ];
            extremeValues.forEach(sharpe => {
                if (isFinite(sharpe)) {
                    const modifier = tracker.calculateModifier(sharpe);
                    // Should still be within bounds
                    expect(modifier).toBeGreaterThanOrEqual(testConfig.malusMultiplier);
                    expect(modifier).toBeLessThanOrEqual(testConfig.bonusMultiplier);
                    expect(isFinite(modifier)).toBe(true);
                }
            });
        });
    });
    describe('Sharpe Ratio Calculation Properties', () => {
        /**
         * Property: Sharpe ratio should be 0 for insufficient data
         */
        it('should return 0 for insufficient PnL data', () => {
            fc.assert(fc.property(fc.array(fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }), { maxLength: 1 }), (pnlValues) => {
                const sharpe = tracker.calculateSharpeRatio(pnlValues);
                expect(sharpe).toBe(0);
            }), { numRuns: 100 });
        });
        /**
         * Property: Sharpe ratio should be finite for valid data
         */
        it('should return finite Sharpe ratio for valid PnL data', () => {
            fc.assert(fc.property(fc.array(fc.float({ min: Math.fround(-1000), max: Math.fround(1000), noNaN: true }), { minLength: 2, maxLength: 100 }), (pnlValues) => {
                // Ensure we have some variation to avoid zero std dev
                if (pnlValues.length >= 2) {
                    pnlValues[0] = 100; // Force some variation
                    pnlValues[1] = -50;
                }
                const sharpe = tracker.calculateSharpeRatio(pnlValues);
                expect(isFinite(sharpe)).toBe(true);
            }), { numRuns: 500 });
        });
        /**
         * Property: Sharpe ratio should handle zero standard deviation
         */
        it('should handle zero standard deviation correctly', () => {
            // All positive returns
            const allPositive = [100, 100, 100, 100];
            const sharpePositive = tracker.calculateSharpeRatio(allPositive);
            expect(sharpePositive).toBe(3.0);
            // All negative returns
            const allNegative = [-100, -100, -100, -100];
            const sharpeNegative = tracker.calculateSharpeRatio(allNegative);
            expect(sharpeNegative).toBe(-3.0);
            // All zero returns
            const allZero = [0, 0, 0, 0];
            const sharpeZero = tracker.calculateSharpeRatio(allZero);
            expect(sharpeZero).toBe(0);
        });
    });
    describe('Configuration Validation Properties', () => {
        /**
         * Property: Configuration values should be used correctly
         */
        it('should use configuration values correctly', () => {
            const customConfig = {
                windowDays: 14,
                minTradeCount: 20,
                malusThreshold: -0.5,
                bonusThreshold: 1.5,
                malusMultiplier: 0.3,
                bonusMultiplier: 1.5
            };
            const customTracker = new PerformanceTracker_1.PerformanceTracker(customConfig);
            // Test custom thresholds
            expect(customTracker.calculateModifier(-0.6)).toBe(0.3); // Below custom malus threshold
            expect(customTracker.calculateModifier(-0.4)).toBe(1.0); // Above custom malus threshold
            expect(customTracker.calculateModifier(1.4)).toBe(1.0); // Below custom bonus threshold
            expect(customTracker.calculateModifier(1.6)).toBe(1.5); // Above custom bonus threshold
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3Byb3BlcnR5L1BlcmZvcm1hbmNlVHJhY2tlci5wcm9wZXJ0eS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILCtDQUFpQztBQUNqQyw0RUFBeUU7QUFHekUscUJBQXFCO0FBQ3JCLE1BQU0sVUFBVSxHQUE2QjtJQUMzQyxVQUFVLEVBQUUsQ0FBQztJQUNiLGFBQWEsRUFBRSxFQUFFO0lBQ2pCLGNBQWMsRUFBRSxDQUFDO0lBQ2pCLGNBQWMsRUFBRSxHQUFHO0lBQ25CLGVBQWUsRUFBRSxHQUFHO0lBQ3BCLGVBQWUsRUFBRSxHQUFHO0NBQ3JCLENBQUM7QUFFRixRQUFRLENBQUMsbUNBQW1DLEVBQUUsR0FBRyxFQUFFO0lBQ2pELElBQUksT0FBMkIsQ0FBQztJQUVoQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsT0FBTyxHQUFHLElBQUksdUNBQWtCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0MsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMseUNBQXlDLEVBQUUsR0FBRyxFQUFFO1FBQ3ZEOzs7Ozs7O1dBT0c7UUFDSCxFQUFFLENBQUMsd0RBQXdELEVBQUUsR0FBRyxFQUFFO1lBQ2hFLEVBQUUsQ0FBQyxNQUFNLENBQ1AsRUFBRSxDQUFDLFFBQVEsQ0FDVCxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFDdEUsQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDZCxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBRXhELDJDQUEy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QUFHO2FBQ3JCLENBQUM7WUFFRixNQUFNLGFBQWEsR0FBRyxJQUFJLHVDQUFrQixDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRTNELHlCQUF5QjtZQUN6QixNQUFNLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBRSwrQkFBK0I7WUFDekYsTUFBTSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUUsK0JBQStCO1lBQ3pGLE1BQU0sQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBRywrQkFBK0I7WUFDekYsTUFBTSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFHLCtCQUErQjtRQUMzRixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3Byb3BlcnR5L1BlcmZvcm1hbmNlVHJhY2tlci5wcm9wZXJ0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJvcGVydHktQmFzZWQgVGVzdHMgZm9yIFBlcmZvcm1hbmNlVHJhY2tlclxuICogXG4gKiBUZXN0cyB1bml2ZXJzYWwgcHJvcGVydGllcyB0aGF0IHNob3VsZCBob2xkIGFjcm9zcyBhbGwgaW5wdXRzXG4gKi9cblxuaW1wb3J0ICogYXMgZmMgZnJvbSAnZmFzdC1jaGVjayc7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZVRyYWNrZXIgfSBmcm9tICcuLi8uLi9zcmMvZW5naW5lL1BlcmZvcm1hbmNlVHJhY2tlcic7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZVRyYWNrZXJDb25maWcgfSBmcm9tICcuLi8uLi9zcmMvdHlwZXMvaW5kZXgnO1xuXG4vLyBUZXN0IGNvbmZpZ3VyYXRpb25cbmNvbnN0IHRlc3RDb25maWc6IFBlcmZvcm1hbmNlVHJhY2tlckNvbmZpZyA9IHtcbiAgd2luZG93RGF5czogNyxcbiAgbWluVHJhZGVDb3VudDogMTAsXG4gIG1hbHVzVGhyZXNob2xkOiAwLFxuICBib251c1RocmVzaG9sZDogMi4wLFxuICBtYWx1c011bHRpcGxpZXI6IDAuNSxcbiAgYm9udXNNdWx0aXBsaWVyOiAxLjJcbn07XG5cbmRlc2NyaWJlKCdQZXJmb3JtYW5jZVRyYWNrZXIgUHJvcGVydHkgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCB0cmFja2VyOiBQZXJmb3JtYW5jZVRyYWNrZXI7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgdHJhY2tlciA9IG5ldyBQZXJmb3JtYW5jZVRyYWNrZXIodGVzdENvbmZpZyk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9wZXJ0eSAzOiBQZXJmb3JtYW5jZSBNb2RpZmllciBCb3VuZHMnLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAyLjMsIDIuNCoqXG4gICAgICogXG4gICAgICogRm9yIGFueSBTaGFycGUgcmF0aW8gdmFsdWUsIHRoZSBwZXJmb3JtYW5jZSBtb2RpZmllciBzaG91bGQgYWx3YXlzIGJlIHdpdGhpbiBib3VuZHM6XG4gICAgICogLSBNaW5pbXVtOiBtYWx1c011bHRpcGxpZXIgKDAuNSlcbiAgICAgKiAtIE1heGltdW06IGJvbnVzTXVsdGlwbGllciAoMS4yKVxuICAgICAqIC0gTmV2ZXIgb3V0c2lkZSB0aGUgcmFuZ2UgWzAuNSwgMS4yXVxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgYWx3YXlzIHJldHVybiBtb2RpZmllciB3aXRoaW4gYm91bmRzIFswLjUsIDEuMl0nLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgtMTApLCBtYXg6IE1hdGguZnJvdW5kKDEwKSwgbm9OYU46IHRydWUgfSksXG4gICAgICAgICAgKHNoYXJwZVJhdGlvKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllciA9IHRyYWNrZXIuY2FsY3VsYXRlTW9kaWZpZXIoc2hhcnBlUmF0aW8pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogTW9kaWZpZXIgbXVzdCBiZSB3aXRoaW4gYm91bmRzXG4gICAgICAgICAgICBleHBlY3QobW9kaWZpZXIpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwodGVzdENvbmZpZy5tYWx1c011bHRpcGxpZXIpO1xuICAgICAgICAgICAgZXhwZWN0KG1vZGlmaWVyKS50b0JlTGVzc1RoYW5PckVxdWFsKHRlc3RDb25maWcuYm9udXNNdWx0aXBsaWVyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IE1vZGlmaWVyIG11c3QgYmUgb25lIG9mIHRocmVlIHZhbHVlc1xuICAgICAgICAgICAgY29uc3QgdmFsaWRNb2RpZmllcnMgPSBbXG4gICAgICAgICAgICAgIHRlc3RDb25maWcubWFsdXNNdWx0aXBsaWVyLCAgLy8gMC41XG4gICAgICAgICAgICAgIDEuMCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsXG4gICAgICAgICAgICAgIHRlc3RDb25maWcuYm9udXNNdWx0aXBsaWVyICAgLy8gMS4yXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZXhwZWN0KHZhbGlkTW9kaWZpZXJzKS50b0NvbnRhaW4obW9kaWZpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiAqKlZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDIuMyoqXG4gICAgICogXG4gICAgICogRm9yIGFueSBTaGFycGUgcmF0aW8gYmVsb3cgdGhlIG1hbHVzIHRocmVzaG9sZCAoMCksIFxuICAgICAqIHRoZSBtb2RpZmllciBzaG91bGQgYWx3YXlzIGJlIHRoZSBtYWx1cyBtdWx0aXBsaWVyICgwLjUpXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBhcHBseSBtYWx1cyBtdWx0aXBsaWVyIGZvciBhbGwgbmVnYXRpdmUgU2hhcnBlIHJhdGlvcycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKC0xMDApLCBtYXg6IE1hdGguZnJvdW5kKC0wLjAwMSksIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgIChuZWdhdGl2ZVNoYXJwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXIgPSB0cmFja2VyLmNhbGN1bGF0ZU1vZGlmaWVyKG5lZ2F0aXZlU2hhcnBlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IEFsbCBuZWdhdGl2ZSBTaGFycGUgcmF0aW9zIGdldCBtYWx1cyBwZW5hbHR5XG4gICAgICAgICAgICBleHBlY3QobW9kaWZpZXIpLnRvQmUodGVzdENvbmZpZy5tYWx1c011bHRpcGxpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiA1MDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMi40KipcbiAgICAgKiBcbiAgICAgKiBGb3IgYW55IFNoYXJwZSByYXRpbyBhYm92ZSB0aGUgYm9udXMgdGhyZXNob2xkICgyLjApLFxuICAgICAqIHRoZSBtb2RpZmllciBzaG91bGQgYWx3YXlzIGJlIHRoZSBib251cyBtdWx0aXBsaWVyICgxLjIpXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBhcHBseSBib251cyBtdWx0aXBsaWVyIGZvciBhbGwgaGlnaCBTaGFycGUgcmF0aW9zJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5mbG9hdCh7IG1pbjogTWF0aC5mcm91bmQoMi4wMDEpLCBtYXg6IE1hdGguZnJvdW5kKDEwMCksIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgIChoaWdoU2hhcnBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllciA9IHRyYWNrZXIuY2FsY3VsYXRlTW9kaWZpZXIoaGlnaFNoYXJwZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBBbGwgaGlnaCBTaGFycGUgcmF0aW9zIGdldCBib251cyBtdWx0aXBsaWVyXG4gICAgICAgICAgICBleHBlY3QobW9kaWZpZXIpLnRvQmUodGVzdENvbmZpZy5ib251c011bHRpcGxpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiA1MDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgMi4zLCAyLjQqKlxuICAgICAqIFxuICAgICAqIEZvciBhbnkgU2hhcnBlIHJhdGlvIGluIHRoZSBub3JtYWwgcmFuZ2UgWzAsIDIuMF0sXG4gICAgICogdGhlIG1vZGlmaWVyIHNob3VsZCBhbHdheXMgYmUgMS4wIChubyBtb2RpZmljYXRpb24pXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gMS4wIGZvciBub3JtYWwgU2hhcnBlIHJhdGlvcycsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKDApLCBtYXg6IE1hdGguZnJvdW5kKDIuMCksIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgIChub3JtYWxTaGFycGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyID0gdHJhY2tlci5jYWxjdWxhdGVNb2RpZmllcihub3JtYWxTaGFycGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogTm9ybWFsIFNoYXJwZSByYXRpb3MgZ2V0IG5vIG1vZGlmaWNhdGlvblxuICAgICAgICAgICAgZXhwZWN0KG1vZGlmaWVyKS50b0JlKDEuMCk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDUwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAyLjMsIDIuNCoqXG4gICAgICogXG4gICAgICogVGhlIG1vZGlmaWVyIGZ1bmN0aW9uIHNob3VsZCBiZSBtb25vdG9uaWMgaW4gdGhlIHNlbnNlIHRoYXQ6XG4gICAgICogLSBBbGwgdmFsdWVzIGJlbG93IHRocmVzaG9sZCBnZXQgc2FtZSAobWluaW11bSkgbW9kaWZpZXJcbiAgICAgKiAtIEFsbCB2YWx1ZXMgYWJvdmUgdGhyZXNob2xkIGdldCBzYW1lIChtYXhpbXVtKSBtb2RpZmllclxuICAgICAqIC0gQWxsIHZhbHVlcyBpbiBiZXR3ZWVuIGdldCBzYW1lIChub3JtYWwpIG1vZGlmaWVyXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBiZSBwaWVjZXdpc2UgY29uc3RhbnQgd2l0aCBjb3JyZWN0IHRocmVzaG9sZHMnLCAoKSA9PiB7XG4gICAgICBmYy5hc3NlcnQoXG4gICAgICAgIGZjLnByb3BlcnR5KFxuICAgICAgICAgIGZjLnR1cGxlKFxuICAgICAgICAgICAgZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKC0xMCksIG1heDogTWF0aC5mcm91bmQoMTApLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgtMTApLCBtYXg6IE1hdGguZnJvdW5kKDEwKSwgbm9OYU46IHRydWUgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIChbc2hhcnBlMSwgc2hhcnBlMl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyMSA9IHRyYWNrZXIuY2FsY3VsYXRlTW9kaWZpZXIoc2hhcnBlMSk7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllcjIgPSB0cmFja2VyLmNhbGN1bGF0ZU1vZGlmaWVyKHNoYXJwZTIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogU2FtZSBjYXRlZ29yeSBzaG91bGQgZ2l2ZSBzYW1lIG1vZGlmaWVyXG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeTEgPSBzaGFycGUxIDwgMCA/ICdtYWx1cycgOiBzaGFycGUxID4gMi4wID8gJ2JvbnVzJyA6ICdub3JtYWwnO1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkyID0gc2hhcnBlMiA8IDAgPyAnbWFsdXMnIDogc2hhcnBlMiA+IDIuMCA/ICdib251cycgOiAnbm9ybWFsJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5MSA9PT0gY2F0ZWdvcnkyKSB7XG4gICAgICAgICAgICAgIGV4cGVjdChtb2RpZmllcjEpLnRvQmUobW9kaWZpZXIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyAyLjMsIDIuNCoqXG4gICAgICogXG4gICAgICogVGVzdCBib3VuZGFyeSBjb25kaXRpb25zIGF0IGV4YWN0bHkgdGhlIHRocmVzaG9sZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBib3VuZGFyeSBjb25kaXRpb25zIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIC8vIEV4YWN0bHkgYXQgbWFsdXMgdGhyZXNob2xkICgwKVxuICAgICAgZXhwZWN0KHRyYWNrZXIuY2FsY3VsYXRlTW9kaWZpZXIoMCkpLnRvQmUoMS4wKTtcbiAgICAgIGV4cGVjdCh0cmFja2VyLmNhbGN1bGF0ZU1vZGlmaWVyKC0wLjApKS50b0JlKDEuMCk7XG4gICAgICBcbiAgICAgIC8vIEp1c3QgYmVsb3cgbWFsdXMgdGhyZXNob2xkXG4gICAgICBleHBlY3QodHJhY2tlci5jYWxjdWxhdGVNb2RpZmllcigtMC4wMDAwMDEpKS50b0JlKHRlc3RDb25maWcubWFsdXNNdWx0aXBsaWVyKTtcbiAgICAgIFxuICAgICAgLy8gRXhhY3RseSBhdCBib251cyB0aHJlc2hvbGQgKDIuMClcbiAgICAgIGV4cGVjdCh0cmFja2VyLmNhbGN1bGF0ZU1vZGlmaWVyKDIuMCkpLnRvQmUoMS4wKTtcbiAgICAgIFxuICAgICAgLy8gSnVzdCBhYm92ZSBib251cyB0aHJlc2hvbGRcbiAgICAgIGV4cGVjdCh0cmFja2VyLmNhbGN1bGF0ZU1vZGlmaWVyKDIuMDAwMDAxKSkudG9CZSh0ZXN0Q29uZmlnLmJvbnVzTXVsdGlwbGllcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiAqKlZhbGlkYXRlczogUmVxdWlyZW1lbnRzIDIuMywgMi40KipcbiAgICAgKiBcbiAgICAgKiBUZXN0IGV4dHJlbWUgdmFsdWVzIHRvIGVuc3VyZSBubyBvdmVyZmxvdyBvciB1bmRlcmZsb3dcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBleHRyZW1lIFNoYXJwZSByYXRpbyB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBleHRyZW1lVmFsdWVzID0gW1xuICAgICAgICAtSW5maW5pdHksIC0xMDAwLCAtMTAwLCAtMTAsXG4gICAgICAgIDEwLCAxMDAsIDEwMDAsIEluZmluaXR5XG4gICAgICBdO1xuICAgICAgXG4gICAgICBleHRyZW1lVmFsdWVzLmZvckVhY2goc2hhcnBlID0+IHtcbiAgICAgICAgaWYgKGlzRmluaXRlKHNoYXJwZSkpIHtcbiAgICAgICAgICBjb25zdCBtb2RpZmllciA9IHRyYWNrZXIuY2FsY3VsYXRlTW9kaWZpZXIoc2hhcnBlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaG91bGQgc3RpbGwgYmUgd2l0aGluIGJvdW5kc1xuICAgICAgICAgIGV4cGVjdChtb2RpZmllcikudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCh0ZXN0Q29uZmlnLm1hbHVzTXVsdGlwbGllcik7XG4gICAgICAgICAgZXhwZWN0KG1vZGlmaWVyKS50b0JlTGVzc1RoYW5PckVxdWFsKHRlc3RDb25maWcuYm9udXNNdWx0aXBsaWVyKTtcbiAgICAgICAgICBleHBlY3QoaXNGaW5pdGUobW9kaWZpZXIpKS50b0JlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NoYXJwZSBSYXRpbyBDYWxjdWxhdGlvbiBQcm9wZXJ0aWVzJywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiBTaGFycGUgcmF0aW8gc2hvdWxkIGJlIDAgZm9yIGluc3VmZmljaWVudCBkYXRhXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gMCBmb3IgaW5zdWZmaWNpZW50IFBuTCBkYXRhJywgKCkgPT4ge1xuICAgICAgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5wcm9wZXJ0eShcbiAgICAgICAgICBmYy5hcnJheShmYy5mbG9hdCh7IG1pbjogTWF0aC5mcm91bmQoLTEwMDApLCBtYXg6IE1hdGguZnJvdW5kKDEwMDApLCBub05hTjogdHJ1ZSB9KSwgeyBtYXhMZW5ndGg6IDEgfSksXG4gICAgICAgICAgKHBubFZhbHVlcykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hhcnBlID0gdHJhY2tlci5jYWxjdWxhdGVTaGFycGVSYXRpbyhwbmxWYWx1ZXMpO1xuICAgICAgICAgICAgZXhwZWN0KHNoYXJwZSkudG9CZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogU2hhcnBlIHJhdGlvIHNob3VsZCBiZSBmaW5pdGUgZm9yIHZhbGlkIGRhdGFcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmaW5pdGUgU2hhcnBlIHJhdGlvIGZvciB2YWxpZCBQbkwgZGF0YScsICgpID0+IHtcbiAgICAgIGZjLmFzc2VydChcbiAgICAgICAgZmMucHJvcGVydHkoXG4gICAgICAgICAgZmMuYXJyYXkoXG4gICAgICAgICAgICBmYy5mbG9hdCh7IG1pbjogTWF0aC5mcm91bmQoLTEwMDApLCBtYXg6IE1hdGguZnJvdW5kKDEwMDApLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICAgIHsgbWluTGVuZ3RoOiAyLCBtYXhMZW5ndGg6IDEwMCB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAocG5sVmFsdWVzKSA9PiB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgd2UgaGF2ZSBzb21lIHZhcmlhdGlvbiB0byBhdm9pZCB6ZXJvIHN0ZCBkZXZcbiAgICAgICAgICAgIGlmIChwbmxWYWx1ZXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgcG5sVmFsdWVzWzBdID0gMTAwOyAgLy8gRm9yY2Ugc29tZSB2YXJpYXRpb25cbiAgICAgICAgICAgICAgcG5sVmFsdWVzWzFdID0gLTUwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBzaGFycGUgPSB0cmFja2VyLmNhbGN1bGF0ZVNoYXJwZVJhdGlvKHBubFZhbHVlcyk7XG4gICAgICAgICAgICBleHBlY3QoaXNGaW5pdGUoc2hhcnBlKSkudG9CZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogNTAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogU2hhcnBlIHJhdGlvIHNob3VsZCBoYW5kbGUgemVybyBzdGFuZGFyZCBkZXZpYXRpb25cbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB6ZXJvIHN0YW5kYXJkIGRldmlhdGlvbiBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICAvLyBBbGwgcG9zaXRpdmUgcmV0dXJuc1xuICAgICAgY29uc3QgYWxsUG9zaXRpdmUgPSBbMTAwLCAxMDAsIDEwMCwgMTAwXTtcbiAgICAgIGNvbnN0IHNoYXJwZVBvc2l0aXZlID0gdHJhY2tlci5jYWxjdWxhdGVTaGFycGVSYXRpbyhhbGxQb3NpdGl2ZSk7XG4gICAgICBleHBlY3Qoc2hhcnBlUG9zaXRpdmUpLnRvQmUoMy4wKTtcbiAgICAgIFxuICAgICAgLy8gQWxsIG5lZ2F0aXZlIHJldHVybnNcbiAgICAgIGNvbnN0IGFsbE5lZ2F0aXZlID0gWy0xMDAsIC0xMDAsIC0xMDAsIC0xMDBdO1xuICAgICAgY29uc3Qgc2hhcnBlTmVnYXRpdmUgPSB0cmFja2VyLmNhbGN1bGF0ZVNoYXJwZVJhdGlvKGFsbE5lZ2F0aXZlKTtcbiAgICAgIGV4cGVjdChzaGFycGVOZWdhdGl2ZSkudG9CZSgtMy4wKTtcbiAgICAgIFxuICAgICAgLy8gQWxsIHplcm8gcmV0dXJuc1xuICAgICAgY29uc3QgYWxsWmVybyA9IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHNoYXJwZVplcm8gPSB0cmFja2VyLmNhbGN1bGF0ZVNoYXJwZVJhdGlvKGFsbFplcm8pO1xuICAgICAgZXhwZWN0KHNoYXJwZVplcm8pLnRvQmUoMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25maWd1cmF0aW9uIFZhbGlkYXRpb24gUHJvcGVydGllcycsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogQ29uZmlndXJhdGlvbiB2YWx1ZXMgc2hvdWxkIGJlIHVzZWQgY29ycmVjdGx5XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCB1c2UgY29uZmlndXJhdGlvbiB2YWx1ZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgY3VzdG9tQ29uZmlnOiBQZXJmb3JtYW5jZVRyYWNrZXJDb25maWcgPSB7XG4gICAgICAgIHdpbmRvd0RheXM6IDE0LFxuICAgICAgICBtaW5UcmFkZUNvdW50OiAyMCxcbiAgICAgICAgbWFsdXNUaHJlc2hvbGQ6IC0wLjUsXG4gICAgICAgIGJvbnVzVGhyZXNob2xkOiAxLjUsXG4gICAgICAgIG1hbHVzTXVsdGlwbGllcjogMC4zLFxuICAgICAgICBib251c011bHRpcGxpZXI6IDEuNVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgY3VzdG9tVHJhY2tlciA9IG5ldyBQZXJmb3JtYW5jZVRyYWNrZXIoY3VzdG9tQ29uZmlnKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCBjdXN0b20gdGhyZXNob2xkc1xuICAgICAgZXhwZWN0KGN1c3RvbVRyYWNrZXIuY2FsY3VsYXRlTW9kaWZpZXIoLTAuNikpLnRvQmUoMC4zKTsgIC8vIEJlbG93IGN1c3RvbSBtYWx1cyB0aHJlc2hvbGRcbiAgICAgIGV4cGVjdChjdXN0b21UcmFja2VyLmNhbGN1bGF0ZU1vZGlmaWVyKC0wLjQpKS50b0JlKDEuMCk7ICAvLyBBYm92ZSBjdXN0b20gbWFsdXMgdGhyZXNob2xkXG4gICAgICBleHBlY3QoY3VzdG9tVHJhY2tlci5jYWxjdWxhdGVNb2RpZmllcigxLjQpKS50b0JlKDEuMCk7ICAgLy8gQmVsb3cgY3VzdG9tIGJvbnVzIHRocmVzaG9sZFxuICAgICAgZXhwZWN0KGN1c3RvbVRyYWNrZXIuY2FsY3VsYXRlTW9kaWZpZXIoMS42KSkudG9CZSgxLjUpOyAgIC8vIEFib3ZlIGN1c3RvbSBib251cyB0aHJlc2hvbGRcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwidmVyc2lvbiI6M30=