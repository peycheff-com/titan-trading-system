{"file":"/Users/ivan/Code/trading/titan/services/titan-brain/src/cache/InMemoryCache.ts","mappings":"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","names":[],"sources":["/Users/ivan/Code/trading/titan/services/titan-brain/src/cache/InMemoryCache.ts"],"sourcesContent":["/**\n * InMemoryCache - High-performance in-memory cache with TTL support\n * \n * Provides fast in-memory caching with automatic expiration and LRU eviction.\n * Used as fallback when Redis is unavailable.\n * \n * Requirements: 3.2.1, 3.2.2, 3.2.3\n */\n\nimport { EventEmitter } from 'events';\n\n/**\n * Cache entry with TTL support\n */\ninterface CacheEntry<T = any> {\n  value: T;\n  expiresAt: number;\n  accessCount: number;\n  lastAccessed: number;\n}\n\n/**\n * In-memory cache statistics\n */\nexport interface InMemoryCacheStats {\n  size: number;\n  maxSize: number;\n  hits: number;\n  misses: number;\n  evictions: number;\n  expired: number;\n  hitRate: number;\n  memoryUsage: number; // Estimated in bytes\n}\n\n/**\n * High-performance in-memory cache with TTL and LRU eviction\n */\nexport class InMemoryCache extends EventEmitter {\n  private cache: Map<string, CacheEntry> = new Map();\n  private maxSize: number;\n  private defaultTtlMs: number;\n  private cleanupInterval: NodeJS.Timeout | null = null;\n  private stats: {\n    hits: number;\n    misses: number;\n    evictions: number;\n    expired: number;\n  } = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    expired: 0\n  };\n\n  constructor(maxSize: number = 1000, defaultTtlMs: number = 300000) {\n    super();\n    this.maxSize = maxSize;\n    this.defaultTtlMs = defaultTtlMs;\n  }\n\n  /**\n   * Initialize the cache with cleanup interval\n   */\n  initialize(): void {\n    // Start cleanup interval to remove expired entries\n    this.startCleanupInterval();\n    this.emit('initialized', { maxSize: this.maxSize, defaultTtlMs: this.defaultTtlMs });\n  }\n\n  /**\n   * Start cleanup interval for expired entries\n   */\n  private startCleanupInterval(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n\n    // Run cleanup every 30 seconds\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupExpired();\n    }, 30000);\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  private cleanupExpired(): void {\n    const now = Date.now();\n    const expiredKeys: string[] = [];\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.expiresAt <= now) {\n        expiredKeys.push(key);\n      }\n    }\n\n    for (const key of expiredKeys) {\n      this.cache.delete(key);\n      this.stats.expired++;\n    }\n\n    if (expiredKeys.length > 0) {\n      this.emit('cleanup', { expiredCount: expiredKeys.length, remainingSize: this.cache.size });\n    }\n  }\n\n  /**\n   * Evict least recently used entries to make space\n   */\n  private evictLRU(count: number = 1): void {\n    if (this.cache.size === 0) return;\n\n    // Sort entries by last accessed time (ascending)\n    const entries = Array.from(this.cache.entries()).sort(\n      ([, a], [, b]) => a.lastAccessed - b.lastAccessed\n    );\n\n    // Remove the oldest entries\n    const actualEvictCount = Math.min(count, entries.length);\n    for (let i = 0; i < actualEvictCount; i++) {\n      const [key] = entries[i];\n      this.cache.delete(key);\n      this.stats.evictions++;\n    }\n\n    this.emit('eviction', { evictedCount: actualEvictCount, remainingSize: this.cache.size });\n  }\n\n  /**\n   * Get a value from cache\n   */\n  get<T = any>(key: string): T | undefined {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      this.stats.misses++;\n      this.emit('miss', { key });\n      return undefined;\n    }\n\n    // Check if entry has expired\n    if (entry.expiresAt <= Date.now()) {\n      this.cache.delete(key);\n      this.stats.expired++;\n      this.stats.misses++;\n      this.emit('expired', { key });\n      return undefined;\n    }\n\n    // Update access statistics\n    entry.accessCount++;\n    entry.lastAccessed = Date.now();\n    this.stats.hits++;\n    \n    this.emit('hit', { key, accessCount: entry.accessCount });\n    return entry.value as T;\n  }\n\n  /**\n   * Set a value in cache\n   */\n  set<T = any>(key: string, value: T, ttlMs?: number): void {\n    const now = Date.now();\n    const effectiveTtl = ttlMs !== undefined ? ttlMs : this.defaultTtlMs;\n    const expiresAt = effectiveTtl > 0 ? now + effectiveTtl : now; // If TTL is 0, expire immediately\n\n    // Check if we need to make space\n    if (!this.cache.has(key) && this.cache.size >= this.maxSize) {\n      // Evict 10% of entries or at least 1\n      const evictCount = Math.max(1, Math.floor(this.maxSize * 0.1));\n      this.evictLRU(evictCount);\n    }\n\n    // Set the entry\n    this.cache.set(key, {\n      value,\n      expiresAt,\n      accessCount: 0,\n      lastAccessed: now\n    });\n\n    this.emit('set', { \n      key, \n      ttlMs: effectiveTtl, \n      size: this.cache.size,\n      expiresAt: new Date(expiresAt).toISOString()\n    });\n  }\n\n  /**\n   * Delete a value from cache\n   */\n  delete(key: string): boolean {\n    const existed = this.cache.delete(key);\n    \n    if (existed) {\n      this.emit('delete', { key, remainingSize: this.cache.size });\n    }\n    \n    return existed;\n  }\n\n  /**\n   * Check if a key exists in cache (without updating access stats)\n   */\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return false;\n    }\n\n    // Check if entry has expired\n    if (entry.expiresAt <= Date.now()) {\n      this.cache.delete(key);\n      this.stats.expired++;\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Get multiple values from cache\n   */\n  getMultiple<T = any>(keys: string[]): Map<string, T> {\n    const result = new Map<string, T>();\n    \n    for (const key of keys) {\n      const value = this.get<T>(key);\n      if (value !== undefined) {\n        result.set(key, value);\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Set multiple values in cache\n   */\n  setMultiple<T = any>(entries: Map<string, T>, ttlMs?: number): void {\n    for (const [key, value] of entries.entries()) {\n      this.set(key, value, ttlMs);\n    }\n  }\n\n  /**\n   * Delete multiple values from cache\n   */\n  deleteMultiple(keys: string[]): number {\n    let deletedCount = 0;\n    \n    for (const key of keys) {\n      if (this.delete(key)) {\n        deletedCount++;\n      }\n    }\n    \n    return deletedCount;\n  }\n\n  /**\n   * Clear all entries from cache\n   */\n  clear(): void {\n    const previousSize = this.cache.size;\n    this.cache.clear();\n    \n    // Reset stats\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      evictions: 0,\n      expired: 0\n    };\n    \n    this.emit('clear', { previousSize });\n  }\n\n  /**\n   * Get all keys in cache (excluding expired)\n   */\n  keys(): string[] {\n    const now = Date.now();\n    const validKeys: string[] = [];\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.expiresAt > now) {\n        validKeys.push(key);\n      }\n    }\n    \n    return validKeys;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): InMemoryCacheStats {\n    const totalRequests = this.stats.hits + this.stats.misses;\n    const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;\n    \n    // Estimate memory usage (rough calculation)\n    let estimatedMemoryUsage = 0;\n    for (const [key, entry] of this.cache.entries()) {\n      // Rough estimation: key size + JSON serialized value size + overhead\n      estimatedMemoryUsage += key.length * 2; // UTF-16 characters\n      estimatedMemoryUsage += JSON.stringify(entry.value).length * 2;\n      estimatedMemoryUsage += 64; // Estimated overhead per entry\n    }\n\n    return {\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      hits: this.stats.hits,\n      misses: this.stats.misses,\n      evictions: this.stats.evictions,\n      expired: this.stats.expired,\n      hitRate,\n      memoryUsage: estimatedMemoryUsage\n    };\n  }\n\n  /**\n   * Get entries that will expire soon\n   */\n  getExpiringEntries(withinMs: number = 60000): Array<{ key: string; expiresAt: number; timeLeft: number }> {\n    const now = Date.now();\n    const threshold = now + withinMs;\n    const expiringEntries: Array<{ key: string; expiresAt: number; timeLeft: number }> = [];\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.expiresAt <= threshold && entry.expiresAt > now) {\n        expiringEntries.push({\n          key,\n          expiresAt: entry.expiresAt,\n          timeLeft: entry.expiresAt - now\n        });\n      }\n    }\n\n    return expiringEntries.sort((a, b) => a.timeLeft - b.timeLeft);\n  }\n\n  /**\n   * Get most accessed entries\n   */\n  getMostAccessed(limit: number = 10): Array<{ key: string; accessCount: number; lastAccessed: number }> {\n    const entries = Array.from(this.cache.entries())\n      .map(([key, entry]) => ({\n        key,\n        accessCount: entry.accessCount,\n        lastAccessed: entry.lastAccessed\n      }))\n      .sort((a, b) => b.accessCount - a.accessCount)\n      .slice(0, limit);\n\n    return entries;\n  }\n\n  /**\n   * Update TTL for an existing entry\n   */\n  updateTTL(key: string, ttlMs: number): boolean {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return false;\n    }\n\n    // Check if entry has expired\n    if (entry.expiresAt <= Date.now()) {\n      this.cache.delete(key);\n      this.stats.expired++;\n      return false;\n    }\n\n    // Update expiration time\n    entry.expiresAt = Date.now() + ttlMs;\n    \n    this.emit('ttl_updated', { \n      key, \n      newTtlMs: ttlMs, \n      expiresAt: new Date(entry.expiresAt).toISOString() \n    });\n    \n    return true;\n  }\n\n  /**\n   * Get TTL for an entry (in milliseconds)\n   */\n  getTTL(key: string): number | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n\n    const now = Date.now();\n    \n    // Check if entry has expired\n    if (entry.expiresAt <= now) {\n      this.cache.delete(key);\n      this.stats.expired++;\n      return null;\n    }\n\n    return entry.expiresAt - now;\n  }\n\n  /**\n   * Shutdown the cache and cleanup resources\n   */\n  shutdown(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n\n    this.clear();\n    this.emit('shutdown');\n  }\n\n  /**\n   * Get current size\n   */\n  size(): number {\n    return this.cache.size;\n  }\n\n  /**\n   * Check if cache is empty\n   */\n  isEmpty(): boolean {\n    return this.cache.size === 0;\n  }\n\n  /**\n   * Check if cache is full\n   */\n  isFull(): boolean {\n    return this.cache.size >= this.maxSize;\n  }\n}"],"version":3}