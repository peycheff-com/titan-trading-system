{"file":"/Users/ivan/Code/trading/titan/services/titan-brain/tests/property/CapitalFlowManager.property.test.ts","mappings":"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","names":[],"sources":["/Users/ivan/Code/trading/titan/services/titan-brain/tests/property/CapitalFlowManager.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for CapitalFlowManager\n * \n * Tests universal properties that should hold across all inputs\n */\n\nimport * as fc from 'fast-check';\nimport { CapitalFlowManager, ExchangeWalletAPI } from '../../src/engine/CapitalFlowManager';\nimport { \n  CapitalFlowConfig,\n  SweepResult,\n  TreasuryOperation\n} from '../../src/types/index';\n\n// Test configuration\nconst testConfig: CapitalFlowConfig = {\n  sweepThreshold: 1.2, // 20% excess triggers sweep\n  reserveLimit: 200, // $200 minimum reserve\n  sweepSchedule: '0 0 * * *', // Daily at midnight\n  maxRetries: 1, // Reduced for faster tests\n  retryBaseDelay: 10 // 10ms base delay for faster tests\n};\n\n/**\n * Mock Exchange API for testing\n */\nclass MockExchangeAPI implements ExchangeWalletAPI {\n  private futuresBalance: number = 0;\n  private spotBalance: number = 0;\n  private shouldFailTransfer: boolean = false;\n  private transferCount: number = 0;\n\n  setFuturesBalance(balance: number): void {\n    this.futuresBalance = Math.max(0, balance);\n  }\n\n  setSpotBalance(balance: number): void {\n    this.spotBalance = Math.max(0, balance);\n  }\n\n  setShouldFailTransfer(shouldFail: boolean): void {\n    this.shouldFailTransfer = shouldFail;\n  }\n\n  getTransferCount(): number {\n    return this.transferCount;\n  }\n\n  resetTransferCount(): void {\n    this.transferCount = 0;\n  }\n\n  async getFuturesBalance(): Promise<number> {\n    return this.futuresBalance;\n  }\n\n  async getSpotBalance(): Promise<number> {\n    return this.spotBalance;\n  }\n\n  async transferToSpot(amount: number): Promise<{ success: boolean; transactionId?: string; error?: string }> {\n    this.transferCount++;\n    \n    if (this.shouldFailTransfer) {\n      return {\n        success: false,\n        error: 'Mock transfer failure'\n      };\n    }\n\n    if (amount > this.futuresBalance) {\n      return {\n        success: false,\n        error: 'Insufficient futures balance'\n      };\n    }\n\n    // Simulate successful transfer\n    this.futuresBalance -= amount;\n    this.spotBalance += amount;\n\n    return {\n      success: true,\n      transactionId: `mock-tx-${Date.now()}-${this.transferCount}`\n    };\n  }\n}\n\ndescribe('CapitalFlowManager Property Tests', () => {\n  let capitalFlowManager: CapitalFlowManager;\n  let mockExchangeAPI: MockExchangeAPI;\n\n  beforeEach(() => {\n    mockExchangeAPI = new MockExchangeAPI();\n    capitalFlowManager = new CapitalFlowManager(testConfig, undefined, mockExchangeAPI);\n  });\n\n  describe('Property 4: Sweep Monotonicity', () => {\n    /**\n     * **Validates: Requirements 4.4**\n     * \n     * For any sequence of successful sweep operations, the total swept amount\n     * should only increase (monotonically non-decreasing). This ensures that\n     * the profit locking mechanism works correctly and never \"loses\" swept profits.\n     * \n     * Property: totalSwept(t+1) >= totalSwept(t) for all successful sweeps\n     */\n    it('should ensure total swept amount only increases with successful sweeps', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          // Generate a sequence of sweep amounts\n          fc.array(\n            fc.float({ min: Math.fround(1), max: Math.fround(10000), noNaN: true }),\n            { minLength: 1, maxLength: 10 }\n          ),\n          // Generate initial futures balance\n          fc.float({ min: Math.fround(1000), max: Math.fround(50000), noNaN: true }),\n          async (sweepAmounts, initialBalance) => {\n            // Set up initial state\n            mockExchangeAPI.setFuturesBalance(initialBalance);\n            mockExchangeAPI.setShouldFailTransfer(false);\n            \n            let previousTotalSwept = capitalFlowManager.getTotalSwept();\n            \n            // Execute sequence of sweeps\n            for (const sweepAmount of sweepAmounts) {\n              // Ensure we have enough balance for the sweep\n              const currentBalance = await mockExchangeAPI.getFuturesBalance();\n              const adjustedAmount = Math.min(sweepAmount, currentBalance - testConfig.reserveLimit);\n              \n              if (adjustedAmount > 0) {\n                const result = await capitalFlowManager.executeSweep(adjustedAmount);\n                \n                if (result.success) {\n                  const currentTotalSwept = capitalFlowManager.getTotalSwept();\n                  \n                  // Property: Total swept should only increase\n                  expect(currentTotalSwept).toBeGreaterThanOrEqual(previousTotalSwept);\n                  \n                  // Property: Increase should equal the sweep amount\n                  expect(currentTotalSwept - previousTotalSwept).toBeCloseTo(adjustedAmount, 6);\n                  \n                  previousTotalSwept = currentTotalSwept;\n                }\n              }\n            }\n          }\n        ),\n        { numRuns: 50, timeout: 10000 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 4.4**\n     * \n     * For any failed sweep operation, the total swept amount should remain unchanged.\n     * This ensures that failed operations don't corrupt the accounting.\n     * \n     * Property: If sweep fails, totalSwept remains constant\n     */\n    it('should not change total swept amount on failed sweeps', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.float({ min: Math.fround(1), max: Math.fround(1000), noNaN: true }), // Reduced max\n          fc.float({ min: Math.fround(500), max: Math.fround(5000), noNaN: true }), // Reduced max\n          async (sweepAmount, initialBalance) => {\n            // Set up initial state\n            mockExchangeAPI.setFuturesBalance(initialBalance);\n            mockExchangeAPI.setShouldFailTransfer(true); // Force failure\n            \n            const initialTotalSwept = capitalFlowManager.getTotalSwept();\n            \n            // Execute sweep (should fail)\n            const result = await capitalFlowManager.executeSweep(sweepAmount);\n            \n            const finalTotalSwept = capitalFlowManager.getTotalSwept();\n            \n            // Property: Failed sweep should not change total swept\n            expect(result.success).toBe(false);\n            expect(finalTotalSwept).toBe(initialTotalSwept);\n          }\n        ),\n        { numRuns: 10, timeout: 1000 } // Further reduced runs and timeout\n      );\n    }, 5000); // Further reduced Jest timeout\n\n    /**\n     * **Validates: Requirements 4.4**\n     * \n     * For any sequence of mixed successful and failed sweeps, the total swept\n     * amount should only increase by the sum of successful sweep amounts.\n     * \n     * Property: totalSwept = sum of all successful sweep amounts\n     */\n    it('should accumulate only successful sweep amounts', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          // Generate sequence of sweep operations with success/failure flags\n          fc.array(\n            fc.record({\n              amount: fc.float({ min: Math.fround(1), max: Math.fround(500), noNaN: true }), // Further reduced max\n              shouldSucceed: fc.boolean()\n            }),\n            { minLength: 2, maxLength: 3 } // Further reduced max length\n          ),\n          fc.float({ min: Math.fround(10000), max: Math.fround(20000), noNaN: true }), // Reduced range\n          async (operations, initialBalance) => {\n            // Set up with large initial balance to avoid balance constraints\n            mockExchangeAPI.setFuturesBalance(initialBalance);\n            \n            const initialTotalSwept = capitalFlowManager.getTotalSwept();\n            let expectedTotalSwept = initialTotalSwept;\n            \n            // Execute sequence of operations\n            for (const op of operations) {\n              mockExchangeAPI.setShouldFailTransfer(!op.shouldSucceed);\n              \n              const result = await capitalFlowManager.executeSweep(op.amount);\n              \n              if (result.success && op.shouldSucceed) {\n                expectedTotalSwept += op.amount;\n              }\n              \n              const currentTotalSwept = capitalFlowManager.getTotalSwept();\n              \n              // Property: Total swept should match expected accumulation\n              expect(currentTotalSwept).toBeCloseTo(expectedTotalSwept, 6);\n            }\n          }\n        ),\n        { numRuns: 10, timeout: 2000 } // Further reduced runs and timeout\n      );\n    }, 8000); // Further reduced Jest timeout\n\n    /**\n     * **Validates: Requirements 4.4**\n     * \n     * The total swept amount should never decrease, even across multiple\n     * manager instances or state resets (monotonicity across time).\n     * \n     * Property: totalSwept is monotonically non-decreasing across all operations\n     */\n    it('should maintain monotonicity across multiple operations', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.array(\n            fc.float({ min: Math.fround(100), max: Math.fround(5000), noNaN: true }),\n            { minLength: 3, maxLength: 15 }\n          ),\n          async (sweepAmounts) => {\n            // Set up with sufficient balance\n            mockExchangeAPI.setFuturesBalance(100000);\n            mockExchangeAPI.setShouldFailTransfer(false);\n            \n            const totalSweptHistory: number[] = [];\n            totalSweptHistory.push(capitalFlowManager.getTotalSwept());\n            \n            // Execute all sweeps and track total swept\n            for (const amount of sweepAmounts) {\n              const result = await capitalFlowManager.executeSweep(amount);\n              \n              if (result.success) {\n                const currentTotal = capitalFlowManager.getTotalSwept();\n                totalSweptHistory.push(currentTotal);\n              }\n            }\n            \n            // Property: Each value should be >= previous value (monotonic)\n            for (let i = 1; i < totalSweptHistory.length; i++) {\n              expect(totalSweptHistory[i]).toBeGreaterThanOrEqual(totalSweptHistory[i - 1]);\n            }\n            \n            // Property: Differences should equal sweep amounts\n            let totalExpectedIncrease = 0;\n            for (const amount of sweepAmounts) {\n              totalExpectedIncrease += amount;\n            }\n            \n            const finalTotal = totalSweptHistory[totalSweptHistory.length - 1];\n            const initialTotal = totalSweptHistory[0];\n            \n            expect(finalTotal - initialTotal).toBeCloseTo(totalExpectedIncrease, 6);\n          }\n        ),\n        { numRuns: 50, timeout: 10000 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 4.4**\n     * \n     * Zero or negative sweep amounts should not affect the total swept amount.\n     * This tests edge cases and input validation.\n     * \n     * Property: Invalid sweep amounts don't change totalSwept\n     */\n    it('should not change total swept for invalid sweep amounts', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.float({ min: Math.fround(-10000), max: Math.fround(0), noNaN: true }),\n          async (invalidAmount) => {\n            mockExchangeAPI.setFuturesBalance(10000);\n            \n            const initialTotalSwept = capitalFlowManager.getTotalSwept();\n            \n            // Execute sweep with invalid amount\n            const result = await capitalFlowManager.executeSweep(invalidAmount);\n            \n            const finalTotalSwept = capitalFlowManager.getTotalSwept();\n            \n            // Property: Invalid amounts should not succeed or change total\n            expect(result.success).toBe(false);\n            expect(finalTotalSwept).toBe(initialTotalSwept);\n          }\n        ),\n        { numRuns: 100, timeout: 8000 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 4.4**\n     * \n     * Concurrent or rapid successive sweeps should maintain monotonicity.\n     * This tests the robustness of the monotonicity property under stress.\n     * \n     * Property: Rapid successive sweeps maintain monotonicity\n     */\n    it('should maintain monotonicity under rapid successive operations', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.array(\n            fc.float({ min: Math.fround(50), max: Math.fround(1000), noNaN: true }),\n            { minLength: 5, maxLength: 20 }\n          ),\n          async (rapidSweepAmounts) => {\n            // Set up with large balance\n            mockExchangeAPI.setFuturesBalance(50000);\n            mockExchangeAPI.setShouldFailTransfer(false);\n            \n            const initialTotalSwept = capitalFlowManager.getTotalSwept();\n            \n            // Execute rapid successive sweeps\n            const results = await Promise.all(\n              rapidSweepAmounts.map(amount => capitalFlowManager.executeSweep(amount))\n            );\n            \n            const finalTotalSwept = capitalFlowManager.getTotalSwept();\n            \n            // Property: Total should have increased by sum of successful sweeps\n            const successfulSweeps = results.filter(r => r.success);\n            const expectedIncrease = successfulSweeps.reduce((sum, r) => sum + r.amount, 0);\n            \n            expect(finalTotalSwept).toBeGreaterThanOrEqual(initialTotalSwept);\n            expect(finalTotalSwept - initialTotalSwept).toBeCloseTo(expectedIncrease, 6);\n          }\n        ),\n        { numRuns: 30, timeout: 15000 }\n      );\n    });\n  });\n\n  describe('Sweep Amount Calculation Properties', () => {\n    /**\n     * Property: Sweep amount should never exceed available balance minus reserve\n     */\n    it('should never sweep more than available balance minus reserve', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.float({ min: Math.fround(500), max: Math.fround(20000), noNaN: true }),\n          fc.float({ min: Math.fround(100), max: Math.fround(10000), noNaN: true }),\n          async (futuresBalance, sweepAmount) => {\n            mockExchangeAPI.setFuturesBalance(futuresBalance);\n            mockExchangeAPI.setShouldFailTransfer(false);\n            \n            const result = await capitalFlowManager.executeSweep(sweepAmount);\n            \n            if (result.success) {\n              // Property: Successful sweep should not violate reserve limit\n              const remainingBalance = futuresBalance - result.amount;\n              expect(remainingBalance).toBeGreaterThanOrEqual(testConfig.reserveLimit);\n            } else if (sweepAmount > 0) {\n              // Property: If sweep failed due to reserve limit, remaining would be < reserve\n              const wouldRemain = futuresBalance - sweepAmount;\n              if (wouldRemain < testConfig.reserveLimit) {\n                expect(result.error).toContain('reserve limit');\n              }\n            }\n          }\n        ),\n        { numRuns: 150, timeout: 8000 }\n      );\n    });\n\n    /**\n     * Property: Sweep decisions should be consistent with balance and thresholds\n     */\n    it('should make consistent sweep decisions based on balance and thresholds', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.float({ min: Math.fround(1000), max: Math.fround(50000), noNaN: true }),\n          fc.float({ min: Math.fround(500), max: Math.fround(20000), noNaN: true }),\n          async (futuresBalance, targetAllocation) => {\n            mockExchangeAPI.setFuturesBalance(futuresBalance);\n            capitalFlowManager.setTargetAllocation(targetAllocation);\n            \n            const decision = await capitalFlowManager.checkSweepConditions();\n            const sweepTriggerLevel = targetAllocation * testConfig.sweepThreshold;\n            \n            // Property: Should sweep if and only if balance exceeds trigger level\n            if (futuresBalance > sweepTriggerLevel) {\n              const maxSweepable = futuresBalance - testConfig.reserveLimit;\n              if (maxSweepable > 0) {\n                expect(decision.shouldSweep).toBe(true);\n                expect(decision.amount).toBeGreaterThan(0);\n                expect(decision.amount).toBeLessThanOrEqual(maxSweepable);\n              } else {\n                expect(decision.shouldSweep).toBe(false);\n              }\n            } else {\n              expect(decision.shouldSweep).toBe(false);\n            }\n          }\n        ),\n        { numRuns: 100, timeout: 8000 }\n      );\n    });\n  });\n\n  describe('Balance Consistency Properties', () => {\n    /**\n     * Property: Futures balance should decrease by exactly the sweep amount on success\n     */\n    it('should decrease futures balance by exactly the sweep amount', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.float({ min: Math.fround(2000), max: Math.fround(20000), noNaN: true }),\n          fc.float({ min: Math.fround(100), max: Math.fround(5000), noNaN: true }),\n          async (initialBalance, sweepAmount) => {\n            mockExchangeAPI.setFuturesBalance(initialBalance);\n            mockExchangeAPI.setShouldFailTransfer(false);\n            \n            const initialFuturesBalance = await mockExchangeAPI.getFuturesBalance();\n            \n            const result = await capitalFlowManager.executeSweep(sweepAmount);\n            \n            if (result.success) {\n              const finalFuturesBalance = await mockExchangeAPI.getFuturesBalance();\n              \n              // Property: Futures balance should decrease by sweep amount\n              expect(initialFuturesBalance - finalFuturesBalance).toBeCloseTo(result.amount, 6);\n            }\n          }\n        ),\n        { numRuns: 100, timeout: 8000 }\n      );\n    });\n\n    /**\n     * Property: Total balance (futures + spot) should remain constant after sweep\n     */\n    it('should preserve total balance across wallets during sweep', async () => {\n      await fc.assert(\n        fc.asyncProperty(\n          fc.float({ min: Math.fround(2000), max: Math.fround(20000), noNaN: true }),\n          fc.float({ min: Math.fround(1000), max: Math.fround(10000), noNaN: true }),\n          fc.float({ min: Math.fround(100), max: Math.fround(3000), noNaN: true }),\n          async (initialFutures, initialSpot, sweepAmount) => {\n            mockExchangeAPI.setFuturesBalance(initialFutures);\n            mockExchangeAPI.setSpotBalance(initialSpot);\n            mockExchangeAPI.setShouldFailTransfer(false);\n            \n            const initialTotal = initialFutures + initialSpot;\n            \n            const result = await capitalFlowManager.executeSweep(sweepAmount);\n            \n            if (result.success) {\n              const finalFutures = await mockExchangeAPI.getFuturesBalance();\n              const finalSpot = await mockExchangeAPI.getSpotBalance();\n              const finalTotal = finalFutures + finalSpot;\n              \n              // Property: Total balance should be preserved\n              expect(finalTotal).toBeCloseTo(initialTotal, 6);\n            }\n          }\n        ),\n        { numRuns: 100, timeout: 8000 }\n      );\n    });\n  });\n});"],"version":3}