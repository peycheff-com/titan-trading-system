e5a196f995dd8ebb3161258e7cbed3eb
"use strict";
/**
 * Property-Based Tests for CapitalFlowManager
 *
 * Tests universal properties that should hold across all inputs
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const fc = __importStar(require("fast-check"));
const CapitalFlowManager_1 = require("../../src/engine/CapitalFlowManager");
// Test configuration
const testConfig = {
    sweepThreshold: 1.2, // 20% excess triggers sweep
    reserveLimit: 200, // $200 minimum reserve
    sweepSchedule: '0 0 * * *', // Daily at midnight
    maxRetries: 3,
    retryBaseDelay: 1000 // 1 second base delay
};
/**
 * Mock Exchange API for testing
 */
class MockExchangeAPI {
    futuresBalance = 0;
    spotBalance = 0;
    shouldFailTransfer = false;
    transferCount = 0;
    setFuturesBalance(balance) {
        this.futuresBalance = Math.max(0, balance);
    }
    setSpotBalance(balance) {
        this.spotBalance = Math.max(0, balance);
    }
    setShouldFailTransfer(shouldFail) {
        this.shouldFailTransfer = shouldFail;
    }
    getTransferCount() {
        return this.transferCount;
    }
    resetTransferCount() {
        this.transferCount = 0;
    }
    async getFuturesBalance() {
        return this.futuresBalance;
    }
    async getSpotBalance() {
        return this.spotBalance;
    }
    async transferToSpot(amount) {
        this.transferCount++;
        if (this.shouldFailTransfer) {
            return {
                success: false,
                error: 'Mock transfer failure'
            };
        }
        if (amount > this.futuresBalance) {
            return {
                success: false,
                error: 'Insufficient futures balance'
            };
        }
        // Simulate successful transfer
        this.futuresBalance -= amount;
        this.spotBalance += amount;
        return {
            success: true,
            transactionId: `mock-tx-${Date.now()}-${this.transferCount}`
        };
    }
}
describe('CapitalFlowManager Property Tests', () => {
    let capitalFlowManager;
    let mockExchangeAPI;
    beforeEach(() => {
        mockExchangeAPI = new MockExchangeAPI();
        capitalFlowManager = new CapitalFlowManager_1.CapitalFlowManager(testConfig, undefined, mockExchangeAPI);
    });
    describe('Property 4: Sweep Monotonicity', () => {
        /**
         * **Validates: Requirements 4.4**
         *
         * For any sequence of successful sweep operations, the total swept amount
         * should only increase (monotonically non-decreasing). This ensures that
         * the profit locking mechanism works correctly and never "loses" swept profits.
         *
         * Property: totalSwept(t+1) >= totalSwept(t) for all successful sweeps
         */
        it('should ensure total swept amount only increases with successful sweeps', async () => {
            await fc.assert(fc.asyncProperty(
            // Generate a sequence of sweep amounts
            fc.array(fc.float({ min: Math.fround(1), max: Math.fround(10000), noNaN: true }), { minLength: 1, maxLength: 10 }), 
            // Generate initial futures balance
            fc.float({ min: Math.fround(1000), max: Math.fround(50000), noNaN: true }), async (sweepAmounts, initialBalance) => {
                // Set up initial state
                mockExchangeAPI.setFuturesBalance(initialBalance);
                mockExchangeAPI.setShouldFailTransfer(false);
                let previousTotalSwept = capitalFlowManager.getTotalSwept();
                // Execute sequence of sweeps
                for (const sweepAmount of sweepAmounts) {
                    // Ensure we have enough balance for the sweep
                    const currentBalance = await mockExchangeAPI.getFuturesBalance();
                    const adjustedAmount = Math.min(sweepAmount, currentBalance - testConfig.reserveLimit);
                    if (adjustedAmount > 0) {
                        const result = await capitalFlowManager.executeSweep(adjustedAmount);
                        if (result.success) {
                            const currentTotalSwept = capitalFlowManager.getTotalSwept();
                            // Property: Total swept should only increase
                            expect(currentTotalSwept).toBeGreaterThanOrEqual(previousTotalSwept);
                            // Property: Increase should equal the sweep amount
                            expect(currentTotalSwept - previousTotalSwept).toBeCloseTo(adjustedAmount, 6);
                            previousTotalSwept = currentTotalSwept;
                        }
                    }
                }
            }), { numRuns: 50, timeout: 10000 });
        });
        /**
         * **Validates: Requirements 4.4**
         *
         * For any failed sweep operation, the total swept amount should remain unchanged.
         * This ensures that failed operations don't corrupt the accounting.
         *
         * Property: If sweep fails, totalSwept remains constant
         */
        it('should not change total swept amount on failed sweeps', async () => {
            await fc.assert(fc.asyncProperty(fc.float({ min: Math.fround(1), max: Math.fround(1000), noNaN: true }), // Reduced max
            fc.float({ min: Math.fround(500), max: Math.fround(5000), noNaN: true }), // Reduced max
            async (sweepAmount, initialBalance) => {
                // Set up initial state
                mockExchangeAPI.setFuturesBalance(initialBalance);
                mockExchangeAPI.setShouldFailTransfer(true); // Force failure
                const initialTotalSwept = capitalFlowManager.getTotalSwept();
                // Execute sweep (should fail)
                const result = await capitalFlowManager.executeSweep(sweepAmount);
                const finalTotalSwept = capitalFlowManager.getTotalSwept();
                // Property: Failed sweep should not change total swept
                expect(result.success).toBe(false);
                expect(finalTotalSwept).toBe(initialTotalSwept);
            }), { numRuns: 10, timeout: 1000 } // Further reduced runs and timeout
            );
        }, 5000); // Further reduced Jest timeout
        /**
         * **Validates: Requirements 4.4**
         *
         * For any sequence of mixed successful and failed sweeps, the total swept
         * amount should only increase by the sum of successful sweep amounts.
         *
         * Property: totalSwept = sum of all successful sweep amounts
         */
        it('should accumulate only successful sweep amounts', async () => {
            await fc.assert(fc.asyncProperty(
            // Generate sequence of sweep operations with success/failure flags
            fc.array(fc.record({
                amount: fc.float({ min: Math.fround(1), max: Math.fround(500), noNaN: true }), // Further reduced max
                shouldSucceed: fc.boolean()
            }), { minLength: 2, maxLength: 3 } // Further reduced max length
            ), fc.float({ min: Math.fround(10000), max: Math.fround(20000), noNaN: true }), // Reduced range
            async (operations, initialBalance) => {
                // Set up with large initial balance to avoid balance constraints
                mockExchangeAPI.setFuturesBalance(initialBalance);
                const initialTotalSwept = capitalFlowManager.getTotalSwept();
                let expectedTotalSwept = initialTotalSwept;
                // Execute sequence of operations
                for (const op of operations) {
                    mockExchangeAPI.setShouldFailTransfer(!op.shouldSucceed);
                    const result = await capitalFlowManager.executeSweep(op.amount);
                    if (result.success && op.shouldSucceed) {
                        expectedTotalSwept += op.amount;
                    }
                    const currentTotalSwept = capitalFlowManager.getTotalSwept();
                    // Property: Total swept should match expected accumulation
                    expect(currentTotalSwept).toBeCloseTo(expectedTotalSwept, 6);
                }
            }), { numRuns: 10, timeout: 2000 } // Further reduced runs and timeout
            );
        }, 8000); // Further reduced Jest timeout
        /**
         * **Validates: Requirements 4.4**
         *
         * The total swept amount should never decrease, even across multiple
         * manager instances or state resets (monotonicity across time).
         *
         * Property: totalSwept is monotonically non-decreasing across all operations
         */
        it('should maintain monotonicity across multiple operations', async () => {
            await fc.assert(fc.asyncProperty(fc.array(fc.float({ min: Math.fround(100), max: Math.fround(5000), noNaN: true }), { minLength: 3, maxLength: 15 }), async (sweepAmounts) => {
                // Set up with sufficient balance
                mockExchangeAPI.setFuturesBalance(100000);
                mockExchangeAPI.setShouldFailTransfer(false);
                const totalSweptHistory = [];
                totalSweptHistory.push(capitalFlowManager.getTotalSwept());
                // Execute all sweeps and track total swept
                for (const amount of sweepAmounts) {
                    const result = await capitalFlowManager.executeSweep(amount);
                    if (result.success) {
                        const currentTotal = capitalFlowManager.getTotalSwept();
                        totalSweptHistory.push(currentTotal);
                    }
                }
                // Property: Each value should be >= previous value (monotonic)
                for (let i = 1; i < totalSweptHistory.length; i++) {
                    expect(totalSweptHistory[i]).toBeGreaterThanOrEqual(totalSweptHistory[i - 1]);
                }
                // Property: Differences should equal sweep amounts
                let totalExpectedIncrease = 0;
                for (const amount of sweepAmounts) {
                    totalExpectedIncrease += amount;
                }
                const finalTotal = totalSweptHistory[totalSweptHistory.length - 1];
                const initialTotal = totalSweptHistory[0];
                expect(finalTotal - initialTotal).toBeCloseTo(totalExpectedIncrease, 6);
            }), { numRuns: 50, timeout: 10000 });
        });
        /**
         * **Validates: Requirements 4.4**
         *
         * Zero or negative sweep amounts should not affect the total swept amount.
         * This tests edge cases and input validation.
         *
         * Property: Invalid sweep amounts don't change totalSwept
         */
        it('should not change total swept for invalid sweep amounts', async () => {
            await fc.assert(fc.asyncProperty(fc.float({ min: Math.fround(-10000), max: Math.fround(0), noNaN: true }), async (invalidAmount) => {
                mockExchangeAPI.setFuturesBalance(10000);
                const initialTotalSwept = capitalFlowManager.getTotalSwept();
                // Execute sweep with invalid amount
                const result = await capitalFlowManager.executeSweep(invalidAmount);
                const finalTotalSwept = capitalFlowManager.getTotalSwept();
                // Property: Invalid amounts should not succeed or change total
                expect(result.success).toBe(false);
                expect(finalTotalSwept).toBe(initialTotalSwept);
            }), { numRuns: 100, timeout: 8000 });
        });
        /**
         * **Validates: Requirements 4.4**
         *
         * Concurrent or rapid successive sweeps should maintain monotonicity.
         * This tests the robustness of the monotonicity property under stress.
         *
         * Property: Rapid successive sweeps maintain monotonicity
         */
        it('should maintain monotonicity under rapid successive operations', async () => {
            await fc.assert(fc.asyncProperty(fc.array(fc.float({ min: Math.fround(50), max: Math.fround(1000), noNaN: true }), { minLength: 5, maxLength: 20 }), async (rapidSweepAmounts) => {
                // Set up with large balance
                mockExchangeAPI.setFuturesBalance(50000);
                mockExchangeAPI.setShouldFailTransfer(false);
                const initialTotalSwept = capitalFlowManager.getTotalSwept();
                // Execute rapid successive sweeps
                const results = await Promise.all(rapidSweepAmounts.map(amount => capitalFlowManager.executeSweep(amount)));
                const finalTotalSwept = capitalFlowManager.getTotalSwept();
                // Property: Total should have increased by sum of successful sweeps
                const successfulSweeps = results.filter(r => r.success);
                const expectedIncrease = successfulSweeps.reduce((sum, r) => sum + r.amount, 0);
                expect(finalTotalSwept).toBeGreaterThanOrEqual(initialTotalSwept);
                expect(finalTotalSwept - initialTotalSwept).toBeCloseTo(expectedIncrease, 6);
            }), { numRuns: 30, timeout: 15000 });
        });
    });
    describe('Sweep Amount Calculation Properties', () => {
        /**
         * Property: Sweep amount should never exceed available balance minus reserve
         */
        it('should never sweep more than available balance minus reserve', async () => {
            await fc.assert(fc.asyncProperty(fc.float({ min: Math.fround(500), max: Math.fround(20000), noNaN: true }), fc.float({ min: Math.fround(100), max: Math.fround(10000), noNaN: true }), async (futuresBalance, sweepAmount) => {
                mockExchangeAPI.setFuturesBalance(futuresBalance);
                mockExchangeAPI.setShouldFailTransfer(false);
                const result = await capitalFlowManager.executeSweep(sweepAmount);
                if (result.success) {
                    // Property: Successful sweep should not violate reserve limit
                    const remainingBalance = futuresBalance - result.amount;
                    expect(remainingBalance).toBeGreaterThanOrEqual(testConfig.reserveLimit);
                }
                else if (sweepAmount > 0) {
                    // Property: If sweep failed due to reserve limit, remaining would be < reserve
                    const wouldRemain = futuresBalance - sweepAmount;
                    if (wouldRemain < testConfig.reserveLimit) {
                        expect(result.error).toContain('reserve limit');
                    }
                }
            }), { numRuns: 150, timeout: 8000 });
        });
        /**
         * Property: Sweep decisions should be consistent with balance and thresholds
         */
        it('should make consistent sweep decisions based on balance and thresholds', async () => {
            await fc.assert(fc.asyncProperty(fc.float({ min: Math.fround(1000), max: Math.fround(50000), noNaN: true }), fc.float({ min: Math.fround(500), max: Math.fround(20000), noNaN: true }), async (futuresBalance, targetAllocation) => {
                mockExchangeAPI.setFuturesBalance(futuresBalance);
                capitalFlowManager.setTargetAllocation(targetAllocation);
                const decision = await capitalFlowManager.checkSweepConditions();
                const sweepTriggerLevel = targetAllocation * testConfig.sweepThreshold;
                // Property: Should sweep if and only if balance exceeds trigger level
                if (futuresBalance > sweepTriggerLevel) {
                    const maxSweepable = futuresBalance - testConfig.reserveLimit;
                    if (maxSweepable > 0) {
                        expect(decision.shouldSweep).toBe(true);
                        expect(decision.amount).toBeGreaterThan(0);
                        expect(decision.amount).toBeLessThanOrEqual(maxSweepable);
                    }
                    else {
                        expect(decision.shouldSweep).toBe(false);
                    }
                }
                else {
                    expect(decision.shouldSweep).toBe(false);
                }
            }), { numRuns: 100, timeout: 8000 });
        });
    });
    describe('Balance Consistency Properties', () => {
        /**
         * Property: Futures balance should decrease by exactly the sweep amount on success
         */
        it('should decrease futures balance by exactly the sweep amount', async () => {
            await fc.assert(fc.asyncProperty(fc.float({ min: Math.fround(2000), max: Math.fround(20000), noNaN: true }), fc.float({ min: Math.fround(100), max: Math.fround(5000), noNaN: true }), async (initialBalance, sweepAmount) => {
                mockExchangeAPI.setFuturesBalance(initialBalance);
                mockExchangeAPI.setShouldFailTransfer(false);
                const initialFuturesBalance = await mockExchangeAPI.getFuturesBalance();
                const result = await capitalFlowManager.executeSweep(sweepAmount);
                if (result.success) {
                    const finalFuturesBalance = await mockExchangeAPI.getFuturesBalance();
                    // Property: Futures balance should decrease by sweep amount
                    expect(initialFuturesBalance - finalFuturesBalance).toBeCloseTo(result.amount, 6);
                }
            }), { numRuns: 100, timeout: 8000 });
        });
        /**
         * Property: Total balance (futures + spot) should remain constant after sweep
         */
        it('should preserve total balance across wallets during sweep', async () => {
            await fc.assert(fc.asyncProperty(fc.float({ min: Math.fround(2000), max: Math.fround(20000), noNaN: true }), fc.float({ min: Math.fround(1000), max: Math.fround(10000), noNaN: true }), fc.float({ min: Math.fround(100), max: Math.fround(3000), noNaN: true }), async (initialFutures, initialSpot, sweepAmount) => {
                mockExchangeAPI.setFuturesBalance(initialFutures);
                mockExchangeAPI.setSpotBalance(initialSpot);
                mockExchangeAPI.setShouldFailTransfer(false);
                const initialTotal = initialFutures + initialSpot;
                const result = await capitalFlowManager.executeSweep(sweepAmount);
                if (result.success) {
                    const finalFutures = await mockExchangeAPI.getFuturesBalance();
                    const finalSpot = await mockExchangeAPI.getSpotBalance();
                    const finalTotal = finalFutures + finalSpot;
                    // Property: Total balance should be preserved
                    expect(finalTotal).toBeCloseTo(initialTotal, 6);
                }
            }), { numRuns: 100, timeout: 8000 });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3Byb3BlcnR5L0NhcGl0YWxGbG93TWFuYWdlci5wcm9wZXJ0eS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILCtDQUFpQztBQUNqQyw0RUFBNEY7QUFPNUYscUJBQXFCO0FBQ3JCLE1BQU0sVUFBVSxHQUFzQjtJQUNwQyxjQUFjLEVBQUUsR0FBRyxFQUFFLDRCQUE0QjtJQUNqRCxZQUFZLEVBQUUsR0FBRyxFQUFFLHVCQUF1QjtJQUMxQyxhQUFhLEVBQUUsV0FBVyxFQUFFLG9CQUFvQjtJQUNoRCxVQUFVLEVBQUUsQ0FBQztJQUNiLGNBQWMsRUFBRSxJQUFJLENBQUMsc0JBQXNCO0NBQzVDLENBQUM7QUFFRjs7R0FFRztBQUNILE1BQU0sZUFBZTtJQUNYLGNBQWMsR0FBVyxDQUFDLENBQUM7SUFDM0IsV0FBVyxHQUFXLENBQUMsQ0FBQztJQUN4QixrQkFBa0IsR0FBWSxLQUFLLENBQUM7SUFDcEMsYUFBYSxHQUFXLENBQUMsQ0FBQztJQUVsQyxpQkFBaUIsQ0FBQyxPQUFlO1FBQy9CLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELGNBQWMsQ0FBQyxPQUFlO1FBQzVCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVELHFCQUFxQixDQUFDLFVBQW1CO1FBQ3ZDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxVQUFVLENBQUM7SUFDdkMsQ0FBQztJQUVELGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM1QixDQUFDO0lBRUQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FB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QUMsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNsRCxDQUFDO1lBQ0gsQ0FBQyxDQUNGLEVBQ0QsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FDaEMsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvaXZhbi9Db2RlL3RyYWRpbmcvdGl0YW4vc2VydmljZXMvdGl0YW4tYnJhaW4vdGVzdHMvcHJvcGVydHkvQ2FwaXRhbEZsb3dNYW5hZ2VyLnByb3BlcnR5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcm9wZXJ0eS1CYXNlZCBUZXN0cyBmb3IgQ2FwaXRhbEZsb3dNYW5hZ2VyXG4gKiBcbiAqIFRlc3RzIHVuaXZlcnNhbCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGhvbGQgYWNyb3NzIGFsbCBpbnB1dHNcbiAqL1xuXG5pbXBvcnQgKiBhcyBmYyBmcm9tICdmYXN0LWNoZWNrJztcbmltcG9ydCB7IENhcGl0YWxGbG93TWFuYWdlciwgRXhjaGFuZ2VXYWxsZXRBUEkgfSBmcm9tICcuLi8uLi9zcmMvZW5naW5lL0NhcGl0YWxGbG93TWFuYWdlcic7XG5pbXBvcnQgeyBcbiAgQ2FwaXRhbEZsb3dDb25maWcsXG4gIFN3ZWVwUmVzdWx0LFxuICBUcmVhc3VyeU9wZXJhdGlvblxufSBmcm9tICcuLi8uLi9zcmMvdHlwZXMvaW5kZXgnO1xuXG4vLyBUZXN0IGNvbmZpZ3VyYXRpb25cbmNvbnN0IHRlc3RDb25maWc6IENhcGl0YWxGbG93Q29uZmlnID0ge1xuICBzd2VlcFRocmVzaG9sZDogMS4yLCAvLyAyMCUgZXhjZXNzIHRyaWdnZXJzIHN3ZWVwXG4gIHJlc2VydmVMaW1pdDogMjAwLCAvLyAkMjAwIG1pbmltdW0gcmVzZXJ2ZVxuICBzd2VlcFNjaGVkdWxlOiAnMCAwICogKiAqJywgLy8gRGFpbHkgYXQgbWlkbmlnaHRcbiAgbWF4UmV0cmllczogMyxcbiAgcmV0cnlCYXNlRGVsYXk6IDEwMDAgLy8gMSBzZWNvbmQgYmFzZSBkZWxheVxufTtcblxuLyoqXG4gKiBNb2NrIEV4Y2hhbmdlIEFQSSBmb3IgdGVzdGluZ1xuICovXG5jbGFzcyBNb2NrRXhjaGFuZ2VBUEkgaW1wbGVtZW50cyBFeGNoYW5nZVdhbGxldEFQSSB7XG4gIHByaXZhdGUgZnV0dXJlc0JhbGFuY2U6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgc3BvdEJhbGFuY2U6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgc2hvdWxkRmFpbFRyYW5zZmVyOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdHJhbnNmZXJDb3VudDogbnVtYmVyID0gMDtcblxuICBzZXRGdXR1cmVzQmFsYW5jZShiYWxhbmNlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmZ1dHVyZXNCYWxhbmNlID0gTWF0aC5tYXgoMCwgYmFsYW5jZSk7XG4gIH1cblxuICBzZXRTcG90QmFsYW5jZShiYWxhbmNlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNwb3RCYWxhbmNlID0gTWF0aC5tYXgoMCwgYmFsYW5jZSk7XG4gIH1cblxuICBzZXRTaG91bGRGYWlsVHJhbnNmZXIoc2hvdWxkRmFpbDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuc2hvdWxkRmFpbFRyYW5zZmVyID0gc2hvdWxkRmFpbDtcbiAgfVxuXG4gIGdldFRyYW5zZmVyQ291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2ZlckNvdW50O1xuICB9XG5cbiAgcmVzZXRUcmFuc2ZlckNvdW50KCk6IHZvaWQge1xuICAgIHRoaXMudHJhbnNmZXJDb3VudCA9IDA7XG4gIH1cblxuICBhc3luYyBnZXRGdXR1cmVzQmFsYW5jZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLmZ1dHVyZXNCYWxhbmNlO1xuICB9XG5cbiAgYXN5bmMgZ2V0U3BvdEJhbGFuY2UoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5zcG90QmFsYW5jZTtcbiAgfVxuXG4gIGFzeW5jIHRyYW5zZmVyVG9TcG90KGFtb3VudDogbnVtYmVyKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IHRyYW5zYWN0aW9uSWQ/OiBzdHJpbmc7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0aGlzLnRyYW5zZmVyQ291bnQrKztcbiAgICBcbiAgICBpZiAodGhpcy5zaG91bGRGYWlsVHJhbnNmZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ01vY2sgdHJhbnNmZXIgZmFpbHVyZSdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGFtb3VudCA+IHRoaXMuZnV0dXJlc0JhbGFuY2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0luc3VmZmljaWVudCBmdXR1cmVzIGJhbGFuY2UnXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNpbXVsYXRlIHN1Y2Nlc3NmdWwgdHJhbnNmZXJcbiAgICB0aGlzLmZ1dHVyZXNCYWxhbmNlIC09IGFtb3VudDtcbiAgICB0aGlzLnNwb3RCYWxhbmNlICs9IGFtb3VudDtcblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdHJhbnNhY3Rpb25JZDogYG1vY2stdHgtJHtEYXRlLm5vdygpfS0ke3RoaXMudHJhbnNmZXJDb3VudH1gXG4gICAgfTtcbiAgfVxufVxuXG5kZXNjcmliZSgnQ2FwaXRhbEZsb3dNYW5hZ2VyIFByb3BlcnR5IFRlc3RzJywgKCkgPT4ge1xuICBsZXQgY2FwaXRhbEZsb3dNYW5hZ2VyOiBDYXBpdGFsRmxvd01hbmFnZXI7XG4gIGxldCBtb2NrRXhjaGFuZ2VBUEk6IE1vY2tFeGNoYW5nZUFQSTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrRXhjaGFuZ2VBUEkgPSBuZXcgTW9ja0V4Y2hhbmdlQVBJKCk7XG4gICAgY2FwaXRhbEZsb3dNYW5hZ2VyID0gbmV3IENhcGl0YWxGbG93TWFuYWdlcih0ZXN0Q29uZmlnLCB1bmRlZmluZWQsIG1vY2tFeGNoYW5nZUFQSSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcm9wZXJ0eSA0OiBTd2VlcCBNb25vdG9uaWNpdHknLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyA0LjQqKlxuICAgICAqIFxuICAgICAqIEZvciBhbnkgc2VxdWVuY2Ugb2Ygc3VjY2Vzc2Z1bCBzd2VlcCBvcGVyYXRpb25zLCB0aGUgdG90YWwgc3dlcHQgYW1vdW50XG4gICAgICogc2hvdWxkIG9ubHkgaW5jcmVhc2UgKG1vbm90b25pY2FsbHkgbm9uLWRlY3JlYXNpbmcpLiBUaGlzIGVuc3VyZXMgdGhhdFxuICAgICAqIHRoZSBwcm9maXQgbG9ja2luZyBtZWNoYW5pc20gd29ya3MgY29ycmVjdGx5IGFuZCBuZXZlciBcImxvc2VzXCIgc3dlcHQgcHJvZml0cy5cbiAgICAgKiBcbiAgICAgKiBQcm9wZXJ0eTogdG90YWxTd2VwdCh0KzEpID49IHRvdGFsU3dlcHQodCkgZm9yIGFsbCBzdWNjZXNzZnVsIHN3ZWVwc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgZW5zdXJlIHRvdGFsIHN3ZXB0IGFtb3VudCBvbmx5IGluY3JlYXNlcyB3aXRoIHN1Y2Nlc3NmdWwgc3dlZXBzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIC8vIEdlbmVyYXRlIGEgc2VxdWVuY2Ugb2Ygc3dlZXAgYW1vdW50c1xuICAgICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgICAgZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKDEpLCBtYXg6IE1hdGguZnJvdW5kKDEwMDAwKSwgbm9OYU46IHRydWUgfSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogMSwgbWF4TGVuZ3RoOiAxMCB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIGZ1dHVyZXMgYmFsYW5jZVxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgxMDAwKSwgbWF4OiBNYXRoLmZyb3VuZCg1MDAwMCksIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgIGFzeW5jIChzd2VlcEFtb3VudHMsIGluaXRpYWxCYWxhbmNlKSA9PiB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgbW9ja0V4Y2hhbmdlQVBJLnNldEZ1dHVyZXNCYWxhbmNlKGluaXRpYWxCYWxhbmNlKTtcbiAgICAgICAgICAgIG1vY2tFeGNoYW5nZUFQSS5zZXRTaG91bGRGYWlsVHJhbnNmZXIoZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgcHJldmlvdXNUb3RhbFN3ZXB0ID0gY2FwaXRhbEZsb3dNYW5hZ2VyLmdldFRvdGFsU3dlcHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBzZXF1ZW5jZSBvZiBzd2VlcHNcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3dlZXBBbW91bnQgb2Ygc3dlZXBBbW91bnRzKSB7XG4gICAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGVub3VnaCBiYWxhbmNlIGZvciB0aGUgc3dlZXBcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBhd2FpdCBtb2NrRXhjaGFuZ2VBUEkuZ2V0RnV0dXJlc0JhbGFuY2UoKTtcbiAgICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWRBbW91bnQgPSBNYXRoLm1pbihzd2VlcEFtb3VudCwgY3VycmVudEJhbGFuY2UgLSB0ZXN0Q29uZmlnLnJlc2VydmVMaW1pdCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoYWRqdXN0ZWRBbW91bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FwaXRhbEZsb3dNYW5hZ2VyLmV4ZWN1dGVTd2VlcChhZGp1c3RlZEFtb3VudCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VG90YWxTd2VwdCA9IGNhcGl0YWxGbG93TWFuYWdlci5nZXRUb3RhbFN3ZXB0KCk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBUb3RhbCBzd2VwdCBzaG91bGQgb25seSBpbmNyZWFzZVxuICAgICAgICAgICAgICAgICAgZXhwZWN0KGN1cnJlbnRUb3RhbFN3ZXB0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKHByZXZpb3VzVG90YWxTd2VwdCk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBJbmNyZWFzZSBzaG91bGQgZXF1YWwgdGhlIHN3ZWVwIGFtb3VudFxuICAgICAgICAgICAgICAgICAgZXhwZWN0KGN1cnJlbnRUb3RhbFN3ZXB0IC0gcHJldmlvdXNUb3RhbFN3ZXB0KS50b0JlQ2xvc2VUbyhhZGp1c3RlZEFtb3VudCwgNik7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzVG90YWxTd2VwdCA9IGN1cnJlbnRUb3RhbFN3ZXB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiA1MCwgdGltZW91dDogMTAwMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNC40KipcbiAgICAgKiBcbiAgICAgKiBGb3IgYW55IGZhaWxlZCBzd2VlcCBvcGVyYXRpb24sIHRoZSB0b3RhbCBzd2VwdCBhbW91bnQgc2hvdWxkIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgICogVGhpcyBlbnN1cmVzIHRoYXQgZmFpbGVkIG9wZXJhdGlvbnMgZG9uJ3QgY29ycnVwdCB0aGUgYWNjb3VudGluZy5cbiAgICAgKiBcbiAgICAgKiBQcm9wZXJ0eTogSWYgc3dlZXAgZmFpbHMsIHRvdGFsU3dlcHQgcmVtYWlucyBjb25zdGFudFxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbm90IGNoYW5nZSB0b3RhbCBzd2VwdCBhbW91bnQgb24gZmFpbGVkIHN3ZWVwcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5mbG9hdCh7IG1pbjogTWF0aC5mcm91bmQoMSksIG1heDogTWF0aC5mcm91bmQoMTAwMCksIG5vTmFOOiB0cnVlIH0pLCAvLyBSZWR1Y2VkIG1heFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCg1MDApLCBtYXg6IE1hdGguZnJvdW5kKDUwMDApLCBub05hTjogdHJ1ZSB9KSwgLy8gUmVkdWNlZCBtYXhcbiAgICAgICAgICBhc3luYyAoc3dlZXBBbW91bnQsIGluaXRpYWxCYWxhbmNlKSA9PiB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgbW9ja0V4Y2hhbmdlQVBJLnNldEZ1dHVyZXNCYWxhbmNlKGluaXRpYWxCYWxhbmNlKTtcbiAgICAgICAgICAgIG1vY2tFeGNoYW5nZUFQSS5zZXRTaG91bGRGYWlsVHJhbnNmZXIodHJ1ZSk7IC8vIEZvcmNlIGZhaWx1cmVcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFRvdGFsU3dlcHQgPSBjYXBpdGFsRmxvd01hbmFnZXIuZ2V0VG90YWxTd2VwdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHN3ZWVwIChzaG91bGQgZmFpbClcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcGl0YWxGbG93TWFuYWdlci5leGVjdXRlU3dlZXAoc3dlZXBBbW91bnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBmaW5hbFRvdGFsU3dlcHQgPSBjYXBpdGFsRmxvd01hbmFnZXIuZ2V0VG90YWxTd2VwdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogRmFpbGVkIHN3ZWVwIHNob3VsZCBub3QgY2hhbmdlIHRvdGFsIHN3ZXB0XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KGZpbmFsVG90YWxTd2VwdCkudG9CZShpbml0aWFsVG90YWxTd2VwdCk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwLCB0aW1lb3V0OiAxMDAwIH0gLy8gRnVydGhlciByZWR1Y2VkIHJ1bnMgYW5kIHRpbWVvdXRcbiAgICAgICk7XG4gICAgfSwgNTAwMCk7IC8vIEZ1cnRoZXIgcmVkdWNlZCBKZXN0IHRpbWVvdXRcblxuICAgIC8qKlxuICAgICAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNC40KipcbiAgICAgKiBcbiAgICAgKiBGb3IgYW55IHNlcXVlbmNlIG9mIG1peGVkIHN1Y2Nlc3NmdWwgYW5kIGZhaWxlZCBzd2VlcHMsIHRoZSB0b3RhbCBzd2VwdFxuICAgICAqIGFtb3VudCBzaG91bGQgb25seSBpbmNyZWFzZSBieSB0aGUgc3VtIG9mIHN1Y2Nlc3NmdWwgc3dlZXAgYW1vdW50cy5cbiAgICAgKiBcbiAgICAgKiBQcm9wZXJ0eTogdG90YWxTd2VwdCA9IHN1bSBvZiBhbGwgc3VjY2Vzc2Z1bCBzd2VlcCBhbW91bnRzXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBhY2N1bXVsYXRlIG9ubHkgc3VjY2Vzc2Z1bCBzd2VlcCBhbW91bnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIC8vIEdlbmVyYXRlIHNlcXVlbmNlIG9mIHN3ZWVwIG9wZXJhdGlvbnMgd2l0aCBzdWNjZXNzL2ZhaWx1cmUgZmxhZ3NcbiAgICAgICAgICBmYy5hcnJheShcbiAgICAgICAgICAgIGZjLnJlY29yZCh7XG4gICAgICAgICAgICAgIGFtb3VudDogZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKDEpLCBtYXg6IE1hdGguZnJvdW5kKDUwMCksIG5vTmFOOiB0cnVlIH0pLCAvLyBGdXJ0aGVyIHJlZHVjZWQgbWF4XG4gICAgICAgICAgICAgIHNob3VsZFN1Y2NlZWQ6IGZjLmJvb2xlYW4oKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogMiwgbWF4TGVuZ3RoOiAzIH0gLy8gRnVydGhlciByZWR1Y2VkIG1heCBsZW5ndGhcbiAgICAgICAgICApLFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgxMDAwMCksIG1heDogTWF0aC5mcm91bmQoMjAwMDApLCBub05hTjogdHJ1ZSB9KSwgLy8gUmVkdWNlZCByYW5nZVxuICAgICAgICAgIGFzeW5jIChvcGVyYXRpb25zLCBpbml0aWFsQmFsYW5jZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHdpdGggbGFyZ2UgaW5pdGlhbCBiYWxhbmNlIHRvIGF2b2lkIGJhbGFuY2UgY29uc3RyYWludHNcbiAgICAgICAgICAgIG1vY2tFeGNoYW5nZUFQSS5zZXRGdXR1cmVzQmFsYW5jZShpbml0aWFsQmFsYW5jZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxUb3RhbFN3ZXB0ID0gY2FwaXRhbEZsb3dNYW5hZ2VyLmdldFRvdGFsU3dlcHQoKTtcbiAgICAgICAgICAgIGxldCBleHBlY3RlZFRvdGFsU3dlcHQgPSBpbml0aWFsVG90YWxTd2VwdDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBzZXF1ZW5jZSBvZiBvcGVyYXRpb25zXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgbW9ja0V4Y2hhbmdlQVBJLnNldFNob3VsZEZhaWxUcmFuc2Zlcighb3Auc2hvdWxkU3VjY2VlZCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXBpdGFsRmxvd01hbmFnZXIuZXhlY3V0ZVN3ZWVwKG9wLmFtb3VudCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgb3Auc2hvdWxkU3VjY2VlZCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkVG90YWxTd2VwdCArPSBvcC5hbW91bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb3RhbFN3ZXB0ID0gY2FwaXRhbEZsb3dNYW5hZ2VyLmdldFRvdGFsU3dlcHQoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBUb3RhbCBzd2VwdCBzaG91bGQgbWF0Y2ggZXhwZWN0ZWQgYWNjdW11bGF0aW9uXG4gICAgICAgICAgICAgIGV4cGVjdChjdXJyZW50VG90YWxTd2VwdCkudG9CZUNsb3NlVG8oZXhwZWN0ZWRUb3RhbFN3ZXB0LCA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAsIHRpbWVvdXQ6IDIwMDAgfSAvLyBGdXJ0aGVyIHJlZHVjZWQgcnVucyBhbmQgdGltZW91dFxuICAgICAgKTtcbiAgICB9LCA4MDAwKTsgLy8gRnVydGhlciByZWR1Y2VkIEplc3QgdGltZW91dFxuXG4gICAgLyoqXG4gICAgICogKipWYWxpZGF0ZXM6IFJlcXVpcmVtZW50cyA0LjQqKlxuICAgICAqIFxuICAgICAqIFRoZSB0b3RhbCBzd2VwdCBhbW91bnQgc2hvdWxkIG5ldmVyIGRlY3JlYXNlLCBldmVuIGFjcm9zcyBtdWx0aXBsZVxuICAgICAqIG1hbmFnZXIgaW5zdGFuY2VzIG9yIHN0YXRlIHJlc2V0cyAobW9ub3RvbmljaXR5IGFjcm9zcyB0aW1lKS5cbiAgICAgKiBcbiAgICAgKiBQcm9wZXJ0eTogdG90YWxTd2VwdCBpcyBtb25vdG9uaWNhbGx5IG5vbi1kZWNyZWFzaW5nIGFjcm9zcyBhbGwgb3BlcmF0aW9uc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gbW9ub3RvbmljaXR5IGFjcm9zcyBtdWx0aXBsZSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgICAgZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKDEwMCksIG1heDogTWF0aC5mcm91bmQoNTAwMCksIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgICAgeyBtaW5MZW5ndGg6IDMsIG1heExlbmd0aDogMTUgfVxuICAgICAgICAgICksXG4gICAgICAgICAgYXN5bmMgKHN3ZWVwQW1vdW50cykgPT4ge1xuICAgICAgICAgICAgLy8gU2V0IHVwIHdpdGggc3VmZmljaWVudCBiYWxhbmNlXG4gICAgICAgICAgICBtb2NrRXhjaGFuZ2VBUEkuc2V0RnV0dXJlc0JhbGFuY2UoMTAwMDAwKTtcbiAgICAgICAgICAgIG1vY2tFeGNoYW5nZUFQSS5zZXRTaG91bGRGYWlsVHJhbnNmZXIoZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB0b3RhbFN3ZXB0SGlzdG9yeTogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgICAgIHRvdGFsU3dlcHRIaXN0b3J5LnB1c2goY2FwaXRhbEZsb3dNYW5hZ2VyLmdldFRvdGFsU3dlcHQoKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgYWxsIHN3ZWVwcyBhbmQgdHJhY2sgdG90YWwgc3dlcHRcbiAgICAgICAgICAgIGZvciAoY29uc3QgYW1vdW50IG9mIHN3ZWVwQW1vdW50cykge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXBpdGFsRmxvd01hbmFnZXIuZXhlY3V0ZVN3ZWVwKGFtb3VudCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VG90YWwgPSBjYXBpdGFsRmxvd01hbmFnZXIuZ2V0VG90YWxTd2VwdCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsU3dlcHRIaXN0b3J5LnB1c2goY3VycmVudFRvdGFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogRWFjaCB2YWx1ZSBzaG91bGQgYmUgPj0gcHJldmlvdXMgdmFsdWUgKG1vbm90b25pYylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxTd2VwdEhpc3RvcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZXhwZWN0KHRvdGFsU3dlcHRIaXN0b3J5W2ldKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKHRvdGFsU3dlcHRIaXN0b3J5W2kgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBEaWZmZXJlbmNlcyBzaG91bGQgZXF1YWwgc3dlZXAgYW1vdW50c1xuICAgICAgICAgICAgbGV0IHRvdGFsRXhwZWN0ZWRJbmNyZWFzZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFtb3VudCBvZiBzd2VlcEFtb3VudHMpIHtcbiAgICAgICAgICAgICAgdG90YWxFeHBlY3RlZEluY3JlYXNlICs9IGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZmluYWxUb3RhbCA9IHRvdGFsU3dlcHRIaXN0b3J5W3RvdGFsU3dlcHRIaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFRvdGFsID0gdG90YWxTd2VwdEhpc3RvcnlbMF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChmaW5hbFRvdGFsIC0gaW5pdGlhbFRvdGFsKS50b0JlQ2xvc2VUbyh0b3RhbEV4cGVjdGVkSW5jcmVhc2UsIDYpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiA1MCwgdGltZW91dDogMTAwMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNC40KipcbiAgICAgKiBcbiAgICAgKiBaZXJvIG9yIG5lZ2F0aXZlIHN3ZWVwIGFtb3VudHMgc2hvdWxkIG5vdCBhZmZlY3QgdGhlIHRvdGFsIHN3ZXB0IGFtb3VudC5cbiAgICAgKiBUaGlzIHRlc3RzIGVkZ2UgY2FzZXMgYW5kIGlucHV0IHZhbGlkYXRpb24uXG4gICAgICogXG4gICAgICogUHJvcGVydHk6IEludmFsaWQgc3dlZXAgYW1vdW50cyBkb24ndCBjaGFuZ2UgdG90YWxTd2VwdFxuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbm90IGNoYW5nZSB0b3RhbCBzd2VwdCBmb3IgaW52YWxpZCBzd2VlcCBhbW91bnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgtMTAwMDApLCBtYXg6IE1hdGguZnJvdW5kKDApLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICBhc3luYyAoaW52YWxpZEFtb3VudCkgPT4ge1xuICAgICAgICAgICAgbW9ja0V4Y2hhbmdlQVBJLnNldEZ1dHVyZXNCYWxhbmNlKDEwMDAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFRvdGFsU3dlcHQgPSBjYXBpdGFsRmxvd01hbmFnZXIuZ2V0VG90YWxTd2VwdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHN3ZWVwIHdpdGggaW52YWxpZCBhbW91bnRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcGl0YWxGbG93TWFuYWdlci5leGVjdXRlU3dlZXAoaW52YWxpZEFtb3VudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVG90YWxTd2VwdCA9IGNhcGl0YWxGbG93TWFuYWdlci5nZXRUb3RhbFN3ZXB0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFByb3BlcnR5OiBJbnZhbGlkIGFtb3VudHMgc2hvdWxkIG5vdCBzdWNjZWVkIG9yIGNoYW5nZSB0b3RhbFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdChmaW5hbFRvdGFsU3dlcHQpLnRvQmUoaW5pdGlhbFRvdGFsU3dlcHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgeyBudW1SdW5zOiAxMDAsIHRpbWVvdXQ6IDgwMDAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqICoqVmFsaWRhdGVzOiBSZXF1aXJlbWVudHMgNC40KipcbiAgICAgKiBcbiAgICAgKiBDb25jdXJyZW50IG9yIHJhcGlkIHN1Y2Nlc3NpdmUgc3dlZXBzIHNob3VsZCBtYWludGFpbiBtb25vdG9uaWNpdHkuXG4gICAgICogVGhpcyB0ZXN0cyB0aGUgcm9idXN0bmVzcyBvZiB0aGUgbW9ub3RvbmljaXR5IHByb3BlcnR5IHVuZGVyIHN0cmVzcy5cbiAgICAgKiBcbiAgICAgKiBQcm9wZXJ0eTogUmFwaWQgc3VjY2Vzc2l2ZSBzd2VlcHMgbWFpbnRhaW4gbW9ub3RvbmljaXR5XG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBtb25vdG9uaWNpdHkgdW5kZXIgcmFwaWQgc3VjY2Vzc2l2ZSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLmFycmF5KFxuICAgICAgICAgICAgZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKDUwKSwgbWF4OiBNYXRoLmZyb3VuZCgxMDAwKSwgbm9OYU46IHRydWUgfSksXG4gICAgICAgICAgICB7IG1pbkxlbmd0aDogNSwgbWF4TGVuZ3RoOiAyMCB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhc3luYyAocmFwaWRTd2VlcEFtb3VudHMpID0+IHtcbiAgICAgICAgICAgIC8vIFNldCB1cCB3aXRoIGxhcmdlIGJhbGFuY2VcbiAgICAgICAgICAgIG1vY2tFeGNoYW5nZUFQSS5zZXRGdXR1cmVzQmFsYW5jZSg1MDAwMCk7XG4gICAgICAgICAgICBtb2NrRXhjaGFuZ2VBUEkuc2V0U2hvdWxkRmFpbFRyYW5zZmVyKGZhbHNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFRvdGFsU3dlcHQgPSBjYXBpdGFsRmxvd01hbmFnZXIuZ2V0VG90YWxTd2VwdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHJhcGlkIHN1Y2Nlc3NpdmUgc3dlZXBzXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIHJhcGlkU3dlZXBBbW91bnRzLm1hcChhbW91bnQgPT4gY2FwaXRhbEZsb3dNYW5hZ2VyLmV4ZWN1dGVTd2VlcChhbW91bnQpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZmluYWxUb3RhbFN3ZXB0ID0gY2FwaXRhbEZsb3dNYW5hZ2VyLmdldFRvdGFsU3dlcHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUHJvcGVydHk6IFRvdGFsIHNob3VsZCBoYXZlIGluY3JlYXNlZCBieSBzdW0gb2Ygc3VjY2Vzc2Z1bCBzd2VlcHNcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NmdWxTd2VlcHMgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3VjY2Vzcyk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZEluY3JlYXNlID0gc3VjY2Vzc2Z1bFN3ZWVwcy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5hbW91bnQsIDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoZmluYWxUb3RhbFN3ZXB0KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGluaXRpYWxUb3RhbFN3ZXB0KTtcbiAgICAgICAgICAgIGV4cGVjdChmaW5hbFRvdGFsU3dlcHQgLSBpbml0aWFsVG90YWxTd2VwdCkudG9CZUNsb3NlVG8oZXhwZWN0ZWRJbmNyZWFzZSwgNik7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDMwLCB0aW1lb3V0OiAxNTAwMCB9XG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3dlZXAgQW1vdW50IENhbGN1bGF0aW9uIFByb3BlcnRpZXMnLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IFN3ZWVwIGFtb3VudCBzaG91bGQgbmV2ZXIgZXhjZWVkIGF2YWlsYWJsZSBiYWxhbmNlIG1pbnVzIHJlc2VydmVcbiAgICAgKi9cbiAgICBpdCgnc2hvdWxkIG5ldmVyIHN3ZWVwIG1vcmUgdGhhbiBhdmFpbGFibGUgYmFsYW5jZSBtaW51cyByZXNlcnZlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCg1MDApLCBtYXg6IE1hdGguZnJvdW5kKDIwMDAwKSwgbm9OYU46IHRydWUgfSksXG4gICAgICAgICAgZmMuZmxvYXQoeyBtaW46IE1hdGguZnJvdW5kKDEwMCksIG1heDogTWF0aC5mcm91bmQoMTAwMDApLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICBhc3luYyAoZnV0dXJlc0JhbGFuY2UsIHN3ZWVwQW1vdW50KSA9PiB7XG4gICAgICAgICAgICBtb2NrRXhjaGFuZ2VBUEkuc2V0RnV0dXJlc0JhbGFuY2UoZnV0dXJlc0JhbGFuY2UpO1xuICAgICAgICAgICAgbW9ja0V4Y2hhbmdlQVBJLnNldFNob3VsZEZhaWxUcmFuc2ZlcihmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcGl0YWxGbG93TWFuYWdlci5leGVjdXRlU3dlZXAoc3dlZXBBbW91bnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgLy8gUHJvcGVydHk6IFN1Y2Nlc3NmdWwgc3dlZXAgc2hvdWxkIG5vdCB2aW9sYXRlIHJlc2VydmUgbGltaXRcbiAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nQmFsYW5jZSA9IGZ1dHVyZXNCYWxhbmNlIC0gcmVzdWx0LmFtb3VudDtcbiAgICAgICAgICAgICAgZXhwZWN0KHJlbWFpbmluZ0JhbGFuY2UpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwodGVzdENvbmZpZy5yZXNlcnZlTGltaXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzd2VlcEFtb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gUHJvcGVydHk6IElmIHN3ZWVwIGZhaWxlZCBkdWUgdG8gcmVzZXJ2ZSBsaW1pdCwgcmVtYWluaW5nIHdvdWxkIGJlIDwgcmVzZXJ2ZVxuICAgICAgICAgICAgICBjb25zdCB3b3VsZFJlbWFpbiA9IGZ1dHVyZXNCYWxhbmNlIC0gc3dlZXBBbW91bnQ7XG4gICAgICAgICAgICAgIGlmICh3b3VsZFJlbWFpbiA8IHRlc3RDb25maWcucmVzZXJ2ZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdyZXNlcnZlIGxpbWl0Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTUwLCB0aW1lb3V0OiA4MDAwIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eTogU3dlZXAgZGVjaXNpb25zIHNob3VsZCBiZSBjb25zaXN0ZW50IHdpdGggYmFsYW5jZSBhbmQgdGhyZXNob2xkc1xuICAgICAqL1xuICAgIGl0KCdzaG91bGQgbWFrZSBjb25zaXN0ZW50IHN3ZWVwIGRlY2lzaW9ucyBiYXNlZCBvbiBiYWxhbmNlIGFuZCB0aHJlc2hvbGRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgxMDAwKSwgbWF4OiBNYXRoLmZyb3VuZCg1MDAwMCksIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCg1MDApLCBtYXg6IE1hdGguZnJvdW5kKDIwMDAwKSwgbm9OYU46IHRydWUgfSksXG4gICAgICAgICAgYXN5bmMgKGZ1dHVyZXNCYWxhbmNlLCB0YXJnZXRBbGxvY2F0aW9uKSA9PiB7XG4gICAgICAgICAgICBtb2NrRXhjaGFuZ2VBUEkuc2V0RnV0dXJlc0JhbGFuY2UoZnV0dXJlc0JhbGFuY2UpO1xuICAgICAgICAgICAgY2FwaXRhbEZsb3dNYW5hZ2VyLnNldFRhcmdldEFsbG9jYXRpb24odGFyZ2V0QWxsb2NhdGlvbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gYXdhaXQgY2FwaXRhbEZsb3dNYW5hZ2VyLmNoZWNrU3dlZXBDb25kaXRpb25zKCk7XG4gICAgICAgICAgICBjb25zdCBzd2VlcFRyaWdnZXJMZXZlbCA9IHRhcmdldEFsbG9jYXRpb24gKiB0ZXN0Q29uZmlnLnN3ZWVwVGhyZXNob2xkO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eTogU2hvdWxkIHN3ZWVwIGlmIGFuZCBvbmx5IGlmIGJhbGFuY2UgZXhjZWVkcyB0cmlnZ2VyIGxldmVsXG4gICAgICAgICAgICBpZiAoZnV0dXJlc0JhbGFuY2UgPiBzd2VlcFRyaWdnZXJMZXZlbCkge1xuICAgICAgICAgICAgICBjb25zdCBtYXhTd2VlcGFibGUgPSBmdXR1cmVzQmFsYW5jZSAtIHRlc3RDb25maWcucmVzZXJ2ZUxpbWl0O1xuICAgICAgICAgICAgICBpZiAobWF4U3dlZXBhYmxlID4gMCkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChkZWNpc2lvbi5zaG91bGRTd2VlcCkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoZGVjaXNpb24uYW1vdW50KS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGRlY2lzaW9uLmFtb3VudCkudG9CZUxlc3NUaGFuT3JFcXVhbChtYXhTd2VlcGFibGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cGVjdChkZWNpc2lvbi5zaG91bGRTd2VlcCkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4cGVjdChkZWNpc2lvbi5zaG91bGRTd2VlcCkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCwgdGltZW91dDogODAwMCB9XG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFsYW5jZSBDb25zaXN0ZW5jeSBQcm9wZXJ0aWVzJywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFByb3BlcnR5OiBGdXR1cmVzIGJhbGFuY2Ugc2hvdWxkIGRlY3JlYXNlIGJ5IGV4YWN0bHkgdGhlIHN3ZWVwIGFtb3VudCBvbiBzdWNjZXNzXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBkZWNyZWFzZSBmdXR1cmVzIGJhbGFuY2UgYnkgZXhhY3RseSB0aGUgc3dlZXAgYW1vdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZmMuYXNzZXJ0KFxuICAgICAgICBmYy5hc3luY1Byb3BlcnR5KFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgyMDAwKSwgbWF4OiBNYXRoLmZyb3VuZCgyMDAwMCksIG5vTmFOOiB0cnVlIH0pLFxuICAgICAgICAgIGZjLmZsb2F0KHsgbWluOiBNYXRoLmZyb3VuZCgxMDApLCBtYXg6IE1hdGguZnJvdW5kKDUwMDApLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICBhc3luYyAoaW5pdGlhbEJhbGFuY2UsIHN3ZWVwQW1vdW50KSA9PiB7XG4gICAgICAgICAgICBtb2NrRXhjaGFuZ2VBUEkuc2V0RnV0dXJlc0JhbGFuY2UoaW5pdGlhbEJhbGFuY2UpO1xuICAgICAgICAgICAgbW9ja0V4Y2hhbmdlQVBJLnNldFNob3VsZEZhaWxUcmFuc2ZlcihmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxGdXR1cmVzQmFsYW5jZSA9IGF3YWl0IG1vY2tFeGNoYW5nZUFQSS5nZXRGdXR1cmVzQmFsYW5jZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXBpdGFsRmxvd01hbmFnZXIuZXhlY3V0ZVN3ZWVwKHN3ZWVwQW1vdW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbmFsRnV0dXJlc0JhbGFuY2UgPSBhd2FpdCBtb2NrRXhjaGFuZ2VBUEkuZ2V0RnV0dXJlc0JhbGFuY2UoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFByb3BlcnR5OiBGdXR1cmVzIGJhbGFuY2Ugc2hvdWxkIGRlY3JlYXNlIGJ5IHN3ZWVwIGFtb3VudFxuICAgICAgICAgICAgICBleHBlY3QoaW5pdGlhbEZ1dHVyZXNCYWxhbmNlIC0gZmluYWxGdXR1cmVzQmFsYW5jZSkudG9CZUNsb3NlVG8ocmVzdWx0LmFtb3VudCwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB7IG51bVJ1bnM6IDEwMCwgdGltZW91dDogODAwMCB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydHk6IFRvdGFsIGJhbGFuY2UgKGZ1dHVyZXMgKyBzcG90KSBzaG91bGQgcmVtYWluIGNvbnN0YW50IGFmdGVyIHN3ZWVwXG4gICAgICovXG4gICAgaXQoJ3Nob3VsZCBwcmVzZXJ2ZSB0b3RhbCBiYWxhbmNlIGFjcm9zcyB3YWxsZXRzIGR1cmluZyBzd2VlcCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGZjLmFzc2VydChcbiAgICAgICAgZmMuYXN5bmNQcm9wZXJ0eShcbiAgICAgICAgICBmYy5mbG9hdCh7IG1pbjogTWF0aC5mcm91bmQoMjAwMCksIG1heDogTWF0aC5mcm91bmQoMjAwMDApLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICBmYy5mbG9hdCh7IG1pbjogTWF0aC5mcm91bmQoMTAwMCksIG1heDogTWF0aC5mcm91bmQoMTAwMDApLCBub05hTjogdHJ1ZSB9KSxcbiAgICAgICAgICBmYy5mbG9hdCh7IG1pbjogTWF0aC5mcm91bmQoMTAwKSwgbWF4OiBNYXRoLmZyb3VuZCgzMDAwKSwgbm9OYU46IHRydWUgfSksXG4gICAgICAgICAgYXN5bmMgKGluaXRpYWxGdXR1cmVzLCBpbml0aWFsU3BvdCwgc3dlZXBBbW91bnQpID0+IHtcbiAgICAgICAgICAgIG1vY2tFeGNoYW5nZUFQSS5zZXRGdXR1cmVzQmFsYW5jZShpbml0aWFsRnV0dXJlcyk7XG4gICAgICAgICAgICBtb2NrRXhjaGFuZ2VBUEkuc2V0U3BvdEJhbGFuY2UoaW5pdGlhbFNwb3QpO1xuICAgICAgICAgICAgbW9ja0V4Y2hhbmdlQVBJLnNldFNob3VsZEZhaWxUcmFuc2ZlcihmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxUb3RhbCA9IGluaXRpYWxGdXR1cmVzICsgaW5pdGlhbFNwb3Q7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcGl0YWxGbG93TWFuYWdlci5leGVjdXRlU3dlZXAoc3dlZXBBbW91bnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmluYWxGdXR1cmVzID0gYXdhaXQgbW9ja0V4Y2hhbmdlQVBJLmdldEZ1dHVyZXNCYWxhbmNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbmFsU3BvdCA9IGF3YWl0IG1vY2tFeGNoYW5nZUFQSS5nZXRTcG90QmFsYW5jZSgpO1xuICAgICAgICAgICAgICBjb25zdCBmaW5hbFRvdGFsID0gZmluYWxGdXR1cmVzICsgZmluYWxTcG90O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUHJvcGVydHk6IFRvdGFsIGJhbGFuY2Ugc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgICAgICAgICBleHBlY3QoZmluYWxUb3RhbCkudG9CZUNsb3NlVG8oaW5pdGlhbFRvdGFsLCA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHsgbnVtUnVuczogMTAwLCB0aW1lb3V0OiA4MDAwIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9