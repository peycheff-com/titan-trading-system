5471102a914e972c76aee7d87105980e
"use strict";
/**
 * HMACValidator Tests
 *
 * Comprehensive unit tests for the HMACValidator class
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Mock Logger
jest.mock('../../src/logging/Logger');
const HMACValidator_1 = require("../../src/security/HMACValidator");
const Logger_1 = require("../../src/logging/Logger");
const crypto_1 = require("crypto");
const mockLogger = {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn()
};
describe('HMACValidator', () => {
    let validator;
    const testSecret = 'test-secret-key';
    beforeEach(() => {
        jest.clearAllMocks();
        Logger_1.Logger.getInstance.mockReturnValue(mockLogger);
        validator = new HMACValidator_1.HMACValidator({
            secret: testSecret,
            algorithm: 'sha256',
            headerName: 'x-signature',
            timestampHeaderName: 'x-timestamp',
            timestampTolerance: 300,
            requireTimestamp: true
        });
    });
    describe('constructor', () => {
        it('should initialize with correct configuration', () => {
            const config = validator.getConfig();
            expect(config.algorithm).toBe('sha256');
            expect(config.headerName).toBe('x-signature');
            expect(config.timestampHeaderName).toBe('x-timestamp');
            expect(config.timestampTolerance).toBe(300);
            expect(config.requireTimestamp).toBe(true);
        });
        it('should throw error if secret is missing', () => {
            expect(() => new HMACValidator_1.HMACValidator({ secret: '' })).toThrow('HMAC secret is required');
        });
        it('should log initialization', () => {
            expect(mockLogger.info).toHaveBeenCalledWith('HMAC validator initialized', undefined, expect.objectContaining({
                algorithm: 'sha256',
                headerName: 'x-signature',
                timestampHeaderName: 'x-timestamp',
                timestampTolerance: 300,
                requireTimestamp: true
            }));
        });
    });
    describe('fromEnvironment', () => {
        const originalEnv = process.env;
        beforeEach(() => {
            process.env = { ...originalEnv };
        });
        afterEach(() => {
            process.env = originalEnv;
        });
        it('should create validator from environment variables', () => {
            process.env.HMAC_SECRET = 'env-secret';
            process.env.HMAC_ALGORITHM = 'sha512';
            process.env.HMAC_HEADER_NAME = 'x-custom-signature';
            process.env.HMAC_TIMESTAMP_TOLERANCE = '600';
            const envValidator = HMACValidator_1.HMACValidator.fromEnvironment();
            const config = envValidator.getConfig();
            expect(config.algorithm).toBe('sha512');
            expect(config.headerName).toBe('x-custom-signature');
            expect(config.timestampTolerance).toBe(600);
        });
        it('should throw error if HMAC_SECRET is missing', () => {
            delete process.env.HMAC_SECRET;
            expect(() => HMACValidator_1.HMACValidator.fromEnvironment()).toThrow('HMAC_SECRET environment variable is required');
        });
        it('should use defaults for missing optional environment variables', () => {
            process.env.HMAC_SECRET = 'env-secret';
            const envValidator = HMACValidator_1.HMACValidator.fromEnvironment();
            const config = envValidator.getConfig();
            expect(config.algorithm).toBe('sha256');
            expect(config.headerName).toBe('x-signature');
            expect(config.timestampTolerance).toBe(300);
        });
    });
    describe('generateSignature', () => {
        it('should generate correct signature without timestamp', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            const expectedSignature = (0, crypto_1.createHmac)('sha256', testSecret)
                .update(payload, 'utf8')
                .digest('hex');
            expect(signature).toBe(expectedSignature);
        });
        it('should generate correct signature with timestamp', () => {
            const payload = 'test payload';
            const timestamp = 1234567890;
            const signature = validator.generateSignature(payload, timestamp);
            const expectedSignature = (0, crypto_1.createHmac)('sha256', testSecret)
                .update(`${timestamp}.${payload}`, 'utf8')
                .digest('hex');
            expect(signature).toBe(expectedSignature);
        });
    });
    describe('validateRequest', () => {
        it('should validate correct signature with timestamp', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            const headers = {
                'x-signature': signature,
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
            expect(result.error).toBeUndefined();
            expect(result.timestamp).toBe(timestamp);
        });
        it('should reject missing signature header', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const headers = {
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Missing x-signature header');
        });
        it('should reject missing timestamp header when required', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            const headers = {
                'x-signature': signature
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Missing x-timestamp header');
        });
        it('should reject invalid timestamp format', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            const headers = {
                'x-signature': signature,
                'x-timestamp': 'invalid-timestamp'
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Invalid timestamp format');
        });
        it('should reject old timestamps', () => {
            const payload = 'test payload';
            const oldTimestamp = Math.floor(Date.now() / 1000) - 600; // 10 minutes ago
            const signature = validator.generateSignature(payload, oldTimestamp);
            const headers = {
                'x-signature': signature,
                'x-timestamp': oldTimestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toContain('Timestamp too old');
        });
        it('should reject future timestamps', () => {
            const payload = 'test payload';
            const futureTimestamp = Math.floor(Date.now() / 1000) + 600; // 10 minutes in future
            const signature = validator.generateSignature(payload, futureTimestamp);
            const headers = {
                'x-signature': signature,
                'x-timestamp': futureTimestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toContain('too far in future');
        });
        it('should reject invalid signature format', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const headers = {
                'x-signature': 'invalid-signature-format!@#',
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Invalid signature format');
        });
        it('should reject incorrect signature', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const wrongSignature = (0, crypto_1.createHmac)('sha256', 'wrong-secret')
                .update(`${timestamp}.${payload}`, 'utf8')
                .digest('hex');
            const headers = {
                'x-signature': wrongSignature,
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Invalid signature');
        });
        it('should handle case-insensitive headers', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            const headers = {
                'X-SIGNATURE': signature,
                'X-TIMESTAMP': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
        it('should handle array header values', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            const headers = {
                'x-signature': [signature, 'other-value'],
                'x-timestamp': [timestamp.toString()]
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
        it('should work without timestamp when not required', () => {
            const noTimestampValidator = new HMACValidator_1.HMACValidator({
                secret: testSecret,
                requireTimestamp: false
            });
            const payload = 'test payload';
            const signature = noTimestampValidator.generateSignature(payload);
            const headers = {
                'x-signature': signature
            };
            const result = noTimestampValidator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
    });
    describe('createHeaders', () => {
        it('should create headers with timestamp', () => {
            const payload = 'test payload';
            const headers = validator.createHeaders(payload, true);
            expect(headers['x-signature']).toBeDefined();
            expect(headers['x-timestamp']).toBeDefined();
            // Verify signature is correct
            const timestamp = parseInt(headers['x-timestamp']);
            const expectedSignature = validator.generateSignature(payload, timestamp);
            expect(headers['x-signature']).toBe(expectedSignature);
        });
        it('should create headers without timestamp', () => {
            const payload = 'test payload';
            const headers = validator.createHeaders(payload, false);
            expect(headers['x-signature']).toBeDefined();
            expect(headers['x-timestamp']).toBeUndefined();
            // Verify signature is correct
            const expectedSignature = validator.generateSignature(payload);
            expect(headers['x-signature']).toBe(expectedSignature);
        });
    });
    describe('utility methods', () => {
        it('should check if enabled', () => {
            expect(validator.isEnabled()).toBe(true);
            const disabledValidator = new HMACValidator_1.HMACValidator({ secret: '' });
            expect(disabledValidator.isEnabled()).toBe(false);
        });
        it('should update secret', () => {
            const newSecret = 'new-secret';
            validator.updateSecret(newSecret);
            // Test with new secret
            const payload = 'test payload';
            const signature = (0, crypto_1.createHmac)('sha256', newSecret)
                .update(payload, 'utf8')
                .digest('hex');
            const headers = { 'x-signature': signature };
            const noTimestampValidator = new HMACValidator_1.HMACValidator({
                secret: newSecret,
                requireTimestamp: false
            });
            const result = noTimestampValidator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
        it('should throw error when updating to empty secret', () => {
            expect(() => validator.updateSecret('')).toThrow('HMAC secret cannot be empty');
        });
        it('should test signature validation', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            expect(validator.test(payload, signature)).toBe(true);
            expect(validator.test(payload, 'wrong-signature')).toBe(false);
        });
    });
    describe('createHMACMiddleware', () => {
        let mockRequest;
        let mockReply;
        beforeEach(() => {
            mockRequest = {
                url: '/test',
                ip: '127.0.0.1',
                headers: {},
                rawBody: '',
                body: {}
            };
            mockReply = {
                status: jest.fn().mockReturnThis(),
                send: jest.fn()
            };
        });
        it('should skip validation for health endpoints', async () => {
            mockRequest.url = '/health';
            const middleware = (0, HMACValidator_1.createHMACMiddleware)(validator);
            await middleware(mockRequest, mockReply);
            expect(mockReply.status).not.toHaveBeenCalled();
        });
        it('should validate HMAC signature', async () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            mockRequest.rawBody = payload;
            mockRequest.headers = {
                'x-signature': signature,
                'x-timestamp': timestamp.toString()
            };
            const middleware = (0, HMACValidator_1.createHMACMiddleware)(validator);
            await middleware(mockRequest, mockReply);
            expect(mockReply.status).not.toHaveBeenCalled();
            expect(mockRequest.hmacValidation).toBeDefined();
            expect(mockRequest.hmacValidation.valid).toBe(true);
        });
        it('should reject invalid HMAC signature', async () => {
            const payload = 'test payload';
            mockRequest.rawBody = payload;
            mockRequest.headers = {
                'x-signature': 'invalid-signature'
            };
            const middleware = (0, HMACValidator_1.createHMACMiddleware)(validator);
            await middleware(mockRequest, mockReply);
            expect(mockReply.status).toHaveBeenCalledWith(401);
            expect(mockReply.send).toHaveBeenCalledWith({
                error: 'Unauthorized',
                message: expect.any(String),
                timestamp: expect.any(String)
            });
        });
    });
    describe('defaults', () => {
        it('should have correct default configurations', () => {
            expect(HMACValidator_1.HMACDefaults.development).toEqual({
                algorithm: 'sha256',
                timestampTolerance: 600,
                requireTimestamp: false
            });
            expect(HMACValidator_1.HMACDefaults.production).toEqual({
                algorithm: 'sha512',
                timestampTolerance: 300,
                requireTimestamp: true
            });
            expect(HMACValidator_1.HMACDefaults.test).toEqual({
                algorithm: 'sha256',
                timestampTolerance: 3600,
                requireTimestamp: false
            });
        });
    });
    describe('timing attack protection', () => {
        it('should take similar time for valid and invalid signatures', async () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const validSignature = validator.generateSignature(payload, timestamp);
            const invalidSignature = 'a'.repeat(validSignature.length);
            const validHeaders = {
                'x-signature': validSignature,
                'x-timestamp': timestamp.toString()
            };
            const invalidHeaders = {
                'x-signature': invalidSignature,
                'x-timestamp': timestamp.toString()
            };
            // Measure time for valid signature
            const validStart = Date.now();
            validator.validateRequest(payload, validHeaders);
            const validTime = Date.now() - validStart;
            // Measure time for invalid signature
            const invalidStart = Date.now();
            validator.validateRequest(payload, invalidHeaders);
            const invalidTime = Date.now() - invalidStart;
            // Times should be similar (within reasonable margin)
            const timeDifference = Math.abs(validTime - invalidTime);
            expect(timeDifference).toBeLessThan(50); // 50ms tolerance
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3NlY3VyaXR5L0hNQUNWYWxpZGF0b3IudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7R0FJRzs7QUFNSCxjQUFjO0FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0FBTHRDLG9FQUFxRztBQUNyRyxxREFBa0Q7QUFDbEQsbUNBQW9DO0FBSXBDLE1BQU0sVUFBVSxHQUFHO0lBQ2pCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtJQUNoQixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUNWLENBQUM7QUFFVCxRQUFRLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRTtJQUM3QixJQUFJLFNBQXdCLENBQUM7SUFDN0IsTUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUM7SUFFckMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNwQixlQUFNLENBQUMsV0FBeUIsQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFOUQsU0FBUyxHQUFHLElBQUksNkJBQWEsQ0FBQztZQUM1QixNQUFNLEVBQUUsVUFBVTtZQUNsQixTQUFTLEVBQUUsUUFBUTtZQUNuQixVQUFVLEVBQUUsYUFBYTtZQUN6QixtQkFBbUIsRUFBRSxhQUFhO1lBQ2xDLGtCQUFrQixFQUFFLEdBQUc7WUFDdkIsZ0JBQWdCLEVBQUUsSUFBSTtTQUN2QixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxhQUFhLEVBQUUsR0FBRyxFQUFFO1FBQzNCLEVBQUUsQ0FBQyw4Q0FBOEMsRUFBRSxHQUFHLEVBQUU7WUFDdEQsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFB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RSxTQUFTLENBQUMsQ0FBQztZQUN2RSxNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTNELE1BQU0sWUFBWSxHQUFHO2dCQUNuQixhQUFhLEVBQUUsY0FBYztnQkFDN0IsYUFBYSxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQUU7YUFDcEMsQ0FBQztZQUVGLE1BQU0sY0FBYyxHQUFHO2dCQUNyQixhQUFhLEVBQUUsZ0JBQWdCO2dCQUMvQixhQUFhLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRTthQUNwQyxDQUFDO1lBRUYsbUNBQW1DO1lBQ25DLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUM5QixTQUFTLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztZQUNqRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsVUFBVSxDQUFDO1lBRTFDLHFDQUFxQztZQUNyQyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDaEMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLENBQUM7WUFDbkQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFlBQVksQ0FBQztZQUU5QyxxREFBcUQ7WUFDckQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLENBQUM7WUFDekQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGlCQUFpQjtRQUM1RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3NlY3VyaXR5L0hNQUNWYWxpZGF0b3IudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhNQUNWYWxpZGF0b3IgVGVzdHNcbiAqIFxuICogQ29tcHJlaGVuc2l2ZSB1bml0IHRlc3RzIGZvciB0aGUgSE1BQ1ZhbGlkYXRvciBjbGFzc1xuICovXG5cbmltcG9ydCB7IEhNQUNWYWxpZGF0b3IsIEhNQUNEZWZhdWx0cywgY3JlYXRlSE1BQ01pZGRsZXdhcmUgfSBmcm9tICcuLi8uLi9zcmMvc2VjdXJpdHkvSE1BQ1ZhbGlkYXRvcic7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi8uLi9zcmMvbG9nZ2luZy9Mb2dnZXInO1xuaW1wb3J0IHsgY3JlYXRlSG1hYyB9IGZyb20gJ2NyeXB0byc7XG5cbi8vIE1vY2sgTG9nZ2VyXG5qZXN0Lm1vY2soJy4uLy4uL3NyYy9sb2dnaW5nL0xvZ2dlcicpO1xuY29uc3QgbW9ja0xvZ2dlciA9IHtcbiAgaW5mbzogamVzdC5mbigpLFxuICB3YXJuOiBqZXN0LmZuKCksXG4gIGVycm9yOiBqZXN0LmZuKCksXG4gIGRlYnVnOiBqZXN0LmZuKClcbn0gYXMgYW55O1xuXG5kZXNjcmliZSgnSE1BQ1ZhbGlkYXRvcicsICgpID0+IHtcbiAgbGV0IHZhbGlkYXRvcjogSE1BQ1ZhbGlkYXRvcjtcbiAgY29uc3QgdGVzdFNlY3JldCA9ICd0ZXN0LXNlY3JldC1rZXknO1xuICBcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgKExvZ2dlci5nZXRJbnN0YW5jZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZShtb2NrTG9nZ2VyKTtcbiAgICBcbiAgICB2YWxpZGF0b3IgPSBuZXcgSE1BQ1ZhbGlkYXRvcih7XG4gICAgICBzZWNyZXQ6IHRlc3RTZWNyZXQsXG4gICAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgICAgaGVhZGVyTmFtZTogJ3gtc2lnbmF0dXJlJyxcbiAgICAgIHRpbWVzdGFtcEhlYWRlck5hbWU6ICd4LXRpbWVzdGFtcCcsXG4gICAgICB0aW1lc3RhbXBUb2xlcmFuY2U6IDMwMCxcbiAgICAgIHJlcXVpcmVUaW1lc3RhbXA6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvbnN0cnVjdG9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGNvcnJlY3QgY29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHZhbGlkYXRvci5nZXRDb25maWcoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGNvbmZpZy5hbGdvcml0aG0pLnRvQmUoJ3NoYTI1NicpO1xuICAgICAgZXhwZWN0KGNvbmZpZy5oZWFkZXJOYW1lKS50b0JlKCd4LXNpZ25hdHVyZScpO1xuICAgICAgZXhwZWN0KGNvbmZpZy50aW1lc3RhbXBIZWFkZXJOYW1lKS50b0JlKCd4LXRpbWVzdGFtcCcpO1xuICAgICAgZXhwZWN0KGNvbmZpZy50aW1lc3RhbXBUb2xlcmFuY2UpLnRvQmUoMzAwKTtcbiAgICAgIGV4cGVjdChjb25maWcucmVxdWlyZVRpbWVzdGFtcCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3IgaWYgc2VjcmV0IGlzIG1pc3NpbmcnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4gbmV3IEhNQUNWYWxpZGF0b3IoeyBzZWNyZXQ6ICcnIH0pKS50b1Rocm93KCdITUFDIHNlY3JldCBpcyByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgaW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgICBleHBlY3QobW9ja0xvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0hNQUMgdmFsaWRhdG9yIGluaXRpYWxpemVkJyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgYWxnb3JpdGhtOiAnc2hhMjU2JyxcbiAgICAgICAgICBoZWFkZXJOYW1lOiAneC1zaWduYXR1cmUnLFxuICAgICAgICAgIHRpbWVzdGFtcEhlYWRlck5hbWU6ICd4LXRpbWVzdGFtcCcsXG4gICAgICAgICAgdGltZXN0YW1wVG9sZXJhbmNlOiAzMDAsXG4gICAgICAgICAgcmVxdWlyZVRpbWVzdGFtcDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2Zyb21FbnZpcm9ubWVudCcsICgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52O1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudiA9IHsgLi4ub3JpZ2luYWxFbnYgfTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52O1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgdmFsaWRhdG9yIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuSE1BQ19TRUNSRVQgPSAnZW52LXNlY3JldCc7XG4gICAgICBwcm9jZXNzLmVudi5ITUFDX0FMR09SSVRITSA9ICdzaGE1MTInO1xuICAgICAgcHJvY2Vzcy5lbnYuSE1BQ19IRUFERVJfTkFNRSA9ICd4LWN1c3RvbS1zaWduYXR1cmUnO1xuICAgICAgcHJvY2Vzcy5lbnYuSE1BQ19USU1FU1RBTVBfVE9MRVJBTkNFID0gJzYwMCc7XG5cbiAgICAgIGNvbnN0IGVudlZhbGlkYXRvciA9IEhNQUNWYWxpZGF0b3IuZnJvbUVudmlyb25tZW50KCk7XG4gICAgICBjb25zdCBjb25maWcgPSBlbnZWYWxpZGF0b3IuZ2V0Q29uZmlnKCk7XG5cbiAgICAgIGV4cGVjdChjb25maWcuYWxnb3JpdGhtKS50b0JlKCdzaGE1MTInKTtcbiAgICAgIGV4cGVjdChjb25maWcuaGVhZGVyTmFtZSkudG9CZSgneC1jdXN0b20tc2lnbmF0dXJlJyk7XG4gICAgICBleHBlY3QoY29uZmlnLnRpbWVzdGFtcFRvbGVyYW5jZSkudG9CZSg2MDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBpZiBITUFDX1NFQ1JFVCBpcyBtaXNzaW5nJywgKCkgPT4ge1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkhNQUNfU0VDUkVUO1xuICAgICAgXG4gICAgICBleHBlY3QoKCkgPT4gSE1BQ1ZhbGlkYXRvci5mcm9tRW52aXJvbm1lbnQoKSkudG9UaHJvdygnSE1BQ19TRUNSRVQgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHRzIGZvciBtaXNzaW5nIG9wdGlvbmFsIGVudmlyb25tZW50IHZhcmlhYmxlcycsICgpID0+IHtcbiAgICAgIHByb2Nlc3MuZW52LkhNQUNfU0VDUkVUID0gJ2Vudi1zZWNyZXQnO1xuICAgICAgXG4gICAgICBjb25zdCBlbnZWYWxpZGF0b3IgPSBITUFDVmFsaWRhdG9yLmZyb21FbnZpcm9ubWVudCgpO1xuICAgICAgY29uc3QgY29uZmlnID0gZW52VmFsaWRhdG9yLmdldENvbmZpZygpO1xuXG4gICAgICBleHBlY3QoY29uZmlnLmFsZ29yaXRobSkudG9CZSgnc2hhMjU2Jyk7XG4gICAgICBleHBlY3QoY29uZmlnLmhlYWRlck5hbWUpLnRvQmUoJ3gtc2lnbmF0dXJlJyk7XG4gICAgICBleHBlY3QoY29uZmlnLnRpbWVzdGFtcFRvbGVyYW5jZSkudG9CZSgzMDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2VuZXJhdGVTaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBjb3JyZWN0IHNpZ25hdHVyZSB3aXRob3V0IHRpbWVzdGFtcCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmUgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCB0ZXN0U2VjcmV0KVxuICAgICAgICAudXBkYXRlKHBheWxvYWQsICd1dGY4JylcbiAgICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzaWduYXR1cmUpLnRvQmUoZXhwZWN0ZWRTaWduYXR1cmUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBjb3JyZWN0IHNpZ25hdHVyZSB3aXRoIHRpbWVzdGFtcCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IDEyMzQ1Njc4OTA7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCwgdGltZXN0YW1wKTtcbiAgICAgIFxuICAgICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmUgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCB0ZXN0U2VjcmV0KVxuICAgICAgICAudXBkYXRlKGAke3RpbWVzdGFtcH0uJHtwYXlsb2FkfWAsICd1dGY4JylcbiAgICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzaWduYXR1cmUpLnRvQmUoZXhwZWN0ZWRTaWduYXR1cmUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVSZXF1ZXN0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgY29ycmVjdCBzaWduYXR1cmUgd2l0aCB0aW1lc3RhbXAnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXApO1xuICAgICAgXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICd4LXRpbWVzdGFtcCc6IHRpbWVzdGFtcC50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC50aW1lc3RhbXApLnRvQmUodGltZXN0YW1wKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IG1pc3Npbmcgc2lnbmF0dXJlIGhlYWRlcicsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAneC10aW1lc3RhbXAnOiB0aW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdNaXNzaW5nIHgtc2lnbmF0dXJlIGhlYWRlcicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgbWlzc2luZyB0aW1lc3RhbXAgaGVhZGVyIHdoZW4gcmVxdWlyZWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdNaXNzaW5nIHgtdGltZXN0YW1wIGhlYWRlcicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCB0aW1lc3RhbXAgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQpO1xuICAgICAgXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICd4LXRpbWVzdGFtcCc6ICdpbnZhbGlkLXRpbWVzdGFtcCdcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZVJlcXVlc3QocGF5bG9hZCwgaGVhZGVycyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZSgnSW52YWxpZCB0aW1lc3RhbXAgZm9ybWF0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBvbGQgdGltZXN0YW1wcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IG9sZFRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gNjAwOyAvLyAxMCBtaW51dGVzIGFnb1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQsIG9sZFRpbWVzdGFtcCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgJ3gtdGltZXN0YW1wJzogb2xkVGltZXN0YW1wLnRvU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZVJlcXVlc3QocGF5bG9hZCwgaGVhZGVycyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdUaW1lc3RhbXAgdG9vIG9sZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgZnV0dXJlIHRpbWVzdGFtcHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCBmdXR1cmVUaW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwMDsgLy8gMTAgbWludXRlcyBpbiBmdXR1cmVcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkLCBmdXR1cmVUaW1lc3RhbXApO1xuICAgICAgXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICd4LXRpbWVzdGFtcCc6IGZ1dHVyZVRpbWVzdGFtcC50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbigndG9vIGZhciBpbiBmdXR1cmUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgc2lnbmF0dXJlIGZvcm1hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiAnaW52YWxpZC1zaWduYXR1cmUtZm9ybWF0IUAjJyxcbiAgICAgICAgJ3gtdGltZXN0YW1wJzogdGltZXN0YW1wLnRvU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZVJlcXVlc3QocGF5bG9hZCwgaGVhZGVycyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZSgnSW52YWxpZCBzaWduYXR1cmUgZm9ybWF0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBpbmNvcnJlY3Qgc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBjb25zdCB3cm9uZ1NpZ25hdHVyZSA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsICd3cm9uZy1zZWNyZXQnKVxuICAgICAgICAudXBkYXRlKGAke3RpbWVzdGFtcH0uJHtwYXlsb2FkfWAsICd1dGY4JylcbiAgICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHdyb25nU2lnbmF0dXJlLFxuICAgICAgICAneC10aW1lc3RhbXAnOiB0aW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCwgdGltZXN0YW1wKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtU0lHTkFUVVJFJzogc2lnbmF0dXJlLFxuICAgICAgICAnWC1USU1FU1RBTVAnOiB0aW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGFycmF5IGhlYWRlciB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXApO1xuICAgICAgXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiBbc2lnbmF0dXJlLCAnb3RoZXItdmFsdWUnXSxcbiAgICAgICAgJ3gtdGltZXN0YW1wJzogW3RpbWVzdGFtcC50b1N0cmluZygpXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgd29yayB3aXRob3V0IHRpbWVzdGFtcCB3aGVuIG5vdCByZXF1aXJlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IG5vVGltZXN0YW1wVmFsaWRhdG9yID0gbmV3IEhNQUNWYWxpZGF0b3Ioe1xuICAgICAgICBzZWNyZXQ6IHRlc3RTZWNyZXQsXG4gICAgICAgIHJlcXVpcmVUaW1lc3RhbXA6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gbm9UaW1lc3RhbXBWYWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gbm9UaW1lc3RhbXBWYWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY3JlYXRlSGVhZGVycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBoZWFkZXJzIHdpdGggdGltZXN0YW1wJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgaGVhZGVycyA9IHZhbGlkYXRvci5jcmVhdGVIZWFkZXJzKHBheWxvYWQsIHRydWUpO1xuICAgICAgXG4gICAgICBleHBlY3QoaGVhZGVyc1sneC1zaWduYXR1cmUnXSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChoZWFkZXJzWyd4LXRpbWVzdGFtcCddKS50b0JlRGVmaW5lZCgpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgc2lnbmF0dXJlIGlzIGNvcnJlY3RcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlSW50KGhlYWRlcnNbJ3gtdGltZXN0YW1wJ10pO1xuICAgICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCwgdGltZXN0YW1wKTtcbiAgICAgIGV4cGVjdChoZWFkZXJzWyd4LXNpZ25hdHVyZSddKS50b0JlKGV4cGVjdGVkU2lnbmF0dXJlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGhlYWRlcnMgd2l0aG91dCB0aW1lc3RhbXAnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdmFsaWRhdG9yLmNyZWF0ZUhlYWRlcnMocGF5bG9hZCwgZmFsc2UpO1xuICAgICAgXG4gICAgICBleHBlY3QoaGVhZGVyc1sneC1zaWduYXR1cmUnXSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChoZWFkZXJzWyd4LXRpbWVzdGFtcCddKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBzaWduYXR1cmUgaXMgY29ycmVjdFxuICAgICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCk7XG4gICAgICBleHBlY3QoaGVhZGVyc1sneC1zaWduYXR1cmUnXSkudG9CZShleHBlY3RlZFNpZ25hdHVyZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd1dGlsaXR5IG1ldGhvZHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjaGVjayBpZiBlbmFibGVkJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHZhbGlkYXRvci5pc0VuYWJsZWQoKSkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgY29uc3QgZGlzYWJsZWRWYWxpZGF0b3IgPSBuZXcgSE1BQ1ZhbGlkYXRvcih7IHNlY3JldDogJycgfSk7XG4gICAgICBleHBlY3QoZGlzYWJsZWRWYWxpZGF0b3IuaXNFbmFibGVkKCkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgc2VjcmV0JywgKCkgPT4ge1xuICAgICAgY29uc3QgbmV3U2VjcmV0ID0gJ25ldy1zZWNyZXQnO1xuICAgICAgdmFsaWRhdG9yLnVwZGF0ZVNlY3JldChuZXdTZWNyZXQpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHdpdGggbmV3IHNlY3JldFxuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gY3JlYXRlSG1hYygnc2hhMjU2JywgbmV3U2VjcmV0KVxuICAgICAgICAudXBkYXRlKHBheWxvYWQsICd1dGY4JylcbiAgICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7ICd4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZSB9O1xuICAgICAgY29uc3Qgbm9UaW1lc3RhbXBWYWxpZGF0b3IgPSBuZXcgSE1BQ1ZhbGlkYXRvcih7XG4gICAgICAgIHNlY3JldDogbmV3U2VjcmV0LFxuICAgICAgICByZXF1aXJlVGltZXN0YW1wOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5vVGltZXN0YW1wVmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIHdoZW4gdXBkYXRpbmcgdG8gZW1wdHkgc2VjcmV0JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KCgpID0+IHZhbGlkYXRvci51cGRhdGVTZWNyZXQoJycpKS50b1Rocm93KCdITUFDIHNlY3JldCBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGVzdCBzaWduYXR1cmUgdmFsaWRhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHZhbGlkYXRvci50ZXN0KHBheWxvYWQsIHNpZ25hdHVyZSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFsaWRhdG9yLnRlc3QocGF5bG9hZCwgJ3dyb25nLXNpZ25hdHVyZScpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NyZWF0ZUhNQUNNaWRkbGV3YXJlJywgKCkgPT4ge1xuICAgIGxldCBtb2NrUmVxdWVzdDogYW55O1xuICAgIGxldCBtb2NrUmVwbHk6IGFueTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIHVybDogJy90ZXN0JyxcbiAgICAgICAgaXA6ICcxMjcuMC4wLjEnLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgcmF3Qm9keTogJycsXG4gICAgICAgIGJvZHk6IHt9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrUmVwbHkgPSB7XG4gICAgICAgIHN0YXR1czogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgIHNlbmQ6IGplc3QuZm4oKVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCB2YWxpZGF0aW9uIGZvciBoZWFsdGggZW5kcG9pbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1JlcXVlc3QudXJsID0gJy9oZWFsdGgnO1xuICAgICAgXG4gICAgICBjb25zdCBtaWRkbGV3YXJlID0gY3JlYXRlSE1BQ01pZGRsZXdhcmUodmFsaWRhdG9yKTtcbiAgICAgIGF3YWl0IG1pZGRsZXdhcmUobW9ja1JlcXVlc3QsIG1vY2tSZXBseSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrUmVwbHkuc3RhdHVzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBITUFDIHNpZ25hdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQsIHRpbWVzdGFtcCk7XG4gICAgICBcbiAgICAgIG1vY2tSZXF1ZXN0LnJhd0JvZHkgPSBwYXlsb2FkO1xuICAgICAgbW9ja1JlcXVlc3QuaGVhZGVycyA9IHtcbiAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbmF0dXJlLFxuICAgICAgICAneC10aW1lc3RhbXAnOiB0aW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbWlkZGxld2FyZSA9IGNyZWF0ZUhNQUNNaWRkbGV3YXJlKHZhbGlkYXRvcik7XG4gICAgICBhd2FpdCBtaWRkbGV3YXJlKG1vY2tSZXF1ZXN0LCBtb2NrUmVwbHkpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja1JlcGx5LnN0YXR1cykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrUmVxdWVzdC5obWFjVmFsaWRhdGlvbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrUmVxdWVzdC5obWFjVmFsaWRhdGlvbi52YWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgSE1BQyBzaWduYXR1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBtb2NrUmVxdWVzdC5yYXdCb2R5ID0gcGF5bG9hZDtcbiAgICAgIG1vY2tSZXF1ZXN0LmhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6ICdpbnZhbGlkLXNpZ25hdHVyZSdcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1pZGRsZXdhcmUgPSBjcmVhdGVITUFDTWlkZGxld2FyZSh2YWxpZGF0b3IpO1xuICAgICAgYXdhaXQgbWlkZGxld2FyZShtb2NrUmVxdWVzdCwgbW9ja1JlcGx5KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tSZXBseS5zdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDQwMSk7XG4gICAgICBleHBlY3QobW9ja1JlcGx5LnNlbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgZXJyb3I6ICdVbmF1dGhvcml6ZWQnLFxuICAgICAgICBtZXNzYWdlOiBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIHRpbWVzdGFtcDogZXhwZWN0LmFueShTdHJpbmcpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlZmF1bHRzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGF2ZSBjb3JyZWN0IGRlZmF1bHQgY29uZmlndXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoSE1BQ0RlZmF1bHRzLmRldmVsb3BtZW50KS50b0VxdWFsKHtcbiAgICAgICAgYWxnb3JpdGhtOiAnc2hhMjU2JyxcbiAgICAgICAgdGltZXN0YW1wVG9sZXJhbmNlOiA2MDAsXG4gICAgICAgIHJlcXVpcmVUaW1lc3RhbXA6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KEhNQUNEZWZhdWx0cy5wcm9kdWN0aW9uKS50b0VxdWFsKHtcbiAgICAgICAgYWxnb3JpdGhtOiAnc2hhNTEyJyxcbiAgICAgICAgdGltZXN0YW1wVG9sZXJhbmNlOiAzMDAsXG4gICAgICAgIHJlcXVpcmVUaW1lc3RhbXA6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoSE1BQ0RlZmF1bHRzLnRlc3QpLnRvRXF1YWwoe1xuICAgICAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgICAgICB0aW1lc3RhbXBUb2xlcmFuY2U6IDM2MDAsXG4gICAgICAgIHJlcXVpcmVUaW1lc3RhbXA6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3RpbWluZyBhdHRhY2sgcHJvdGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRha2Ugc2ltaWxhciB0aW1lIGZvciB2YWxpZCBhbmQgaW52YWxpZCBzaWduYXR1cmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBjb25zdCB2YWxpZFNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXApO1xuICAgICAgY29uc3QgaW52YWxpZFNpZ25hdHVyZSA9ICdhJy5yZXBlYXQodmFsaWRTaWduYXR1cmUubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRIZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiB2YWxpZFNpZ25hdHVyZSxcbiAgICAgICAgJ3gtdGltZXN0YW1wJzogdGltZXN0YW1wLnRvU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGludmFsaWRIZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiBpbnZhbGlkU2lnbmF0dXJlLFxuICAgICAgICAneC10aW1lc3RhbXAnOiB0aW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSB0aW1lIGZvciB2YWxpZCBzaWduYXR1cmVcbiAgICAgIGNvbnN0IHZhbGlkU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCB2YWxpZEhlYWRlcnMpO1xuICAgICAgY29uc3QgdmFsaWRUaW1lID0gRGF0ZS5ub3coKSAtIHZhbGlkU3RhcnQ7XG4gICAgICBcbiAgICAgIC8vIE1lYXN1cmUgdGltZSBmb3IgaW52YWxpZCBzaWduYXR1cmVcbiAgICAgIGNvbnN0IGludmFsaWRTdGFydCA9IERhdGUubm93KCk7XG4gICAgICB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGludmFsaWRIZWFkZXJzKTtcbiAgICAgIGNvbnN0IGludmFsaWRUaW1lID0gRGF0ZS5ub3coKSAtIGludmFsaWRTdGFydDtcbiAgICAgIFxuICAgICAgLy8gVGltZXMgc2hvdWxkIGJlIHNpbWlsYXIgKHdpdGhpbiByZWFzb25hYmxlIG1hcmdpbilcbiAgICAgIGNvbnN0IHRpbWVEaWZmZXJlbmNlID0gTWF0aC5hYnModmFsaWRUaW1lIC0gaW52YWxpZFRpbWUpO1xuICAgICAgZXhwZWN0KHRpbWVEaWZmZXJlbmNlKS50b0JlTGVzc1RoYW4oNTApOyAvLyA1MG1zIHRvbGVyYW5jZVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==