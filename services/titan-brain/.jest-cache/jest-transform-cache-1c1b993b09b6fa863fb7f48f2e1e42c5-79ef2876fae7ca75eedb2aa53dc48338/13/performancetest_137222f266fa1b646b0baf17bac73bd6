5e06077ae1ba0db2144173d0339ea604
"use strict";
/**
 * Performance validation tests for Titan Brain
 *
 * Tests performance requirements under load:
 * - Cache operations performance
 * - Memory usage stability
 * - No memory leaks detected
 */
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const CacheManager_js_1 = require("../../src/cache/CacheManager.js");
describe('Performance Validation Tests', () => {
    describe('Cache Performance', () => {
        let cacheManager;
        beforeAll(async () => {
            cacheManager = new CacheManager_js_1.CacheManager({
                redis: {
                    host: 'localhost',
                    port: 6379
                },
                enableInMemoryFallback: true,
                inMemoryMaxSize: 1000,
                inMemoryTtlMs: 300000, // 5 minutes
                healthCheckIntervalMs: 30000,
                healthCheckTimeoutMs: 5000,
                maxReconnectAttempts: 3,
                reconnectDelayMs: 1000
            });
            await cacheManager.initialize();
        });
        afterAll(async () => {
            if (cacheManager) {
                await cacheManager.shutdown();
            }
        });
        it('should handle high-frequency cache operations', async () => {
            const operations = 1000;
            const start = perf_hooks_1.performance.now();
            // Perform mixed cache operations
            for (let i = 0; i < operations; i++) {
                const key = `test-key-${i % 100}`; // Reuse keys to test overwrites
                const value = { data: `test-value-${i}`, timestamp: Date.now() };
                await cacheManager.set(key, value, 60000); // 1 minute TTL
                if (i % 10 === 0) {
                    await cacheManager.get(key);
                }
            }
            const end = perf_hooks_1.performance.now();
            const totalTime = end - start;
            const avgOperationTime = totalTime / operations;
            console.log(`Cache performance:
        Total time for ${operations} operations: ${totalTime.toFixed(2)}ms
        Average operation time: ${avgOperationTime.toFixed(3)}ms`);
            expect(avgOperationTime).toBeLessThan(5); // < 5ms per operation (more realistic)
            expect(totalTime).toBeLessThan(10000); // Total < 10 seconds
        }, 15000);
        it('should handle concurrent cache operations', async () => {
            const concurrentOps = 50;
            const promises = [];
            for (let i = 0; i < concurrentOps; i++) {
                promises.push((async () => {
                    const start = perf_hooks_1.performance.now();
                    try {
                        const key = `concurrent-key-${i}`;
                        const value = { id: i, data: `concurrent-data-${i}` };
                        await cacheManager.set(key, value, 30000);
                        const retrieved = await cacheManager.get(key);
                        const end = perf_hooks_1.performance.now();
                        expect(retrieved).toBeDefined();
                        return end - start;
                    }
                    catch (error) {
                        console.warn(`Concurrent cache operation ${i + 1} failed:`, error);
                        return 1000; // Return high time for failed operations
                    }
                })());
            }
            const operationTimes = await Promise.all(promises);
            const successfulOps = operationTimes.filter(time => time < 1000);
            // At least 90% of operations should succeed
            expect(successfulOps.length).toBeGreaterThanOrEqual(concurrentOps * 0.9);
            // Average time should be reasonable under concurrent load
            const avgOpTime = successfulOps.reduce((a, b) => a + b, 0) / successfulOps.length;
            expect(avgOpTime).toBeLessThan(100); // < 100ms under concurrent load
        }, 15000);
    });
    describe('Memory Usage', () => {
        it('should maintain stable memory usage', async () => {
            const initialMemory = process.memoryUsage();
            const memorySnapshots = [initialMemory];
            // Perform memory-intensive operations
            for (let i = 0; i < 100; i++) {
                // Create and discard objects to test garbage collection
                const largeArray = new Array(10000).fill(0).map((_, idx) => ({
                    id: idx,
                    data: `test-data-${idx}`,
                    timestamp: Date.now()
                }));
                // Force some async operations
                await new Promise(resolve => setTimeout(resolve, 10));
                // Take memory snapshot every 20 iterations
                if (i % 20 === 0) {
                    // Force garbage collection if available
                    if (global.gc) {
                        global.gc();
                    }
                    memorySnapshots.push(process.memoryUsage());
                }
            }
            const finalMemory = process.memoryUsage();
            const memoryGrowth = finalMemory.heapUsed - initialMemory.heapUsed;
            const memoryGrowthMB = memoryGrowth / (1024 * 1024);
            console.log(`Memory usage:
        Initial heap: ${(initialMemory.heapUsed / 1024 / 1024).toFixed(2)} MB
        Final heap: ${(finalMemory.heapUsed / 1024 / 1024).toFixed(2)} MB
        Growth: ${memoryGrowthMB.toFixed(2)} MB`);
            // Memory growth should be reasonable (< 50MB for this test)
            expect(memoryGrowthMB).toBeLessThan(50);
            // Heap usage should not exceed 200MB
            expect(finalMemory.heapUsed / 1024 / 1024).toBeLessThan(200);
        }, 15000);
        it('should not have significant memory leaks', async () => {
            const iterations = 50;
            const memoryReadings = [];
            for (let i = 0; i < iterations; i++) {
                // Create temporary objects
                const tempData = new Array(1000).fill(0).map((_, idx) => ({
                    id: `temp-${i}-${idx}`,
                    data: new Array(100).fill(`data-${i}-${idx}`),
                    timestamp: Date.now()
                }));
                // Use the data briefly
                const processed = tempData.filter(item => item.id.includes('temp'));
                expect(processed.length).toBe(1000);
                // Clear references
                tempData.length = 0;
                // Force garbage collection every 10 iterations
                if (i % 10 === 0 && global.gc) {
                    global.gc();
                    memoryReadings.push(process.memoryUsage().heapUsed);
                }
                await new Promise(resolve => setTimeout(resolve, 5));
            }
            // Check that memory usage doesn't continuously grow
            if (memoryReadings.length >= 3) {
                const firstReading = memoryReadings[0];
                const lastReading = memoryReadings[memoryReadings.length - 1];
                const memoryGrowth = (lastReading - firstReading) / (1024 * 1024);
                console.log(`Memory leak test:
          First reading: ${(firstReading / 1024 / 1024).toFixed(2)} MB
          Last reading: ${(lastReading / 1024 / 1024).toFixed(2)} MB
          Growth: ${memoryGrowth.toFixed(2)} MB`);
                // Memory growth should be minimal (< 20MB)
                expect(memoryGrowth).toBeLessThan(20);
            }
        }, 20000);
    });
    describe('CPU Performance', () => {
        it('should handle CPU-intensive operations efficiently', async () => {
            const iterations = 1000;
            const start = perf_hooks_1.performance.now();
            // Simulate CPU-intensive calculations
            let result = 0;
            for (let i = 0; i < iterations; i++) {
                // Mathematical operations
                result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);
                // String operations
                const str = `test-string-${i}`;
                const processed = str.split('-').map(s => s.toUpperCase()).join('_');
                // Object operations
                const obj = { id: i, value: processed, timestamp: Date.now() };
                const serialized = JSON.stringify(obj);
                const deserialized = JSON.parse(serialized);
                expect(deserialized.id).toBe(i);
            }
            const end = perf_hooks_1.performance.now();
            const totalTime = end - start;
            const avgOperationTime = totalTime / iterations;
            console.log(`CPU performance:
        Total time for ${iterations} operations: ${totalTime.toFixed(2)}ms
        Average operation time: ${avgOperationTime.toFixed(3)}ms
        Result: ${result.toFixed(2)}`);
            expect(avgOperationTime).toBeLessThan(1); // < 1ms per operation
            expect(totalTime).toBeLessThan(2000); // Total < 2 seconds
        }, 10000);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3BlcmZvcm1hbmNlL3BlcmZvcm1hbmNlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7O0dBT0c7O0FBRUgsMkNBQXlDO0FBQ3pDLHFFQUErRDtBQUUvRCxRQUFRLENBQUMsOEJBQThCLEVBQUUsR0FBRyxFQUFFO0lBQzVDLFFBQVEsQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLEVBQUU7UUFDakMsSUFBSSxZQUEwQixDQUFDO1FBRS9CLFNBQVMsQ0FBQyxLQUFLLElBQUksRUFBRTtZQUNuQixZQUFZLEdBQUcsSUFBSSw4QkFBWSxDQUFDO2dCQUM5QixLQUFLLEVBQUU7b0JBQ0wsSUFBSSxFQUFFLFdBQVc7b0JBQ2pCLElBQUksRUFBRSxJQUFJO2lCQUNYO2dCQUNELHNCQUFzQixFQUFFLElBQUk7Z0JBQzVCLGVBQWUsRUFBRSxJQUFJO2dCQUNyQixhQUFhLEVBQUUsTUFBTSxFQUFFLFlBQVk7Z0JBQ25DLHFCQUFxQixFQUFFLEtBQUs7Z0JBQzVCLG9CQUFvQixFQUFFLElBQUk7Z0JBQzFCLG9CQUFvQixFQUFFLENBQUM7Z0JBQ3ZCLGdCQUFnQixFQUFFLElBQUk7YUFDdkIsQ0FBQyxDQUFDO1lBRUgsTUFBTSxZQUFZLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDbEIsSUFBSSxZQUFZLEVBQUUsQ0FBQztnQkFDakIsTUFBTSxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDaEMsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtDQUErQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQztZQUN4QixNQUFNLEtBQUssR0FBRyx3QkFBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBRWhDLGlDQUFpQztZQUNqQyxLQUFLLElBQUks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WUFDOUIsTUFBTSxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsVUFBVSxDQUFDO1lBRWhELE9BQU8sQ0FBQyxHQUFHLENBQUM7eUJBQ08sVUFBVSxnQkFBZ0IsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7a0NBQ3JDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7a0JBQzNDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRWpDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLHNCQUFzQjtZQUNoRSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsb0JBQW9CO1FBQzVELENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNaLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3BlcmZvcm1hbmNlL3BlcmZvcm1hbmNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSB2YWxpZGF0aW9uIHRlc3RzIGZvciBUaXRhbiBCcmFpblxuICogXG4gKiBUZXN0cyBwZXJmb3JtYW5jZSByZXF1aXJlbWVudHMgdW5kZXIgbG9hZDpcbiAqIC0gQ2FjaGUgb3BlcmF0aW9ucyBwZXJmb3JtYW5jZVxuICogLSBNZW1vcnkgdXNhZ2Ugc3RhYmlsaXR5XG4gKiAtIE5vIG1lbW9yeSBsZWFrcyBkZXRlY3RlZFxuICovXG5cbmltcG9ydCB7IHBlcmZvcm1hbmNlIH0gZnJvbSAncGVyZl9ob29rcyc7XG5pbXBvcnQgeyBDYWNoZU1hbmFnZXIgfSBmcm9tICcuLi8uLi9zcmMvY2FjaGUvQ2FjaGVNYW5hZ2VyLmpzJztcblxuZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFZhbGlkYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdDYWNoZSBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICBsZXQgY2FjaGVNYW5hZ2VyOiBDYWNoZU1hbmFnZXI7XG5cbiAgICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgY2FjaGVNYW5hZ2VyID0gbmV3IENhY2hlTWFuYWdlcih7XG4gICAgICAgIHJlZGlzOiB7XG4gICAgICAgICAgaG9zdDogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgcG9ydDogNjM3OVxuICAgICAgICB9LFxuICAgICAgICBlbmFibGVJbk1lbW9yeUZhbGxiYWNrOiB0cnVlLFxuICAgICAgICBpbk1lbW9yeU1heFNpemU6IDEwMDAsXG4gICAgICAgIGluTWVtb3J5VHRsTXM6IDMwMDAwMCwgLy8gNSBtaW51dGVzXG4gICAgICAgIGhlYWx0aENoZWNrSW50ZXJ2YWxNczogMzAwMDAsXG4gICAgICAgIGhlYWx0aENoZWNrVGltZW91dE1zOiA1MDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogMyxcbiAgICAgICAgcmVjb25uZWN0RGVsYXlNczogMTAwMFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGNhY2hlTWFuYWdlci5pbml0aWFsaXplKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoY2FjaGVNYW5hZ2VyKSB7XG4gICAgICAgIGF3YWl0IGNhY2hlTWFuYWdlci5zaHV0ZG93bigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaGlnaC1mcmVxdWVuY3kgY2FjaGUgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSAxMDAwO1xuICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgLy8gUGVyZm9ybSBtaXhlZCBjYWNoZSBvcGVyYXRpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBgdGVzdC1rZXktJHtpICUgMTAwfWA7IC8vIFJldXNlIGtleXMgdG8gdGVzdCBvdmVyd3JpdGVzXG4gICAgICAgIGNvbnN0IHZhbHVlID0geyBkYXRhOiBgdGVzdC12YWx1ZS0ke2l9YCwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBjYWNoZU1hbmFnZXIuc2V0KGtleSwgdmFsdWUsIDYwMDAwKTsgLy8gMSBtaW51dGUgVFRMXG4gICAgICAgIFxuICAgICAgICBpZiAoaSAlIDEwID09PSAwKSB7XG4gICAgICAgICAgYXdhaXQgY2FjaGVNYW5hZ2VyLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kIC0gc3RhcnQ7XG4gICAgICBjb25zdCBhdmdPcGVyYXRpb25UaW1lID0gdG90YWxUaW1lIC8gb3BlcmF0aW9ucztcblxuICAgICAgY29uc29sZS5sb2coYENhY2hlIHBlcmZvcm1hbmNlOlxuICAgICAgICBUb3RhbCB0aW1lIGZvciAke29wZXJhdGlvbnN9IG9wZXJhdGlvbnM6ICR7dG90YWxUaW1lLnRvRml4ZWQoMil9bXNcbiAgICAgICAgQXZlcmFnZSBvcGVyYXRpb24gdGltZTogJHthdmdPcGVyYXRpb25UaW1lLnRvRml4ZWQoMyl9bXNgKTtcblxuICAgICAgZXhwZWN0KGF2Z09wZXJhdGlvblRpbWUpLnRvQmVMZXNzVGhhbig1KTsgLy8gPCA1bXMgcGVyIG9wZXJhdGlvbiAobW9yZSByZWFsaXN0aWMpXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4oMTAwMDApOyAvLyBUb3RhbCA8IDEwIHNlY29uZHNcbiAgICB9LCAxNTAwMCk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IGNhY2hlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25jdXJyZW50T3BzID0gNTA7XG4gICAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTxudW1iZXI+W10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25jdXJyZW50T3BzOyBpKyspIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGBjb25jdXJyZW50LWtleS0ke2l9YDtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB7IGlkOiBpLCBkYXRhOiBgY29uY3VycmVudC1kYXRhLSR7aX1gIH07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBhd2FpdCBjYWNoZU1hbmFnZXIuc2V0KGtleSwgdmFsdWUsIDMwMDAwKTtcbiAgICAgICAgICAgICAgY29uc3QgcmV0cmlldmVkID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldChrZXkpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBleHBlY3QocmV0cmlldmVkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENvbmN1cnJlbnQgY2FjaGUgb3BlcmF0aW9uICR7aSArIDF9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICAgICAgICAgIHJldHVybiAxMDAwOyAvLyBSZXR1cm4gaGlnaCB0aW1lIGZvciBmYWlsZWQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3BlcmF0aW9uVGltZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBjb25zdCBzdWNjZXNzZnVsT3BzID0gb3BlcmF0aW9uVGltZXMuZmlsdGVyKHRpbWUgPT4gdGltZSA8IDEwMDApO1xuICAgICAgXG4gICAgICAvLyBBdCBsZWFzdCA5MCUgb2Ygb3BlcmF0aW9ucyBzaG91bGQgc3VjY2VlZFxuICAgICAgZXhwZWN0KHN1Y2Nlc3NmdWxPcHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGNvbmN1cnJlbnRPcHMgKiAwLjkpO1xuICAgICAgXG4gICAgICAvLyBBdmVyYWdlIHRpbWUgc2hvdWxkIGJlIHJlYXNvbmFibGUgdW5kZXIgY29uY3VycmVudCBsb2FkXG4gICAgICBjb25zdCBhdmdPcFRpbWUgPSBzdWNjZXNzZnVsT3BzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gc3VjY2Vzc2Z1bE9wcy5sZW5ndGg7XG4gICAgICBleHBlY3QoYXZnT3BUaW1lKS50b0JlTGVzc1RoYW4oMTAwKTsgLy8gPCAxMDBtcyB1bmRlciBjb25jdXJyZW50IGxvYWRcbiAgICB9LCAxNTAwMCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgVXNhZ2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBtYWludGFpbiBzdGFibGUgbWVtb3J5IHVzYWdlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICAgIGNvbnN0IG1lbW9yeVNuYXBzaG90czogTm9kZUpTLk1lbW9yeVVzYWdlW10gPSBbaW5pdGlhbE1lbW9yeV07XG5cbiAgICAgIC8vIFBlcmZvcm0gbWVtb3J5LWludGVuc2l2ZSBvcGVyYXRpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgZGlzY2FyZCBvYmplY3RzIHRvIHRlc3QgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgICAgIGNvbnN0IGxhcmdlQXJyYXkgPSBuZXcgQXJyYXkoMTAwMDApLmZpbGwoMCkubWFwKChfLCBpZHgpID0+ICh7XG4gICAgICAgICAgaWQ6IGlkeCxcbiAgICAgICAgICBkYXRhOiBgdGVzdC1kYXRhLSR7aWR4fWAsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvcmNlIHNvbWUgYXN5bmMgb3BlcmF0aW9uc1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRha2UgbWVtb3J5IHNuYXBzaG90IGV2ZXJ5IDIwIGl0ZXJhdGlvbnNcbiAgICAgICAgaWYgKGkgJSAyMCA9PT0gMCkge1xuICAgICAgICAgIC8vIEZvcmNlIGdhcmJhZ2UgY29sbGVjdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAoZ2xvYmFsLmdjKSB7XG4gICAgICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtb3J5U25hcHNob3RzLnB1c2gocHJvY2Vzcy5tZW1vcnlVc2FnZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICAgIGNvbnN0IG1lbW9yeUdyb3d0aCA9IGZpbmFsTWVtb3J5LmhlYXBVc2VkIC0gaW5pdGlhbE1lbW9yeS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUdyb3d0aE1CID0gbWVtb3J5R3Jvd3RoIC8gKDEwMjQgKiAxMDI0KTtcblxuICAgICAgY29uc29sZS5sb2coYE1lbW9yeSB1c2FnZTpcbiAgICAgICAgSW5pdGlhbCBoZWFwOiAkeyhpbml0aWFsTWVtb3J5LmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQpLnRvRml4ZWQoMil9IE1CXG4gICAgICAgIEZpbmFsIGhlYXA6ICR7KGZpbmFsTWVtb3J5LmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQpLnRvRml4ZWQoMil9IE1CXG4gICAgICAgIEdyb3d0aDogJHttZW1vcnlHcm93dGhNQi50b0ZpeGVkKDIpfSBNQmApO1xuXG4gICAgICAvLyBNZW1vcnkgZ3Jvd3RoIHNob3VsZCBiZSByZWFzb25hYmxlICg8IDUwTUIgZm9yIHRoaXMgdGVzdClcbiAgICAgIGV4cGVjdChtZW1vcnlHcm93dGhNQikudG9CZUxlc3NUaGFuKDUwKTtcbiAgICAgIFxuICAgICAgLy8gSGVhcCB1c2FnZSBzaG91bGQgbm90IGV4Y2VlZCAyMDBNQlxuICAgICAgZXhwZWN0KGZpbmFsTWVtb3J5LmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQpLnRvQmVMZXNzVGhhbigyMDApO1xuICAgIH0sIDE1MDAwKTtcblxuICAgIGl0KCdzaG91bGQgbm90IGhhdmUgc2lnbmlmaWNhbnQgbWVtb3J5IGxlYWtzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDUwO1xuICAgICAgY29uc3QgbWVtb3J5UmVhZGluZ3M6IG51bWJlcltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0ZW1wb3Jhcnkgb2JqZWN0c1xuICAgICAgICBjb25zdCB0ZW1wRGF0YSA9IG5ldyBBcnJheSgxMDAwKS5maWxsKDApLm1hcCgoXywgaWR4KSA9PiAoe1xuICAgICAgICAgIGlkOiBgdGVtcC0ke2l9LSR7aWR4fWAsXG4gICAgICAgICAgZGF0YTogbmV3IEFycmF5KDEwMCkuZmlsbChgZGF0YS0ke2l9LSR7aWR4fWApLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBkYXRhIGJyaWVmbHlcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gdGVtcERhdGEuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZC5pbmNsdWRlcygndGVtcCcpKTtcbiAgICAgICAgZXhwZWN0KHByb2Nlc3NlZC5sZW5ndGgpLnRvQmUoMTAwMCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgcmVmZXJlbmNlc1xuICAgICAgICB0ZW1wRGF0YS5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIEZvcmNlIGdhcmJhZ2UgY29sbGVjdGlvbiBldmVyeSAxMCBpdGVyYXRpb25zXG4gICAgICAgIGlmIChpICUgMTAgPT09IDAgJiYgZ2xvYmFsLmdjKSB7XG4gICAgICAgICAgZ2xvYmFsLmdjKCk7XG4gICAgICAgICAgbWVtb3J5UmVhZGluZ3MucHVzaChwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdGhhdCBtZW1vcnkgdXNhZ2UgZG9lc24ndCBjb250aW51b3VzbHkgZ3Jvd1xuICAgICAgaWYgKG1lbW9yeVJlYWRpbmdzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVhZGluZyA9IG1lbW9yeVJlYWRpbmdzWzBdO1xuICAgICAgICBjb25zdCBsYXN0UmVhZGluZyA9IG1lbW9yeVJlYWRpbmdzW21lbW9yeVJlYWRpbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBtZW1vcnlHcm93dGggPSAobGFzdFJlYWRpbmcgLSBmaXJzdFJlYWRpbmcpIC8gKDEwMjQgKiAxMDI0KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgTWVtb3J5IGxlYWsgdGVzdDpcbiAgICAgICAgICBGaXJzdCByZWFkaW5nOiAkeyhmaXJzdFJlYWRpbmcgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX0gTUJcbiAgICAgICAgICBMYXN0IHJlYWRpbmc6ICR7KGxhc3RSZWFkaW5nIC8gMTAyNCAvIDEwMjQpLnRvRml4ZWQoMil9IE1CXG4gICAgICAgICAgR3Jvd3RoOiAke21lbW9yeUdyb3d0aC50b0ZpeGVkKDIpfSBNQmApO1xuXG4gICAgICAgIC8vIE1lbW9yeSBncm93dGggc2hvdWxkIGJlIG1pbmltYWwgKDwgMjBNQilcbiAgICAgICAgZXhwZWN0KG1lbW9yeUdyb3d0aCkudG9CZUxlc3NUaGFuKDIwKTtcbiAgICAgIH1cbiAgICB9LCAyMDAwMCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDUFUgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQ1BVLWludGVuc2l2ZSBvcGVyYXRpb25zIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDEwMDA7XG4gICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBDUFUtaW50ZW5zaXZlIGNhbGN1bGF0aW9uc1xuICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAvLyBNYXRoZW1hdGljYWwgb3BlcmF0aW9uc1xuICAgICAgICByZXN1bHQgKz0gTWF0aC5zcXJ0KGkpICogTWF0aC5zaW4oaSkgKiBNYXRoLmNvcyhpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0cmluZyBvcGVyYXRpb25zXG4gICAgICAgIGNvbnN0IHN0ciA9IGB0ZXN0LXN0cmluZy0ke2l9YDtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gc3RyLnNwbGl0KCctJykubWFwKHMgPT4gcy50b1VwcGVyQ2FzZSgpKS5qb2luKCdfJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBPYmplY3Qgb3BlcmF0aW9uc1xuICAgICAgICBjb25zdCBvYmogPSB7IGlkOiBpLCB2YWx1ZTogcHJvY2Vzc2VkLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZGVzZXJpYWxpemVkLmlkKS50b0JlKGkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgY29uc3QgYXZnT3BlcmF0aW9uVGltZSA9IHRvdGFsVGltZSAvIGl0ZXJhdGlvbnM7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBDUFUgcGVyZm9ybWFuY2U6XG4gICAgICAgIFRvdGFsIHRpbWUgZm9yICR7aXRlcmF0aW9uc30gb3BlcmF0aW9uczogJHt0b3RhbFRpbWUudG9GaXhlZCgyKX1tc1xuICAgICAgICBBdmVyYWdlIG9wZXJhdGlvbiB0aW1lOiAke2F2Z09wZXJhdGlvblRpbWUudG9GaXhlZCgzKX1tc1xuICAgICAgICBSZXN1bHQ6ICR7cmVzdWx0LnRvRml4ZWQoMil9YCk7XG5cbiAgICAgIGV4cGVjdChhdmdPcGVyYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMSk7IC8vIDwgMW1zIHBlciBvcGVyYXRpb25cbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKTsgLy8gVG90YWwgPCAyIHNlY29uZHNcbiAgICB9LCAxMDAwMCk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9