fcf7cbaf4802dca249868b9da05e19ca
"use strict";
/**
 * HMACValidator Tests
 *
 * Comprehensive unit tests for the HMACValidator class
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Mock Logger
jest.mock('../../src/logging/Logger');
const HMACValidator_1 = require("../../src/security/HMACValidator");
const Logger_1 = require("../../src/logging/Logger");
const crypto_1 = require("crypto");
const mockLogger = {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
    debug: jest.fn()
};
describe('HMACValidator', () => {
    let validator;
    const testSecret = 'test-secret-key';
    beforeEach(() => {
        jest.clearAllMocks();
        Logger_1.Logger.getInstance.mockReturnValue(mockLogger);
        validator = new HMACValidator_1.HMACValidator({
            secret: testSecret,
            algorithm: 'sha256',
            headerName: 'x-signature',
            timestampHeaderName: 'x-timestamp',
            timestampTolerance: 300,
            requireTimestamp: true
        });
    });
    describe('constructor', () => {
        it('should initialize with correct configuration', () => {
            const config = validator.getConfig();
            expect(config.algorithm).toBe('sha256');
            expect(config.headerName).toBe('x-signature');
            expect(config.timestampHeaderName).toBe('x-timestamp');
            expect(config.timestampTolerance).toBe(300);
            expect(config.requireTimestamp).toBe(true);
        });
        it('should throw error if secret is missing', () => {
            expect(() => new HMACValidator_1.HMACValidator({ secret: '' })).toThrow('HMAC secret is required');
        });
        it('should log initialization', () => {
            expect(mockLogger.info).toHaveBeenCalledWith('HMAC validator initialized', undefined, expect.objectContaining({
                algorithm: 'sha256',
                headerName: 'x-signature',
                timestampHeaderName: 'x-timestamp',
                timestampTolerance: 300,
                requireTimestamp: true
            }));
        });
    });
    describe('fromEnvironment', () => {
        const originalEnv = process.env;
        beforeEach(() => {
            process.env = { ...originalEnv };
        });
        afterEach(() => {
            process.env = originalEnv;
        });
        it('should create validator from environment variables', () => {
            process.env.HMAC_SECRET = 'env-secret';
            process.env.HMAC_ALGORITHM = 'sha512';
            process.env.HMAC_HEADER_NAME = 'x-custom-signature';
            process.env.HMAC_TIMESTAMP_TOLERANCE = '600';
            const envValidator = HMACValidator_1.HMACValidator.fromEnvironment();
            const config = envValidator.getConfig();
            expect(config.algorithm).toBe('sha512');
            expect(config.headerName).toBe('x-custom-signature');
            expect(config.timestampTolerance).toBe(600);
        });
        it('should throw error if HMAC_SECRET is missing', () => {
            delete process.env.HMAC_SECRET;
            expect(() => HMACValidator_1.HMACValidator.fromEnvironment()).toThrow('HMAC_SECRET environment variable is required');
        });
        it('should use defaults for missing optional environment variables', () => {
            process.env.HMAC_SECRET = 'env-secret';
            const envValidator = HMACValidator_1.HMACValidator.fromEnvironment();
            const config = envValidator.getConfig();
            expect(config.algorithm).toBe('sha256');
            expect(config.headerName).toBe('x-signature');
            expect(config.timestampTolerance).toBe(300);
        });
    });
    describe('generateSignature', () => {
        it('should generate correct signature without timestamp', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            const expectedSignature = (0, crypto_1.createHmac)('sha256', testSecret)
                .update(payload, 'utf8')
                .digest('hex');
            expect(signature).toBe(expectedSignature);
        });
        it('should generate correct signature with timestamp', () => {
            const payload = 'test payload';
            const timestamp = 1234567890;
            const signature = validator.generateSignature(payload, timestamp);
            const expectedSignature = (0, crypto_1.createHmac)('sha256', testSecret)
                .update(`${timestamp}.${payload}`, 'utf8')
                .digest('hex');
            expect(signature).toBe(expectedSignature);
        });
    });
    describe('validateRequest', () => {
        it('should validate correct signature with timestamp', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            const headers = {
                'x-signature': signature,
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
            expect(result.error).toBeUndefined();
            expect(result.timestamp).toBe(timestamp);
        });
        it('should reject missing signature header', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const headers = {
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Missing x-signature header');
        });
        it('should reject missing timestamp header when required', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            const headers = {
                'x-signature': signature
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Missing x-timestamp header');
        });
        it('should reject invalid timestamp format', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            const headers = {
                'x-signature': signature,
                'x-timestamp': 'invalid-timestamp'
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Invalid timestamp format');
        });
        it('should reject old timestamps', () => {
            const payload = 'test payload';
            const oldTimestamp = Math.floor(Date.now() / 1000) - 600; // 10 minutes ago
            const signature = validator.generateSignature(payload, oldTimestamp);
            const headers = {
                'x-signature': signature,
                'x-timestamp': oldTimestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toContain('Timestamp too old');
        });
        it('should reject future timestamps', () => {
            const payload = 'test payload';
            const futureTimestamp = Math.floor(Date.now() / 1000) + 600; // 10 minutes in future
            const signature = validator.generateSignature(payload, futureTimestamp);
            const headers = {
                'x-signature': signature,
                'x-timestamp': futureTimestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toContain('too far in future');
        });
        it('should reject invalid signature format', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const headers = {
                'x-signature': 'invalid-signature-format!@#',
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Invalid signature format');
        });
        it('should reject incorrect signature', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const wrongSignature = (0, crypto_1.createHmac)('sha256', 'wrong-secret')
                .update(`${timestamp}.${payload}`, 'utf8')
                .digest('hex');
            const headers = {
                'x-signature': wrongSignature,
                'x-timestamp': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(false);
            expect(result.error).toBe('Invalid signature');
        });
        it('should handle case-insensitive headers', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            const headers = {
                'X-SIGNATURE': signature,
                'X-TIMESTAMP': timestamp.toString()
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
        it('should handle array header values', () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            const headers = {
                'x-signature': [signature, 'other-value'],
                'x-timestamp': [timestamp.toString()]
            };
            const result = validator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
        it('should work without timestamp when not required', () => {
            const noTimestampValidator = new HMACValidator_1.HMACValidator({
                secret: testSecret,
                requireTimestamp: false
            });
            const payload = 'test payload';
            const signature = noTimestampValidator.generateSignature(payload);
            const headers = {
                'x-signature': signature
            };
            const result = noTimestampValidator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
    });
    describe('createHeaders', () => {
        it('should create headers with timestamp', () => {
            const payload = 'test payload';
            const headers = validator.createHeaders(payload, true);
            expect(headers['x-signature']).toBeDefined();
            expect(headers['x-timestamp']).toBeDefined();
            // Verify signature is correct
            const timestamp = parseInt(headers['x-timestamp']);
            const expectedSignature = validator.generateSignature(payload, timestamp);
            expect(headers['x-signature']).toBe(expectedSignature);
        });
        it('should create headers without timestamp', () => {
            const payload = 'test payload';
            const headers = validator.createHeaders(payload, false);
            expect(headers['x-signature']).toBeDefined();
            expect(headers['x-timestamp']).toBeUndefined();
            // Verify signature is correct
            const expectedSignature = validator.generateSignature(payload);
            expect(headers['x-signature']).toBe(expectedSignature);
        });
    });
    describe('utility methods', () => {
        it('should check if enabled', () => {
            expect(validator.isEnabled()).toBe(true);
            // Test the isEnabled method logic directly
            const testValidator = new HMACValidator_1.HMACValidator({ secret: 'test-secret' });
            expect(testValidator.isEnabled()).toBe(true);
            // We can't test with empty secret since constructor throws error
            // This is the correct behavior - empty secret should not be allowed
        });
        it('should update secret', () => {
            const newSecret = 'new-secret';
            validator.updateSecret(newSecret);
            // Test with new secret
            const payload = 'test payload';
            const signature = (0, crypto_1.createHmac)('sha256', newSecret)
                .update(payload, 'utf8')
                .digest('hex');
            const headers = { 'x-signature': signature };
            const noTimestampValidator = new HMACValidator_1.HMACValidator({
                secret: newSecret,
                requireTimestamp: false
            });
            const result = noTimestampValidator.validateRequest(payload, headers);
            expect(result.valid).toBe(true);
        });
        it('should throw error when updating to empty secret', () => {
            expect(() => validator.updateSecret('')).toThrow('HMAC secret cannot be empty');
        });
        it('should test signature validation', () => {
            const payload = 'test payload';
            const signature = validator.generateSignature(payload);
            expect(validator.test(payload, signature)).toBe(true);
            expect(validator.test(payload, 'wrong-signature')).toBe(false);
        });
    });
    describe('createHMACMiddleware', () => {
        let mockRequest;
        let mockReply;
        beforeEach(() => {
            mockRequest = {
                url: '/test',
                ip: '127.0.0.1',
                headers: {},
                rawBody: '',
                body: {}
            };
            mockReply = {
                status: jest.fn().mockReturnThis(),
                send: jest.fn()
            };
        });
        it('should skip validation for health endpoints', async () => {
            mockRequest.url = '/health';
            const middleware = (0, HMACValidator_1.createHMACMiddleware)(validator);
            await middleware(mockRequest, mockReply);
            expect(mockReply.status).not.toHaveBeenCalled();
        });
        it('should validate HMAC signature', async () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const signature = validator.generateSignature(payload, timestamp);
            mockRequest.rawBody = payload;
            mockRequest.headers = {
                'x-signature': signature,
                'x-timestamp': timestamp.toString()
            };
            const middleware = (0, HMACValidator_1.createHMACMiddleware)(validator);
            await middleware(mockRequest, mockReply);
            expect(mockReply.status).not.toHaveBeenCalled();
            expect(mockRequest.hmacValidation).toBeDefined();
            expect(mockRequest.hmacValidation.valid).toBe(true);
        });
        it('should reject invalid HMAC signature', async () => {
            const payload = 'test payload';
            mockRequest.rawBody = payload;
            mockRequest.headers = {
                'x-signature': 'invalid-signature'
            };
            const middleware = (0, HMACValidator_1.createHMACMiddleware)(validator);
            await middleware(mockRequest, mockReply);
            expect(mockReply.status).toHaveBeenCalledWith(401);
            expect(mockReply.send).toHaveBeenCalledWith({
                error: 'Unauthorized',
                message: expect.any(String),
                timestamp: expect.any(String)
            });
        });
    });
    describe('defaults', () => {
        it('should have correct default configurations', () => {
            expect(HMACValidator_1.HMACDefaults.development).toEqual({
                algorithm: 'sha256',
                timestampTolerance: 600,
                requireTimestamp: false
            });
            expect(HMACValidator_1.HMACDefaults.production).toEqual({
                algorithm: 'sha512',
                timestampTolerance: 300,
                requireTimestamp: true
            });
            expect(HMACValidator_1.HMACDefaults.test).toEqual({
                algorithm: 'sha256',
                timestampTolerance: 3600,
                requireTimestamp: false
            });
        });
    });
    describe('timing attack protection', () => {
        it('should take similar time for valid and invalid signatures', async () => {
            const payload = 'test payload';
            const timestamp = Math.floor(Date.now() / 1000);
            const validSignature = validator.generateSignature(payload, timestamp);
            const invalidSignature = 'a'.repeat(validSignature.length);
            const validHeaders = {
                'x-signature': validSignature,
                'x-timestamp': timestamp.toString()
            };
            const invalidHeaders = {
                'x-signature': invalidSignature,
                'x-timestamp': timestamp.toString()
            };
            // Measure time for valid signature
            const validStart = Date.now();
            validator.validateRequest(payload, validHeaders);
            const validTime = Date.now() - validStart;
            // Measure time for invalid signature
            const invalidStart = Date.now();
            validator.validateRequest(payload, invalidHeaders);
            const invalidTime = Date.now() - invalidStart;
            // Times should be similar (within reasonable margin)
            const timeDifference = Math.abs(validTime - invalidTime);
            expect(timeDifference).toBeLessThan(50); // 50ms tolerance
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3NlY3VyaXR5L0hNQUNWYWxpZGF0b3IudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7R0FJRzs7QUFNSCxjQUFjO0FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0FBTHRDLG9FQUFxRztBQUNyRyxxREFBa0Q7QUFDbEQsbUNBQW9DO0FBSXBDLE1BQU0sVUFBVSxHQUFHO0lBQ2pCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtJQUNoQixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUNWLENBQUM7QUFFVCxRQUFRLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRTtJQUM3QixJQUFJLFNBQXdCLENBQUM7SUFDN0IsTUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUM7SUFFckMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNwQixlQUFNLENBQUMsV0FBeUIsQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFOUQsU0FBUyxHQUFHLElBQUksNkJBQWEsQ0FBQztZQUM1QixNQUFNLEVBQUUsVUFBVTtZQUNsQixTQUFTLEVBQUUsUUFBUTtZQUNuQixVQUFVLEVBQUUsYUFBYTtZQUN6QixtQkFBbUIsRUFBRSxhQUFhO1lBQ2xDLGtCQUFrQixFQUFFLEdBQUc7WUFDdkIsZ0JBQWdCLEVBQUUsSUFBSTtTQUN2QixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxhQUFhLEVBQUUsR0FBRyxFQUFFO1FBQzNCLEVBQUUsQ0FBQyw4Q0FBOEMsRUFBRSxHQUFHLEVBQUU7WUFDdEQsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLFNBQVMsRUFB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dmljZXMvdGl0YW4tYnJhaW4vdGVzdHMvc2VjdXJpdHkvSE1BQ1ZhbGlkYXRvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSE1BQ1ZhbGlkYXRvciBUZXN0c1xuICogXG4gKiBDb21wcmVoZW5zaXZlIHVuaXQgdGVzdHMgZm9yIHRoZSBITUFDVmFsaWRhdG9yIGNsYXNzXG4gKi9cblxuaW1wb3J0IHsgSE1BQ1ZhbGlkYXRvciwgSE1BQ0RlZmF1bHRzLCBjcmVhdGVITUFDTWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL3NyYy9zZWN1cml0eS9ITUFDVmFsaWRhdG9yJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uLy4uL3NyYy9sb2dnaW5nL0xvZ2dlcic7XG5pbXBvcnQgeyBjcmVhdGVIbWFjIH0gZnJvbSAnY3J5cHRvJztcblxuLy8gTW9jayBMb2dnZXJcbmplc3QubW9jaygnLi4vLi4vc3JjL2xvZ2dpbmcvTG9nZ2VyJyk7XG5jb25zdCBtb2NrTG9nZ2VyID0ge1xuICBpbmZvOiBqZXN0LmZuKCksXG4gIHdhcm46IGplc3QuZm4oKSxcbiAgZXJyb3I6IGplc3QuZm4oKSxcbiAgZGVidWc6IGplc3QuZm4oKVxufSBhcyBhbnk7XG5cbmRlc2NyaWJlKCdITUFDVmFsaWRhdG9yJywgKCkgPT4ge1xuICBsZXQgdmFsaWRhdG9yOiBITUFDVmFsaWRhdG9yO1xuICBjb25zdCB0ZXN0U2VjcmV0ID0gJ3Rlc3Qtc2VjcmV0LWtleSc7XG4gIFxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAoTG9nZ2VyLmdldEluc3RhbmNlIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKG1vY2tMb2dnZXIpO1xuICAgIFxuICAgIHZhbGlkYXRvciA9IG5ldyBITUFDVmFsaWRhdG9yKHtcbiAgICAgIHNlY3JldDogdGVzdFNlY3JldCxcbiAgICAgIGFsZ29yaXRobTogJ3NoYTI1NicsXG4gICAgICBoZWFkZXJOYW1lOiAneC1zaWduYXR1cmUnLFxuICAgICAgdGltZXN0YW1wSGVhZGVyTmFtZTogJ3gtdGltZXN0YW1wJyxcbiAgICAgIHRpbWVzdGFtcFRvbGVyYW5jZTogMzAwLFxuICAgICAgcmVxdWlyZVRpbWVzdGFtcDogdHJ1ZVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY29uc3RydWN0b3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHdpdGggY29ycmVjdCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0gdmFsaWRhdG9yLmdldENvbmZpZygpO1xuICAgICAgXG4gICAgICBleHBlY3QoY29uZmlnLmFsZ29yaXRobSkudG9CZSgnc2hhMjU2Jyk7XG4gICAgICBleHBlY3QoY29uZmlnLmhlYWRlck5hbWUpLnRvQmUoJ3gtc2lnbmF0dXJlJyk7XG4gICAgICBleHBlY3QoY29uZmlnLnRpbWVzdGFtcEhlYWRlck5hbWUpLnRvQmUoJ3gtdGltZXN0YW1wJyk7XG4gICAgICBleHBlY3QoY29uZmlnLnRpbWVzdGFtcFRvbGVyYW5jZSkudG9CZSgzMDApO1xuICAgICAgZXhwZWN0KGNvbmZpZy5yZXF1aXJlVGltZXN0YW1wKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBlcnJvciBpZiBzZWNyZXQgaXMgbWlzc2luZycsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiBuZXcgSE1BQ1ZhbGlkYXRvcih7IHNlY3JldDogJycgfSkpLnRvVGhyb3coJ0hNQUMgc2VjcmV0IGlzIHJlcXVpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyBpbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnSE1BQyB2YWxpZGF0b3IgaW5pdGlhbGl6ZWQnLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgICAgICAgIGhlYWRlck5hbWU6ICd4LXNpZ25hdHVyZScsXG4gICAgICAgICAgdGltZXN0YW1wSGVhZGVyTmFtZTogJ3gtdGltZXN0YW1wJyxcbiAgICAgICAgICB0aW1lc3RhbXBUb2xlcmFuY2U6IDMwMCxcbiAgICAgICAgICByZXF1aXJlVGltZXN0YW1wOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZnJvbUVudmlyb25tZW50JywgKCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsRW52ID0gcHJvY2Vzcy5lbnY7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHByb2Nlc3MuZW52ID0geyAuLi5vcmlnaW5hbEVudiB9O1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIHByb2Nlc3MuZW52ID0gb3JpZ2luYWxFbnY7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSB2YWxpZGF0b3IgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMnLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5ITUFDX1NFQ1JFVCA9ICdlbnYtc2VjcmV0JztcbiAgICAgIHByb2Nlc3MuZW52LkhNQUNfQUxHT1JJVEhNID0gJ3NoYTUxMic7XG4gICAgICBwcm9jZXNzLmVudi5ITUFDX0hFQURFUl9OQU1FID0gJ3gtY3VzdG9tLXNpZ25hdHVyZSc7XG4gICAgICBwcm9jZXNzLmVudi5ITUFDX1RJTUVTVEFNUF9UT0xFUkFOQ0UgPSAnNjAwJztcblxuICAgICAgY29uc3QgZW52VmFsaWRhdG9yID0gSE1BQ1ZhbGlkYXRvci5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGVudlZhbGlkYXRvci5nZXRDb25maWcoKTtcblxuICAgICAgZXhwZWN0KGNvbmZpZy5hbGdvcml0aG0pLnRvQmUoJ3NoYTUxMicpO1xuICAgICAgZXhwZWN0KGNvbmZpZy5oZWFkZXJOYW1lKS50b0JlKCd4LWN1c3RvbS1zaWduYXR1cmUnKTtcbiAgICAgIGV4cGVjdChjb25maWcudGltZXN0YW1wVG9sZXJhbmNlKS50b0JlKDYwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGlmIEhNQUNfU0VDUkVUIGlzIG1pc3NpbmcnLCAoKSA9PiB7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSE1BQ19TRUNSRVQ7XG4gICAgICBcbiAgICAgIGV4cGVjdCgoKSA9PiBITUFDVmFsaWRhdG9yLmZyb21FbnZpcm9ubWVudCgpKS50b1Rocm93KCdITUFDX1NFQ1JFVCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdHMgZm9yIG1pc3Npbmcgb3B0aW9uYWwgZW52aXJvbm1lbnQgdmFyaWFibGVzJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuSE1BQ19TRUNSRVQgPSAnZW52LXNlY3JldCc7XG4gICAgICBcbiAgICAgIGNvbnN0IGVudlZhbGlkYXRvciA9IEhNQUNWYWxpZGF0b3IuZnJvbUVudmlyb25tZW50KCk7XG4gICAgICBjb25zdCBjb25maWcgPSBlbnZWYWxpZGF0b3IuZ2V0Q29uZmlnKCk7XG5cbiAgICAgIGV4cGVjdChjb25maWcuYWxnb3JpdGhtKS50b0JlKCdzaGEyNTYnKTtcbiAgICAgIGV4cGVjdChjb25maWcuaGVhZGVyTmFtZSkudG9CZSgneC1zaWduYXR1cmUnKTtcbiAgICAgIGV4cGVjdChjb25maWcudGltZXN0YW1wVG9sZXJhbmNlKS50b0JlKDMwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZW5lcmF0ZVNpZ25hdHVyZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGNvcnJlY3Qgc2lnbmF0dXJlIHdpdGhvdXQgdGltZXN0YW1wJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQpO1xuICAgICAgXG4gICAgICBjb25zdCBleHBlY3RlZFNpZ25hdHVyZSA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIHRlc3RTZWNyZXQpXG4gICAgICAgIC51cGRhdGUocGF5bG9hZCwgJ3V0ZjgnKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHNpZ25hdHVyZSkudG9CZShleHBlY3RlZFNpZ25hdHVyZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGNvcnJlY3Qgc2lnbmF0dXJlIHdpdGggdGltZXN0YW1wJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gMTIzNDU2Nzg5MDtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXApO1xuICAgICAgXG4gICAgICBjb25zdCBleHBlY3RlZFNpZ25hdHVyZSA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIHRlc3RTZWNyZXQpXG4gICAgICAgIC51cGRhdGUoYCR7dGltZXN0YW1wfS4ke3BheWxvYWR9YCwgJ3V0ZjgnKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHNpZ25hdHVyZSkudG9CZShleHBlY3RlZFNpZ25hdHVyZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd2YWxpZGF0ZVJlcXVlc3QnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBjb3JyZWN0IHNpZ25hdHVyZSB3aXRoIHRpbWVzdGFtcCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQsIHRpbWVzdGFtcCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgJ3gtdGltZXN0YW1wJzogdGltZXN0YW1wLnRvU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZVJlcXVlc3QocGF5bG9hZCwgaGVhZGVycyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0LnRpbWVzdGFtcCkudG9CZSh0aW1lc3RhbXApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgbWlzc2luZyBzaWduYXR1cmUgaGVhZGVyJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXRpbWVzdGFtcCc6IHRpbWVzdGFtcC50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoJ01pc3NpbmcgeC1zaWduYXR1cmUgaGVhZGVyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBtaXNzaW5nIHRpbWVzdGFtcCBoZWFkZXIgd2hlbiByZXF1aXJlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbmF0dXJlXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoJ01pc3NpbmcgeC10aW1lc3RhbXAgaGVhZGVyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIHRpbWVzdGFtcCBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgJ3gtdGltZXN0YW1wJzogJ2ludmFsaWQtdGltZXN0YW1wJ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdJbnZhbGlkIHRpbWVzdGFtcCBmb3JtYXQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IG9sZCB0aW1lc3RhbXBzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3Qgb2xkVGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgLSA2MDA7IC8vIDEwIG1pbnV0ZXMgYWdvXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCwgb2xkVGltZXN0YW1wKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbmF0dXJlLFxuICAgICAgICAneC10aW1lc3RhbXAnOiBvbGRUaW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oJ1RpbWVzdGFtcCB0b28gb2xkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBmdXR1cmUgdGltZXN0YW1wcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IGZ1dHVyZVRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgNjAwOyAvLyAxMCBtaW51dGVzIGluIGZ1dHVyZVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQsIGZ1dHVyZVRpbWVzdGFtcCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgJ3gtdGltZXN0YW1wJzogZnV0dXJlVGltZXN0YW1wLnRvU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZVJlcXVlc3QocGF5bG9hZCwgaGVhZGVycyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCd0b28gZmFyIGluIGZ1dHVyZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBzaWduYXR1cmUgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6ICdpbnZhbGlkLXNpZ25hdHVyZS1mb3JtYXQhQCMnLFxuICAgICAgICAneC10aW1lc3RhbXAnOiB0aW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlUmVxdWVzdChwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdJbnZhbGlkIHNpZ25hdHVyZSBmb3JtYXQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGluY29ycmVjdCBzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIGNvbnN0IHdyb25nU2lnbmF0dXJlID0gY3JlYXRlSG1hYygnc2hhMjU2JywgJ3dyb25nLXNlY3JldCcpXG4gICAgICAgIC51cGRhdGUoYCR7dGltZXN0YW1wfS4ke3BheWxvYWR9YCwgJ3V0ZjgnKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ3gtc2lnbmF0dXJlJzogd3JvbmdTaWduYXR1cmUsXG4gICAgICAgICd4LXRpbWVzdGFtcCc6IHRpbWVzdGFtcC50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXApO1xuICAgICAgXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAnWC1TSUdOQVRVUkUnOiBzaWduYXR1cmUsXG4gICAgICAgICdYLVRJTUVTVEFNUCc6IHRpbWVzdGFtcC50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXJyYXkgaGVhZGVyIHZhbHVlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQsIHRpbWVzdGFtcCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IFtzaWduYXR1cmUsICdvdGhlci12YWx1ZSddLFxuICAgICAgICAneC10aW1lc3RhbXAnOiBbdGltZXN0YW1wLnRvU3RyaW5nKCldXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB3b3JrIHdpdGhvdXQgdGltZXN0YW1wIHdoZW4gbm90IHJlcXVpcmVkJywgKCkgPT4ge1xuICAgICAgY29uc3Qgbm9UaW1lc3RhbXBWYWxpZGF0b3IgPSBuZXcgSE1BQ1ZhbGlkYXRvcih7XG4gICAgICAgIHNlY3JldDogdGVzdFNlY3JldCxcbiAgICAgICAgcmVxdWlyZVRpbWVzdGFtcDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBub1RpbWVzdGFtcFZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbmF0dXJlXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBub1RpbWVzdGFtcFZhbGlkYXRvci52YWxpZGF0ZVJlcXVlc3QocGF5bG9hZCwgaGVhZGVycyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjcmVhdGVIZWFkZXJzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIGhlYWRlcnMgd2l0aCB0aW1lc3RhbXAnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCBoZWFkZXJzID0gdmFsaWRhdG9yLmNyZWF0ZUhlYWRlcnMocGF5bG9hZCwgdHJ1ZSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChoZWFkZXJzWyd4LXNpZ25hdHVyZSddKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGhlYWRlcnNbJ3gtdGltZXN0YW1wJ10pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBzaWduYXR1cmUgaXMgY29ycmVjdFxuICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQoaGVhZGVyc1sneC10aW1lc3RhbXAnXSk7XG4gICAgICBjb25zdCBleHBlY3RlZFNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkLCB0aW1lc3RhbXApO1xuICAgICAgZXhwZWN0KGhlYWRlcnNbJ3gtc2lnbmF0dXJlJ10pLnRvQmUoZXhwZWN0ZWRTaWduYXR1cmUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgaGVhZGVycyB3aXRob3V0IHRpbWVzdGFtcCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB2YWxpZGF0b3IuY3JlYXRlSGVhZGVycyhwYXlsb2FkLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChoZWFkZXJzWyd4LXNpZ25hdHVyZSddKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGhlYWRlcnNbJ3gtdGltZXN0YW1wJ10pLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHNpZ25hdHVyZSBpcyBjb3JyZWN0XG4gICAgICBjb25zdCBleHBlY3RlZFNpZ25hdHVyZSA9IHZhbGlkYXRvci5nZW5lcmF0ZVNpZ25hdHVyZShwYXlsb2FkKTtcbiAgICAgIGV4cGVjdChoZWFkZXJzWyd4LXNpZ25hdHVyZSddKS50b0JlKGV4cGVjdGVkU2lnbmF0dXJlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3V0aWxpdHkgbWV0aG9kcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNoZWNrIGlmIGVuYWJsZWQnLCAoKSA9PiB7XG4gICAgICBleHBlY3QodmFsaWRhdG9yLmlzRW5hYmxlZCgpKS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHRoZSBpc0VuYWJsZWQgbWV0aG9kIGxvZ2ljIGRpcmVjdGx5XG4gICAgICBjb25zdCB0ZXN0VmFsaWRhdG9yID0gbmV3IEhNQUNWYWxpZGF0b3IoeyBzZWNyZXQ6ICd0ZXN0LXNlY3JldCcgfSk7XG4gICAgICBleHBlY3QodGVzdFZhbGlkYXRvci5pc0VuYWJsZWQoKSkudG9CZSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gV2UgY2FuJ3QgdGVzdCB3aXRoIGVtcHR5IHNlY3JldCBzaW5jZSBjb25zdHJ1Y3RvciB0aHJvd3MgZXJyb3JcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGNvcnJlY3QgYmVoYXZpb3IgLSBlbXB0eSBzZWNyZXQgc2hvdWxkIG5vdCBiZSBhbGxvd2VkXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBzZWNyZXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBuZXdTZWNyZXQgPSAnbmV3LXNlY3JldCc7XG4gICAgICB2YWxpZGF0b3IudXBkYXRlU2VjcmV0KG5ld1NlY3JldCk7XG4gICAgICBcbiAgICAgIC8vIFRlc3Qgd2l0aCBuZXcgc2VjcmV0XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBuZXdTZWNyZXQpXG4gICAgICAgIC51cGRhdGUocGF5bG9hZCwgJ3V0ZjgnKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGVhZGVycyA9IHsgJ3gtc2lnbmF0dXJlJzogc2lnbmF0dXJlIH07XG4gICAgICBjb25zdCBub1RpbWVzdGFtcFZhbGlkYXRvciA9IG5ldyBITUFDVmFsaWRhdG9yKHtcbiAgICAgICAgc2VjcmV0OiBuZXdTZWNyZXQsXG4gICAgICAgIHJlcXVpcmVUaW1lc3RhbXA6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gbm9UaW1lc3RhbXBWYWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIGhlYWRlcnMpO1xuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgZXJyb3Igd2hlbiB1cGRhdGluZyB0byBlbXB0eSBzZWNyZXQnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4gdmFsaWRhdG9yLnVwZGF0ZVNlY3JldCgnJykpLnRvVGhyb3coJ0hNQUMgc2VjcmV0IGNhbm5vdCBiZSBlbXB0eScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0ZXN0IHNpZ25hdHVyZSB2YWxpZGF0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQpO1xuICAgICAgXG4gICAgICBleHBlY3QodmFsaWRhdG9yLnRlc3QocGF5bG9hZCwgc2lnbmF0dXJlKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0b3IudGVzdChwYXlsb2FkLCAnd3Jvbmctc2lnbmF0dXJlJykpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY3JlYXRlSE1BQ01pZGRsZXdhcmUnLCAoKSA9PiB7XG4gICAgbGV0IG1vY2tSZXF1ZXN0OiBhbnk7XG4gICAgbGV0IG1vY2tSZXBseTogYW55O1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgdXJsOiAnL3Rlc3QnLFxuICAgICAgICBpcDogJzEyNy4wLjAuMScsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICByYXdCb2R5OiAnJyxcbiAgICAgICAgYm9keToge31cbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tSZXBseSA9IHtcbiAgICAgICAgc3RhdHVzOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICAgICAgc2VuZDogamVzdC5mbigpXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBza2lwIHZhbGlkYXRpb24gZm9yIGhlYWx0aCBlbmRwb2ludHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrUmVxdWVzdC51cmwgPSAnL2hlYWx0aCc7XG4gICAgICBcbiAgICAgIGNvbnN0IG1pZGRsZXdhcmUgPSBjcmVhdGVITUFDTWlkZGxld2FyZSh2YWxpZGF0b3IpO1xuICAgICAgYXdhaXQgbWlkZGxld2FyZShtb2NrUmVxdWVzdCwgbW9ja1JlcGx5KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tSZXBseS5zdGF0dXMpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIEhNQUMgc2lnbmF0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9ICd0ZXN0IHBheWxvYWQnO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSB2YWxpZGF0b3IuZ2VuZXJhdGVTaWduYXR1cmUocGF5bG9hZCwgdGltZXN0YW1wKTtcbiAgICAgIFxuICAgICAgbW9ja1JlcXVlc3QucmF3Qm9keSA9IHBheWxvYWQ7XG4gICAgICBtb2NrUmVxdWVzdC5oZWFkZXJzID0ge1xuICAgICAgICAneC1zaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICd4LXRpbWVzdGFtcCc6IHRpbWVzdGFtcC50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBtaWRkbGV3YXJlID0gY3JlYXRlSE1BQ01pZGRsZXdhcmUodmFsaWRhdG9yKTtcbiAgICAgIGF3YWl0IG1pZGRsZXdhcmUobW9ja1JlcXVlc3QsIG1vY2tSZXBseSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrUmVwbHkuc3RhdHVzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tSZXF1ZXN0LmhtYWNWYWxpZGF0aW9uKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG1vY2tSZXF1ZXN0LmhtYWNWYWxpZGF0aW9uLnZhbGlkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBITUFDIHNpZ25hdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSAndGVzdCBwYXlsb2FkJztcbiAgICAgIG1vY2tSZXF1ZXN0LnJhd0JvZHkgPSBwYXlsb2FkO1xuICAgICAgbW9ja1JlcXVlc3QuaGVhZGVycyA9IHtcbiAgICAgICAgJ3gtc2lnbmF0dXJlJzogJ2ludmFsaWQtc2lnbmF0dXJlJ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbWlkZGxld2FyZSA9IGNyZWF0ZUhNQUNNaWRkbGV3YXJlKHZhbGlkYXRvcik7XG4gICAgICBhd2FpdCBtaWRkbGV3YXJlKG1vY2tSZXF1ZXN0LCBtb2NrUmVwbHkpO1xuICAgICAgXG4gICAgICBleHBlY3QobW9ja1JlcGx5LnN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNDAxKTtcbiAgICAgIGV4cGVjdChtb2NrUmVwbHkuc2VuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBlcnJvcjogJ1VuYXV0aG9yaXplZCcsXG4gICAgICAgIG1lc3NhZ2U6IGV4cGVjdC5hbnkoU3RyaW5nKSxcbiAgICAgICAgdGltZXN0YW1wOiBleHBlY3QuYW55KFN0cmluZylcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGVmYXVsdHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYXZlIGNvcnJlY3QgZGVmYXVsdCBjb25maWd1cmF0aW9ucycsICgpID0+IHtcbiAgICAgIGV4cGVjdChITUFDRGVmYXVsdHMuZGV2ZWxvcG1lbnQpLnRvRXF1YWwoe1xuICAgICAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgICAgICB0aW1lc3RhbXBUb2xlcmFuY2U6IDYwMCxcbiAgICAgICAgcmVxdWlyZVRpbWVzdGFtcDogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoSE1BQ0RlZmF1bHRzLnByb2R1Y3Rpb24pLnRvRXF1YWwoe1xuICAgICAgICBhbGdvcml0aG06ICdzaGE1MTInLFxuICAgICAgICB0aW1lc3RhbXBUb2xlcmFuY2U6IDMwMCxcbiAgICAgICAgcmVxdWlyZVRpbWVzdGFtcDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChITUFDRGVmYXVsdHMudGVzdCkudG9FcXVhbCh7XG4gICAgICAgIGFsZ29yaXRobTogJ3NoYTI1NicsXG4gICAgICAgIHRpbWVzdGFtcFRvbGVyYW5jZTogMzYwMCxcbiAgICAgICAgcmVxdWlyZVRpbWVzdGFtcDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndGltaW5nIGF0dGFjayBwcm90ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdGFrZSBzaW1pbGFyIHRpbWUgZm9yIHZhbGlkIGFuZCBpbnZhbGlkIHNpZ25hdHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gJ3Rlc3QgcGF5bG9hZCc7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIGNvbnN0IHZhbGlkU2lnbmF0dXJlID0gdmFsaWRhdG9yLmdlbmVyYXRlU2lnbmF0dXJlKHBheWxvYWQsIHRpbWVzdGFtcCk7XG4gICAgICBjb25zdCBpbnZhbGlkU2lnbmF0dXJlID0gJ2EnLnJlcGVhdCh2YWxpZFNpZ25hdHVyZS5sZW5ndGgpO1xuICAgICAgXG4gICAgICBjb25zdCB2YWxpZEhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IHZhbGlkU2lnbmF0dXJlLFxuICAgICAgICAneC10aW1lc3RhbXAnOiB0aW1lc3RhbXAudG9TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgaW52YWxpZEhlYWRlcnMgPSB7XG4gICAgICAgICd4LXNpZ25hdHVyZSc6IGludmFsaWRTaWduYXR1cmUsXG4gICAgICAgICd4LXRpbWVzdGFtcCc6IHRpbWVzdGFtcC50b1N0cmluZygpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIHRpbWUgZm9yIHZhbGlkIHNpZ25hdHVyZVxuICAgICAgY29uc3QgdmFsaWRTdGFydCA9IERhdGUubm93KCk7XG4gICAgICB2YWxpZGF0b3IudmFsaWRhdGVSZXF1ZXN0KHBheWxvYWQsIHZhbGlkSGVhZGVycyk7XG4gICAgICBjb25zdCB2YWxpZFRpbWUgPSBEYXRlLm5vdygpIC0gdmFsaWRTdGFydDtcbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSB0aW1lIGZvciBpbnZhbGlkIHNpZ25hdHVyZVxuICAgICAgY29uc3QgaW52YWxpZFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHZhbGlkYXRvci52YWxpZGF0ZVJlcXVlc3QocGF5bG9hZCwgaW52YWxpZEhlYWRlcnMpO1xuICAgICAgY29uc3QgaW52YWxpZFRpbWUgPSBEYXRlLm5vdygpIC0gaW52YWxpZFN0YXJ0O1xuICAgICAgXG4gICAgICAvLyBUaW1lcyBzaG91bGQgYmUgc2ltaWxhciAod2l0aGluIHJlYXNvbmFibGUgbWFyZ2luKVxuICAgICAgY29uc3QgdGltZURpZmZlcmVuY2UgPSBNYXRoLmFicyh2YWxpZFRpbWUgLSBpbnZhbGlkVGltZSk7XG4gICAgICBleHBlY3QodGltZURpZmZlcmVuY2UpLnRvQmVMZXNzVGhhbig1MCk7IC8vIDUwbXMgdG9sZXJhbmNlXG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9