{"file":"/Users/ivan/Code/trading/titan/services/titan-brain/tests/property/RiskGuardian.property.test.ts","mappings":"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","names":[],"sources":["/Users/ivan/Code/trading/titan/services/titan-brain/tests/property/RiskGuardian.property.test.ts"],"sourcesContent":["/**\n * Property-Based Tests for RiskGuardian\n * \n * Tests universal properties that should hold across all inputs\n */\n\nimport * as fc from 'fast-check';\nimport { RiskGuardian } from '../../src/engine/RiskGuardian';\nimport { AllocationEngine } from '../../src/engine/AllocationEngine';\nimport { \n  RiskGuardianConfig, \n  AllocationEngineConfig, \n  IntentSignal, \n  Position,\n  PhaseId,\n  EquityTier\n} from '../../src/types/index';\n\n// Test configurations\nconst allocationConfig: AllocationEngineConfig = {\n  transitionPoints: {\n    startP2: 1500,\n    fullP2: 5000,\n    startP3: 25000\n  },\n  leverageCaps: {\n    [EquityTier.MICRO]: 20,\n    [EquityTier.SMALL]: 20,\n    [EquityTier.MEDIUM]: 5,\n    [EquityTier.LARGE]: 5,\n    [EquityTier.INSTITUTIONAL]: 2\n  }\n};\n\nconst riskConfig: RiskGuardianConfig = {\n  maxCorrelation: 0.8,\n  correlationPenalty: 0.5,\n  correlationUpdateInterval: 300000, // 5 minutes\n  betaUpdateInterval: 300000 // 5 minutes\n};\n\ndescribe('RiskGuardian Property Tests', () => {\n  let allocationEngine: AllocationEngine;\n  let riskGuardian: RiskGuardian;\n\n  beforeEach(() => {\n    allocationEngine = new AllocationEngine(allocationConfig);\n    riskGuardian = new RiskGuardian(riskConfig, allocationEngine);\n  });\n\n  describe('Property 2: Leverage Cap Enforcement', () => {\n    /**\n     * **Validates: Requirements 3.4**\n     * \n     * For any equity level and any signal, the system should never approve\n     * a signal that would result in leverage exceeding the equity-tier maximum:\n     * - $200 equity = 20x max leverage\n     * - $5,000 equity = 5x max leverage  \n     * - $50,000 equity = 2x max leverage\n     */\n    it('should never approve signals that exceed leverage caps', () => {\n      fc.assert(\n        fc.property(\n          // Generate random equity values across all tiers\n          fc.float({ min: Math.fround(200), max: Math.fround(100000), noNaN: true }),\n          // Generate random signal size\n          fc.float({ min: Math.fround(100), max: Math.fround(50000), noNaN: true }),\n          // Generate random existing positions\n          fc.array(\n            fc.record({\n              symbol: fc.constantFrom('BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'SOLUSDT'),\n              side: fc.constantFrom('LONG', 'SHORT'),\n              size: fc.float({ min: Math.fround(100), max: Math.fround(10000), noNaN: true })\n            }),\n            { maxLength: 5 }\n          ),\n          (equity, signalSize, existingPositions) => {\n            // Set up the test scenario\n            riskGuardian.setEquity(equity);\n            \n            const signal: IntentSignal = {\n              signalId: 'test-signal',\n              phaseId: 'phase1' as PhaseId,\n              symbol: 'BTCUSDT',\n              side: 'BUY',\n              requestedSize: signalSize,\n              timestamp: Date.now()\n            };\n\n            const positions: Position[] = existingPositions.map((pos, index) => ({\n              symbol: pos.symbol,\n              side: pos.side as 'LONG' | 'SHORT',\n              size: pos.size,\n              entryPrice: 50000,\n              unrealizedPnL: 0,\n              leverage: 1,\n              phaseId: 'phase1' as PhaseId\n            }));\n\n            const decision = riskGuardian.checkSignal(signal, positions);\n            \n            // Property: If signal is approved, projected leverage must not exceed cap\n            if (decision.approved) {\n              const maxLeverage = allocationEngine.getMaxLeverage(equity);\n              const projectedLeverage = decision.riskMetrics.projectedLeverage;\n              \n              expect(projectedLeverage).toBeLessThanOrEqual(maxLeverage + 0.001); // Small tolerance for floating point\n            }\n            \n            // Property: If projected leverage exceeds cap, signal must be rejected\n            const maxLeverage = allocationEngine.getMaxLeverage(equity);\n            if (decision.riskMetrics.projectedLeverage > maxLeverage) {\n              expect(decision.approved).toBe(false);\n              expect(decision.reason).toContain('Leverage cap exceeded');\n            }\n          }\n        ),\n        { numRuns: 1000 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 3.4**\n     * \n     * For any equity level, the maximum leverage should follow the tier rules:\n     * - Below $5,000: max 20x\n     * - $5,000 to $50,000: max 5x  \n     * - Above $50,000: max 2x\n     */\n    it('should enforce correct leverage caps for each equity tier', () => {\n      fc.assert(\n        fc.property(\n          fc.float({ min: Math.fround(200), max: Math.fround(200000), noNaN: true }),\n          (equity) => {\n            const maxLeverage = allocationEngine.getMaxLeverage(equity);\n            \n            // Property: Leverage caps should follow tier rules\n            if (equity < 5000) {\n              expect(maxLeverage).toBeLessThanOrEqual(20);\n            } else if (equity < 50000) {\n              expect(maxLeverage).toBeLessThanOrEqual(5);\n            } else {\n              expect(maxLeverage).toBeLessThanOrEqual(2);\n            }\n            \n            // Property: Leverage should always be positive\n            expect(maxLeverage).toBeGreaterThan(0);\n          }\n        ),\n        { numRuns: 500 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 3.4**\n     * \n     * For any signal that would result in zero or negative projected leverage,\n     * the system should handle it gracefully (not crash or give invalid results)\n     */\n    it('should handle edge cases with zero or minimal leverage gracefully', () => {\n      fc.assert(\n        fc.property(\n          fc.float({ min: Math.fround(200), max: Math.fround(10000), noNaN: true }),\n          fc.float({ min: Math.fround(1), max: Math.fround(100), noNaN: true }),\n          (equity, signalSize) => {\n            riskGuardian.setEquity(equity);\n            \n            const signal: IntentSignal = {\n              signalId: 'test-signal',\n              phaseId: 'phase1' as PhaseId,\n              symbol: 'BTCUSDT',\n              side: 'BUY',\n              requestedSize: signalSize,\n              timestamp: Date.now()\n            };\n\n            const decision = riskGuardian.checkSignal(signal, []);\n            \n            // Property: Decision should always be valid\n            expect(decision).toBeDefined();\n            expect(typeof decision.approved).toBe('boolean');\n            expect(decision.riskMetrics).toBeDefined();\n            expect(decision.riskMetrics.projectedLeverage).toBeGreaterThanOrEqual(0);\n            expect(isFinite(decision.riskMetrics.projectedLeverage)).toBe(true);\n          }\n        ),\n        { numRuns: 500 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 3.5**\n     * \n     * Phase 3 hedge positions that reduce global delta should always be approved\n     * regardless of leverage constraints\n     */\n    it('should always approve Phase 3 hedges that reduce delta regardless of leverage', () => {\n      fc.assert(\n        fc.property(\n          fc.float({ min: Math.fround(200), max: Math.fround(10000), noNaN: true }),\n          fc.float({ min: Math.fround(1000), max: Math.fround(50000), noNaN: true }),\n          fc.constantFrom('LONG', 'SHORT'),\n          (equity, existingPositionSize, existingPositionSide) => {\n            riskGuardian.setEquity(equity);\n            \n            // Create existing position that creates delta\n            const existingPosition: Position = {\n              symbol: 'BTCUSDT',\n              side: existingPositionSide as 'LONG' | 'SHORT',\n              size: existingPositionSize,\n              entryPrice: 50000,\n              unrealizedPnL: 0,\n              leverage: 1,\n              phaseId: 'phase1' as PhaseId\n            };\n\n            // Create Phase 3 signal that reduces delta (opposite direction)\n            const hedgeSignal: IntentSignal = {\n              signalId: 'hedge-signal',\n              phaseId: 'phase3' as PhaseId,\n              symbol: 'BTCUSDT',\n              side: existingPositionSide === 'LONG' ? 'SELL' : 'BUY',\n              requestedSize: existingPositionSize * 0.5, // Partial hedge\n              timestamp: Date.now()\n            };\n\n            const decision = riskGuardian.checkSignal(hedgeSignal, [existingPosition]);\n            \n            // Property: Phase 3 hedges that reduce delta should always be approved\n            expect(decision.approved).toBe(true);\n            expect(decision.reason).toContain('Phase 3 hedge approved');\n          }\n        ),\n        { numRuns: 500 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 3.4**\n     * \n     * The leverage calculation should be consistent and monotonic:\n     * - Larger position sizes should result in higher leverage (given same equity)\n     * - Higher equity should result in lower leverage (given same position size)\n     */\n    it('should have consistent and monotonic leverage calculations', () => {\n      fc.assert(\n        fc.property(\n          fc.tuple(\n            fc.float({ min: Math.fround(200), max: Math.fround(10000), noNaN: true }),\n            fc.float({ min: Math.fround(200), max: Math.fround(10000), noNaN: true })\n          ).filter(([equity1, equity2]) => Math.abs(equity1 - equity2) > 100), // Ensure meaningful difference\n          fc.float({ min: Math.fround(1000), max: Math.fround(5000), noNaN: true }),\n          ([equity1, equity2], positionSize) => {\n            const positions: Position[] = [{\n              symbol: 'BTCUSDT',\n              side: 'LONG',\n              size: positionSize,\n              entryPrice: 50000,\n              unrealizedPnL: 0,\n              leverage: 1,\n              phaseId: 'phase1' as PhaseId\n            }];\n\n            // Calculate leverage for both equity levels\n            riskGuardian.setEquity(equity1);\n            const leverage1 = riskGuardian.calculateCombinedLeverage(positions);\n            \n            riskGuardian.setEquity(equity2);\n            const leverage2 = riskGuardian.calculateCombinedLeverage(positions);\n            \n            // Property: Higher equity should result in lower leverage\n            if (equity1 > equity2) {\n              expect(leverage1).toBeLessThanOrEqual(leverage2 + 0.001); // Small tolerance\n            } else {\n              expect(leverage2).toBeLessThanOrEqual(leverage1 + 0.001);\n            }\n            \n            // Property: Both leverages should be positive and finite\n            expect(leverage1).toBeGreaterThanOrEqual(0);\n            expect(leverage2).toBeGreaterThanOrEqual(0);\n            expect(isFinite(leverage1)).toBe(true);\n            expect(isFinite(leverage2)).toBe(true);\n          }\n        ),\n        { numRuns: 500 }\n      );\n    });\n\n    /**\n     * **Validates: Requirements 3.4**\n     * \n     * When equity is zero or negative, leverage calculations should handle gracefully\n     * and not approve any new positions\n     */\n    it('should handle zero or negative equity gracefully', () => {\n      fc.assert(\n        fc.property(\n          fc.float({ min: Math.fround(-1000), max: Math.fround(0), noNaN: true }),\n          fc.float({ min: Math.fround(100), max: Math.fround(1000), noNaN: true }),\n          (equity, signalSize) => {\n            riskGuardian.setEquity(equity);\n            \n            const signal: IntentSignal = {\n              signalId: 'test-signal',\n              phaseId: 'phase1' as PhaseId,\n              symbol: 'BTCUSDT',\n              side: 'BUY',\n              requestedSize: signalSize,\n              timestamp: Date.now()\n            };\n\n            const decision = riskGuardian.checkSignal(signal, []);\n            \n            // Property: Should not crash and should provide valid decision\n            expect(decision).toBeDefined();\n            expect(typeof decision.approved).toBe('boolean');\n            \n            // Property: Leverage should be 0 when equity is 0 or negative\n            expect(decision.riskMetrics.projectedLeverage).toBe(0);\n            expect(decision.riskMetrics.currentLeverage).toBe(0);\n          }\n        ),\n        { numRuns: 200 }\n      );\n    });\n  });\n\n  describe('Portfolio Delta Calculation Properties', () => {\n    /**\n     * Property: Portfolio delta should be the sum of all position deltas\n     */\n    it('should calculate portfolio delta as sum of position deltas', () => {\n      fc.assert(\n        fc.property(\n          fc.array(\n            fc.record({\n              symbol: fc.constantFrom('BTCUSDT', 'ETHUSDT', 'ADAUSDT'),\n              side: fc.constantFrom('LONG', 'SHORT'),\n              size: fc.float({ min: Math.fround(100), max: Math.fround(5000), noNaN: true })\n            }),\n            { minLength: 1, maxLength: 10 }\n          ),\n          (positionData) => {\n            const positions: Position[] = positionData.map((pos, index) => ({\n              symbol: pos.symbol,\n              side: pos.side as 'LONG' | 'SHORT',\n              size: pos.size,\n              entryPrice: 50000,\n              unrealizedPnL: 0,\n              leverage: 1,\n              phaseId: 'phase1' as PhaseId\n            }));\n\n            const portfolioDelta = riskGuardian.calculatePortfolioDelta(positions);\n            \n            // Calculate expected delta manually\n            const expectedDelta = positions.reduce((delta, pos) => {\n              const positionDelta = pos.side === 'LONG' ? pos.size : -pos.size;\n              return delta + positionDelta;\n            }, 0);\n            \n            // Property: Portfolio delta should equal sum of position deltas\n            expect(portfolioDelta).toBeCloseTo(expectedDelta, 2);\n          }\n        ),\n        { numRuns: 500 }\n      );\n    });\n\n    /**\n     * Property: Empty portfolio should have zero delta\n     */\n    it('should return zero delta for empty portfolio', () => {\n      const delta = riskGuardian.calculatePortfolioDelta([]);\n      expect(delta).toBe(0);\n    });\n  });\n\n  describe('Combined Leverage Calculation Properties', () => {\n    /**\n     * Property: Combined leverage should be total notional divided by equity\n     */\n    it('should calculate combined leverage correctly', () => {\n      fc.assert(\n        fc.property(\n          fc.float({ min: Math.fround(1000), max: Math.fround(50000), noNaN: true }),\n          fc.array(\n            fc.record({\n              size: fc.float({ min: Math.fround(100), max: Math.fround(5000), noNaN: true })\n            }),\n            { minLength: 1, maxLength: 5 }\n          ),\n          (equity, positionData) => {\n            riskGuardian.setEquity(equity);\n            \n            const positions: Position[] = positionData.map((pos, index) => ({\n              symbol: 'BTCUSDT',\n              side: 'LONG',\n              size: pos.size,\n              entryPrice: 50000,\n              unrealizedPnL: 0,\n              leverage: 1,\n              phaseId: 'phase1' as PhaseId\n            }));\n\n            const leverage = riskGuardian.calculateCombinedLeverage(positions);\n            \n            // Calculate expected leverage manually\n            const totalNotional = positions.reduce((sum, pos) => sum + pos.size, 0);\n            const expectedLeverage = totalNotional / equity;\n            \n            // Property: Leverage should equal total notional / equity\n            expect(leverage).toBeCloseTo(expectedLeverage, 6);\n          }\n        ),\n        { numRuns: 500 }\n      );\n    });\n  });\n});"],"version":3}