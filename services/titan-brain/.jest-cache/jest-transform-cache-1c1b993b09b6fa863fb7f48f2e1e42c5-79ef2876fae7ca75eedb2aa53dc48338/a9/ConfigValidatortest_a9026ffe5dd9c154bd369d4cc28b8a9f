54e97b0bd56c8708f8dc1b54f3faf3da
"use strict";
/**
 * ConfigValidator Tests
 *
 * Comprehensive unit tests for the ConfigValidator class covering
 * environment variable validation, type checking, and error handling.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Mock Logger
jest.mock('../../src/logging/Logger.js');
const ConfigValidator_js_1 = require("../../src/config/ConfigValidator.js");
const Logger_js_1 = require("../../src/logging/Logger.js");
describe('ConfigValidator', () => {
    let configValidator;
    let mockLogger;
    let originalEnv;
    beforeEach(() => {
        // Save original environment
        originalEnv = { ...process.env };
        // Create mock logger
        mockLogger = {
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn(),
            debug: jest.fn(),
            logSecurityEvent: jest.fn()
        };
        Logger_js_1.Logger.getInstance.mockReturnValue(mockLogger);
        configValidator = new ConfigValidator_js_1.ConfigValidator();
        // Clear all default rules for isolated testing
        const defaultRules = configValidator.getRules();
        for (const rule of defaultRules) {
            configValidator.removeRule(rule.name);
        }
    });
    afterEach(() => {
        // Restore original environment
        process.env = originalEnv;
        jest.clearAllMocks();
    });
    describe('Rule Management', () => {
        it('should add custom validation rules', () => {
            const customRule = {
                name: 'CUSTOM_VAR',
                required: true,
                type: 'string',
                description: 'Custom variable'
            };
            configValidator.addRule(customRule);
            const rule = configValidator.getRule('CUSTOM_VAR');
            expect(rule).toEqual(customRule);
        });
        it('should remove validation rules', () => {
            const customRule = {
                name: 'CUSTOM_VAR',
                required: true,
                type: 'string',
                description: 'Custom variable'
            };
            configValidator.addRule(customRule);
            expect(configValidator.getRule('CUSTOM_VAR')).toBeDefined();
            configValidator.removeRule('CUSTOM_VAR');
            expect(configValidator.getRule('CUSTOM_VAR')).toBeUndefined();
        });
        it('should get all validation rules', () => {
            const rules = configValidator.getRules();
            expect(rules.length).toBeGreaterThan(0);
            expect(rules.some(rule => rule.name === 'NODE_ENV')).toBe(true);
            expect(rules.some(rule => rule.name === 'PORT')).toBe(true);
        });
    });
    describe('String Validation', () => {
        it('should validate string values', () => {
            process.env.TEST_STRING = 'test-value';
            const rule = {
                name: 'TEST_STRING',
                required: true,
                type: 'string',
                description: 'Test string'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(true);
            const variable = result.variables.find(v => v.name === 'TEST_STRING');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBe('test-value');
        });
        it('should validate string patterns', () => {
            process.env.TEST_PATTERN = 'invalid-pattern';
            const rule = {
                name: 'TEST_PATTERN',
                required: true,
                type: 'string',
                pattern: /^valid-/,
                description: 'Test pattern'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_PATTERN');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('does not match required pattern');
        });
    });
    describe('Number Validation', () => {
        it('should validate number values', () => {
            process.env.TEST_NUMBER = '42';
            const rule = {
                name: 'TEST_NUMBER',
                required: true,
                type: 'number',
                description: 'Test number'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(true);
            const variable = result.variables.find(v => v.name === 'TEST_NUMBER');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBe(42);
        });
        it('should validate number ranges', () => {
            process.env.TEST_RANGE = '150';
            const rule = {
                name: 'TEST_RANGE',
                required: true,
                type: 'number',
                minValue: 1,
                maxValue: 100,
                description: 'Test range'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_RANGE');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('must be <= 100');
        });
        it('should reject invalid numbers', () => {
            process.env.TEST_INVALID_NUMBER = 'not-a-number';
            const rule = {
                name: 'TEST_INVALID_NUMBER',
                required: true,
                type: 'number',
                description: 'Test invalid number'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_INVALID_NUMBER');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('must be a valid number');
        });
    });
    describe('Boolean Validation', () => {
        it('should validate true boolean values', () => {
            const testCases = ['true', '1', 'yes', 'on', 'TRUE', 'YES'];
            for (const testValue of testCases) {
                process.env.TEST_BOOLEAN = testValue;
                const rule = {
                    name: 'TEST_BOOLEAN',
                    required: true,
                    type: 'boolean',
                    description: 'Test boolean'
                };
                configValidator.removeRule('TEST_BOOLEAN');
                configValidator.addRule(rule);
                const result = configValidator.validate();
                const variable = result.variables.find(v => v.name === 'TEST_BOOLEAN');
                expect(variable?.valid).toBe(true);
                expect(variable?.value).toBe(true);
            }
        });
        it('should validate false boolean values', () => {
            const testCases = ['false', '0', 'no', 'off', 'FALSE', 'NO'];
            for (const testValue of testCases) {
                process.env.TEST_BOOLEAN = testValue;
                const rule = {
                    name: 'TEST_BOOLEAN',
                    required: true,
                    type: 'boolean',
                    description: 'Test boolean'
                };
                configValidator.removeRule('TEST_BOOLEAN');
                configValidator.addRule(rule);
                const result = configValidator.validate();
                const variable = result.variables.find(v => v.name === 'TEST_BOOLEAN');
                expect(variable?.valid).toBe(true);
                expect(variable?.value).toBe(false);
            }
        });
        it('should reject invalid boolean values', () => {
            process.env.TEST_INVALID_BOOLEAN = 'maybe';
            const rule = {
                name: 'TEST_INVALID_BOOLEAN',
                required: true,
                type: 'boolean',
                description: 'Test invalid boolean'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_INVALID_BOOLEAN');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('must be a boolean value');
        });
    });
    describe('URL Validation', () => {
        it('should validate valid URLs', () => {
            const validUrls = [
                'https://example.com',
                'http://localhost:3000',
                'postgresql://user:pass@host:5432/db',
                'redis://localhost:6379'
            ];
            for (const url of validUrls) {
                process.env.TEST_URL = url;
                const rule = {
                    name: 'TEST_URL',
                    required: true,
                    type: 'url',
                    description: 'Test URL'
                };
                configValidator.removeRule('TEST_URL');
                configValidator.addRule(rule);
                const result = configValidator.validate();
                const variable = result.variables.find(v => v.name === 'TEST_URL');
                expect(variable?.valid).toBe(true);
                expect(variable?.value).toBe(url);
            }
        });
        it('should reject invalid URLs', () => {
            process.env.TEST_INVALID_URL = 'not-a-url';
            const rule = {
                name: 'TEST_INVALID_URL',
                required: true,
                type: 'url',
                description: 'Test invalid URL'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_INVALID_URL');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('must be a valid URL');
        });
    });
    describe('Port Validation', () => {
        it('should validate valid port numbers', () => {
            const validPorts = ['80', '443', '3000', '8080', '65535'];
            for (const port of validPorts) {
                process.env.TEST_PORT = port;
                const rule = {
                    name: 'TEST_PORT',
                    required: true,
                    type: 'port',
                    description: 'Test port'
                };
                configValidator.removeRule('TEST_PORT');
                configValidator.addRule(rule);
                const result = configValidator.validate();
                const variable = result.variables.find(v => v.name === 'TEST_PORT');
                expect(variable?.valid).toBe(true);
                expect(variable?.value).toBe(parseInt(port, 10));
            }
        });
        it('should reject invalid port numbers', () => {
            const invalidPorts = ['0', '65536', '-1', 'not-a-port'];
            for (const port of invalidPorts) {
                process.env.TEST_INVALID_PORT = port;
                const rule = {
                    name: 'TEST_INVALID_PORT',
                    required: true,
                    type: 'port',
                    description: 'Test invalid port'
                };
                configValidator.removeRule('TEST_INVALID_PORT');
                configValidator.addRule(rule);
                const result = configValidator.validate();
                const variable = result.variables.find(v => v.name === 'TEST_INVALID_PORT');
                expect(variable?.valid).toBe(false);
                expect(variable?.error).toContain('must be a valid port number');
            }
        });
    });
    describe('Enum Validation', () => {
        it('should validate enum values', () => {
            process.env.TEST_ENUM = 'production';
            const rule = {
                name: 'TEST_ENUM',
                required: true,
                type: 'enum',
                enumValues: ['development', 'production', 'test'],
                description: 'Test enum'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(true);
            const variable = result.variables.find(v => v.name === 'TEST_ENUM');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBe('production');
        });
        it('should reject invalid enum values', () => {
            process.env.TEST_INVALID_ENUM = 'invalid-value';
            const rule = {
                name: 'TEST_INVALID_ENUM',
                required: true,
                type: 'enum',
                enumValues: ['development', 'production', 'test'],
                description: 'Test invalid enum'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_INVALID_ENUM');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('must be one of: development, production, test');
        });
    });
    describe('Required vs Optional Variables', () => {
        it('should fail validation for missing required variables', () => {
            delete process.env.TEST_REQUIRED;
            const rule = {
                name: 'TEST_REQUIRED',
                required: true,
                type: 'string',
                description: 'Test required'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_REQUIRED');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('Required environment variable TEST_REQUIRED is not set');
        });
        it('should pass validation for missing optional variables', () => {
            delete process.env.TEST_OPTIONAL;
            const rule = {
                name: 'TEST_OPTIONAL',
                required: false,
                type: 'string',
                description: 'Test optional'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            const variable = result.variables.find(v => v.name === 'TEST_OPTIONAL');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBeUndefined();
        });
        it('should use default values for missing variables', () => {
            delete process.env.TEST_DEFAULT;
            const rule = {
                name: 'TEST_DEFAULT',
                required: true,
                type: 'string',
                defaultValue: 'default-value',
                description: 'Test default'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(true);
            const variable = result.variables.find(v => v.name === 'TEST_DEFAULT');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBe('default-value');
            expect(variable?.usingDefault).toBe(true);
            expect(variable?.warning).toContain('Using default value');
        });
    });
    describe('Default Rules', () => {
        beforeEach(() => {
            // Re-create validator with default rules for this test suite
            configValidator = new ConfigValidator_js_1.ConfigValidator();
        });
        it('should validate NODE_ENV', () => {
            process.env.NODE_ENV = 'production';
            process.env.PORT = '3000';
            process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
            const result = configValidator.validate();
            const variable = result.variables.find(v => v.name === 'NODE_ENV');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBe('production');
        });
        it('should validate PORT', () => {
            process.env.NODE_ENV = 'production';
            process.env.PORT = '3000';
            process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
            const result = configValidator.validate();
            const variable = result.variables.find(v => v.name === 'PORT');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBe(3000);
        });
        it('should validate DATABASE_URL', () => {
            process.env.NODE_ENV = 'production';
            process.env.PORT = '3000';
            process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
            const result = configValidator.validate();
            const variable = result.variables.find(v => v.name === 'DATABASE_URL');
            expect(variable?.valid).toBe(true);
            expect(variable?.value).toBe('postgresql://user:pass@localhost:5432/db');
        });
        it('should handle missing required variables with defaults', () => {
            // Clear all environment variables
            for (const rule of configValidator.getRules()) {
                delete process.env[rule.name];
            }
            const result = configValidator.validate();
            // Should still be valid due to default values
            expect(result.valid).toBe(false); // DATABASE_URL has no default
            expect(result.summary.usingDefaults).toBeGreaterThan(0);
        });
    });
    describe('Configuration Summary', () => {
        beforeEach(() => {
            // Re-create validator with default rules for this test suite
            configValidator = new ConfigValidator_js_1.ConfigValidator();
        });
        it('should provide configuration summary with masked sensitive values', () => {
            process.env.NODE_ENV = 'production';
            process.env.PORT = '3000';
            process.env.HMAC_SECRET = 'super-secret-key';
            process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
            const summary = configValidator.getConfigSummary();
            expect(summary.NODE_ENV).toBe('production');
            expect(summary.PORT).toBe('3000');
            expect(summary.HMAC_SECRET).toBe('[CONFIGURED]');
            expect(summary.DATABASE_URL).toBe('postgresql://user:pass@localhost:5432/db');
        });
        it('should show [NOT SET] for missing variables', () => {
            delete process.env.REDIS_URL;
            const summary = configValidator.getConfigSummary();
            expect(summary.REDIS_URL).toBe('[NOT SET]');
        });
    });
    describe('Validation Summary', () => {
        it('should provide validation summary', () => {
            // Set up mixed validation results
            process.env.NODE_ENV = 'production';
            process.env.PORT = 'invalid-port';
            delete process.env.DATABASE_URL;
            const result = configValidator.validate();
            expect(result.summary.total).toBeGreaterThan(0);
            expect(result.summary.valid).toBeGreaterThan(0);
            expect(result.summary.invalid).toBeGreaterThan(0);
            expect(result.summary.total).toBe(result.summary.valid + result.summary.invalid);
        });
        it('should track warnings and defaults', () => {
            // Clear optional variable to trigger default
            delete process.env.LOG_LEVEL;
            const result = configValidator.validate();
            expect(result.summary.usingDefaults).toBeGreaterThan(0);
        });
    });
    describe('Error Handling', () => {
        it('should handle unknown validation types', () => {
            const rule = {
                name: 'TEST_UNKNOWN_TYPE',
                required: true,
                type: 'unknown',
                description: 'Test unknown type'
            };
            process.env.TEST_UNKNOWN_TYPE = 'test-value';
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_UNKNOWN_TYPE');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('Unknown validation type');
        });
        it('should handle empty string values', () => {
            process.env.TEST_EMPTY = '';
            const rule = {
                name: 'TEST_EMPTY',
                required: true,
                type: 'string',
                description: 'Test empty'
            };
            configValidator.addRule(rule);
            const result = configValidator.validate();
            expect(result.valid).toBe(false);
            const variable = result.variables.find(v => v.name === 'TEST_EMPTY');
            expect(variable?.valid).toBe(false);
            expect(variable?.error).toContain('Required environment variable TEST_EMPTY is not set');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL2NvbmZpZy9Db25maWdWYWxpZGF0b3IudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7O0dBS0c7O0FBS0gsY0FBYztBQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztBQUp6Qyw0RUFBc0Y7QUFDdEYsMkRBQXFEO0FBS3JELFFBQVEsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLEVBQUU7SUFDL0IsSUFBSSxlQUFnQyxDQUFDO0lBQ3JDLElBQUksVUFBK0IsQ0FBQztJQUNwQyxJQUFJLFdBQThCLENBQUM7SUFFbkMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLDRCQUE0QjtRQUM1QixXQUFXLEdBQUcsRUFBRSxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUVqQyxxQkFBcUI7UUFDckIsVUFBVSxHQUFHO1lBQ1gsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2hCLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2hCLGdCQUFnQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7U0FDckIsQ0FBQztRQUVSLGtCQUFNLENBQUMsV0FBeUIsQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFOUQsZUFBZSxHQUFHLElBQUksb0NBQWUsRUFBRSxDQUFDO1FBRXhDLCtDQUErQztRQUMvQyxNQUFNLFlBQVksR0FBRyxlQUFlLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDaEQsS0FBSyxNQUFNLElBQUksSUFBSSxZQUFZLEVBQUUsQ0FBQztZQUNoQyxlQUFlLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxTQUFTLENB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QUFDLENBQUM7WUFDckUsTUFBTSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEMsTUFBTSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMscURBQXFELENBQUMsQ0FBQztRQUMzRixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL2NvbmZpZy9Db25maWdWYWxpZGF0b3IudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbmZpZ1ZhbGlkYXRvciBUZXN0c1xuICogXG4gKiBDb21wcmVoZW5zaXZlIHVuaXQgdGVzdHMgZm9yIHRoZSBDb25maWdWYWxpZGF0b3IgY2xhc3MgY292ZXJpbmdcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIHZhbGlkYXRpb24sIHR5cGUgY2hlY2tpbmcsIGFuZCBlcnJvciBoYW5kbGluZy5cbiAqL1xuXG5pbXBvcnQgeyBDb25maWdWYWxpZGF0b3IsIFZhbGlkYXRpb25SdWxlIH0gZnJvbSAnLi4vLi4vc3JjL2NvbmZpZy9Db25maWdWYWxpZGF0b3IuanMnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vLi4vc3JjL2xvZ2dpbmcvTG9nZ2VyLmpzJztcblxuLy8gTW9jayBMb2dnZXJcbmplc3QubW9jaygnLi4vLi4vc3JjL2xvZ2dpbmcvTG9nZ2VyLmpzJyk7XG5cbmRlc2NyaWJlKCdDb25maWdWYWxpZGF0b3InLCAoKSA9PiB7XG4gIGxldCBjb25maWdWYWxpZGF0b3I6IENvbmZpZ1ZhbGlkYXRvcjtcbiAgbGV0IG1vY2tMb2dnZXI6IGplc3QuTW9ja2VkPExvZ2dlcj47XG4gIGxldCBvcmlnaW5hbEVudjogTm9kZUpTLlByb2Nlc3NFbnY7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gU2F2ZSBvcmlnaW5hbCBlbnZpcm9ubWVudFxuICAgIG9yaWdpbmFsRW52ID0geyAuLi5wcm9jZXNzLmVudiB9O1xuXG4gICAgLy8gQ3JlYXRlIG1vY2sgbG9nZ2VyXG4gICAgbW9ja0xvZ2dlciA9IHtcbiAgICAgIGluZm86IGplc3QuZm4oKSxcbiAgICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgICBkZWJ1ZzogamVzdC5mbigpLFxuICAgICAgbG9nU2VjdXJpdHlFdmVudDogamVzdC5mbigpXG4gICAgfSBhcyBhbnk7XG5cbiAgICAoTG9nZ2VyLmdldEluc3RhbmNlIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKG1vY2tMb2dnZXIpO1xuXG4gICAgY29uZmlnVmFsaWRhdG9yID0gbmV3IENvbmZpZ1ZhbGlkYXRvcigpO1xuICAgIFxuICAgIC8vIENsZWFyIGFsbCBkZWZhdWx0IHJ1bGVzIGZvciBpc29sYXRlZCB0ZXN0aW5nXG4gICAgY29uc3QgZGVmYXVsdFJ1bGVzID0gY29uZmlnVmFsaWRhdG9yLmdldFJ1bGVzKCk7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIGRlZmF1bHRSdWxlcykge1xuICAgICAgY29uZmlnVmFsaWRhdG9yLnJlbW92ZVJ1bGUocnVsZS5uYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBlbnZpcm9ubWVudFxuICAgIHByb2Nlc3MuZW52ID0gb3JpZ2luYWxFbnY7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSdWxlIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhZGQgY3VzdG9tIHZhbGlkYXRpb24gcnVsZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21SdWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgbmFtZTogJ0NVU1RPTV9WQVInLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQ3VzdG9tIHZhcmlhYmxlJ1xuICAgICAgfTtcblxuICAgICAgY29uZmlnVmFsaWRhdG9yLmFkZFJ1bGUoY3VzdG9tUnVsZSk7XG5cbiAgICAgIGNvbnN0IHJ1bGUgPSBjb25maWdWYWxpZGF0b3IuZ2V0UnVsZSgnQ1VTVE9NX1ZBUicpO1xuICAgICAgZXhwZWN0KHJ1bGUpLnRvRXF1YWwoY3VzdG9tUnVsZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlbW92ZSB2YWxpZGF0aW9uIHJ1bGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgY3VzdG9tUnVsZTogVmFsaWRhdGlvblJ1bGUgPSB7XG4gICAgICAgIG5hbWU6ICdDVVNUT01fVkFSJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0N1c3RvbSB2YXJpYWJsZSdcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKGN1c3RvbVJ1bGUpO1xuICAgICAgZXhwZWN0KGNvbmZpZ1ZhbGlkYXRvci5nZXRSdWxlKCdDVVNUT01fVkFSJykpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIGNvbmZpZ1ZhbGlkYXRvci5yZW1vdmVSdWxlKCdDVVNUT01fVkFSJyk7XG4gICAgICBleHBlY3QoY29uZmlnVmFsaWRhdG9yLmdldFJ1bGUoJ0NVU1RPTV9WQVInKSkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZXQgYWxsIHZhbGlkYXRpb24gcnVsZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBydWxlcyA9IGNvbmZpZ1ZhbGlkYXRvci5nZXRSdWxlcygpO1xuICAgICAgZXhwZWN0KHJ1bGVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHJ1bGVzLnNvbWUocnVsZSA9PiBydWxlLm5hbWUgPT09ICdOT0RFX0VOVicpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJ1bGVzLnNvbWUocnVsZSA9PiBydWxlLm5hbWUgPT09ICdQT1JUJykpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdHJpbmcgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHN0cmluZyB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5URVNUX1NUUklORyA9ICd0ZXN0LXZhbHVlJztcblxuICAgICAgY29uc3QgcnVsZTogVmFsaWRhdGlvblJ1bGUgPSB7XG4gICAgICAgIG5hbWU6ICdURVNUX1NUUklORycsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHN0cmluZydcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKHJ1bGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29uZmlnVmFsaWRhdG9yLnZhbGlkYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfU1RSSU5HJyk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWx1ZSkudG9CZSgndGVzdC12YWx1ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBzdHJpbmcgcGF0dGVybnMnLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5URVNUX1BBVFRFUk4gPSAnaW52YWxpZC1wYXR0ZXJuJztcblxuICAgICAgY29uc3QgcnVsZTogVmFsaWRhdGlvblJ1bGUgPSB7XG4gICAgICAgIG5hbWU6ICdURVNUX1BBVFRFUk4nLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIHBhdHRlcm46IC9edmFsaWQtLyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHBhdHRlcm4nXG4gICAgICB9O1xuXG4gICAgICBjb25maWdWYWxpZGF0b3IuYWRkUnVsZShydWxlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ1ZhbGlkYXRvci52YWxpZGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnVEVTVF9QQVRURVJOJyk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8uZXJyb3IpLnRvQ29udGFpbignZG9lcyBub3QgbWF0Y2ggcmVxdWlyZWQgcGF0dGVybicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTnVtYmVyIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBudW1iZXIgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuVEVTVF9OVU1CRVIgPSAnNDInO1xuXG4gICAgICBjb25zdCBydWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgbmFtZTogJ1RFU1RfTlVNQkVSJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgbnVtYmVyJ1xuICAgICAgfTtcblxuICAgICAgY29uZmlnVmFsaWRhdG9yLmFkZFJ1bGUocnVsZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnVEVTVF9OVU1CRVInKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbHVlKS50b0JlKDQyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgbnVtYmVyIHJhbmdlcycsICgpID0+IHtcbiAgICAgIHByb2Nlc3MuZW52LlRFU1RfUkFOR0UgPSAnMTUwJztcblxuICAgICAgY29uc3QgcnVsZTogVmFsaWRhdGlvblJ1bGUgPSB7XG4gICAgICAgIG5hbWU6ICdURVNUX1JBTkdFJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBtaW5WYWx1ZTogMSxcbiAgICAgICAgbWF4VmFsdWU6IDEwMCxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHJhbmdlJ1xuICAgICAgfTtcblxuICAgICAgY29uZmlnVmFsaWRhdG9yLmFkZFJ1bGUocnVsZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfUkFOR0UnKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy5lcnJvcikudG9Db250YWluKCdtdXN0IGJlIDw9IDEwMCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuVEVTVF9JTlZBTElEX05VTUJFUiA9ICdub3QtYS1udW1iZXInO1xuXG4gICAgICBjb25zdCBydWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgbmFtZTogJ1RFU1RfSU5WQUxJRF9OVU1CRVInLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBpbnZhbGlkIG51bWJlcidcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKHJ1bGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29uZmlnVmFsaWRhdG9yLnZhbGlkYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSByZXN1bHQudmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09ICdURVNUX0lOVkFMSURfTlVNQkVSJyk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8uZXJyb3IpLnRvQ29udGFpbignbXVzdCBiZSBhIHZhbGlkIG51bWJlcicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQm9vbGVhbiBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdHJ1ZSBib29sZWFuIHZhbHVlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDYXNlcyA9IFsndHJ1ZScsICcxJywgJ3llcycsICdvbicsICdUUlVFJywgJ1lFUyddO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3RWYWx1ZSBvZiB0ZXN0Q2FzZXMpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEVTVF9CT09MRUFOID0gdGVzdFZhbHVlO1xuXG4gICAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICAgIG5hbWU6ICdURVNUX0JPT0xFQU4nLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgYm9vbGVhbidcbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWdWYWxpZGF0b3IucmVtb3ZlUnVsZSgnVEVTVF9CT09MRUFOJyk7XG4gICAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKHJ1bGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfQk9PTEVBTicpO1xuICAgICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QodmFyaWFibGU/LnZhbHVlKS50b0JlKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBmYWxzZSBib29sZWFuIHZhbHVlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDYXNlcyA9IFsnZmFsc2UnLCAnMCcsICdubycsICdvZmYnLCAnRkFMU0UnLCAnTk8nXTtcblxuICAgICAgZm9yIChjb25zdCB0ZXN0VmFsdWUgb2YgdGVzdENhc2VzKSB7XG4gICAgICAgIHByb2Nlc3MuZW52LlRFU1RfQk9PTEVBTiA9IHRlc3RWYWx1ZTtcblxuICAgICAgICBjb25zdCBydWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgICBuYW1lOiAnVEVTVF9CT09MRUFOJyxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGJvb2xlYW4nXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uZmlnVmFsaWRhdG9yLnJlbW92ZVJ1bGUoJ1RFU1RfQk9PTEVBTicpO1xuICAgICAgICBjb25maWdWYWxpZGF0b3IuYWRkUnVsZShydWxlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29uZmlnVmFsaWRhdG9yLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSByZXN1bHQudmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09ICdURVNUX0JPT0xFQU4nKTtcbiAgICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWx1ZSkudG9CZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGJvb2xlYW4gdmFsdWVzJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuVEVTVF9JTlZBTElEX0JPT0xFQU4gPSAnbWF5YmUnO1xuXG4gICAgICBjb25zdCBydWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgbmFtZTogJ1RFU1RfSU5WQUxJRF9CT09MRUFOJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGludmFsaWQgYm9vbGVhbidcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKHJ1bGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29uZmlnVmFsaWRhdG9yLnZhbGlkYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSByZXN1bHQudmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09ICdURVNUX0lOVkFMSURfQk9PTEVBTicpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LmVycm9yKS50b0NvbnRhaW4oJ211c3QgYmUgYSBib29sZWFuIHZhbHVlJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdVUkwgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHZhbGlkIFVSTHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZFVybHMgPSBbXG4gICAgICAgICdodHRwczovL2V4YW1wbGUuY29tJyxcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcsXG4gICAgICAgICdwb3N0Z3Jlc3FsOi8vdXNlcjpwYXNzQGhvc3Q6NTQzMi9kYicsXG4gICAgICAgICdyZWRpczovL2xvY2FsaG9zdDo2Mzc5J1xuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCB1cmwgb2YgdmFsaWRVcmxzKSB7XG4gICAgICAgIHByb2Nlc3MuZW52LlRFU1RfVVJMID0gdXJsO1xuXG4gICAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICAgIG5hbWU6ICdURVNUX1VSTCcsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgdHlwZTogJ3VybCcsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IFVSTCdcbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWdWYWxpZGF0b3IucmVtb3ZlUnVsZSgnVEVTVF9VUkwnKTtcbiAgICAgICAgY29uZmlnVmFsaWRhdG9yLmFkZFJ1bGUocnVsZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ1ZhbGlkYXRvci52YWxpZGF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnVEVTVF9VUkwnKTtcbiAgICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWx1ZSkudG9CZSh1cmwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaW52YWxpZCBVUkxzJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuVEVTVF9JTlZBTElEX1VSTCA9ICdub3QtYS11cmwnO1xuXG4gICAgICBjb25zdCBydWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgbmFtZTogJ1RFU1RfSU5WQUxJRF9VUkwnLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ3VybCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBpbnZhbGlkIFVSTCdcbiAgICAgIH07XG5cbiAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKHJ1bGUpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29uZmlnVmFsaWRhdG9yLnZhbGlkYXRlKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSByZXN1bHQudmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09ICdURVNUX0lOVkFMSURfVVJMJyk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8uZXJyb3IpLnRvQ29udGFpbignbXVzdCBiZSBhIHZhbGlkIFVSTCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUG9ydCBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdmFsaWQgcG9ydCBudW1iZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRQb3J0cyA9IFsnODAnLCAnNDQzJywgJzMwMDAnLCAnODA4MCcsICc2NTUzNSddO1xuXG4gICAgICBmb3IgKGNvbnN0IHBvcnQgb2YgdmFsaWRQb3J0cykge1xuICAgICAgICBwcm9jZXNzLmVudi5URVNUX1BPUlQgPSBwb3J0O1xuXG4gICAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICAgIG5hbWU6ICdURVNUX1BPUlQnLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgIHR5cGU6ICdwb3J0JyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgcG9ydCdcbiAgICAgICAgfTtcblxuICAgICAgICBjb25maWdWYWxpZGF0b3IucmVtb3ZlUnVsZSgnVEVTVF9QT1JUJyk7XG4gICAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKHJ1bGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfUE9SVCcpO1xuICAgICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QodmFyaWFibGU/LnZhbHVlKS50b0JlKHBhcnNlSW50KHBvcnQsIDEwKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIHBvcnQgbnVtYmVycycsICgpID0+IHtcbiAgICAgIGNvbnN0IGludmFsaWRQb3J0cyA9IFsnMCcsICc2NTUzNicsICctMScsICdub3QtYS1wb3J0J107XG5cbiAgICAgIGZvciAoY29uc3QgcG9ydCBvZiBpbnZhbGlkUG9ydHMpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEVTVF9JTlZBTElEX1BPUlQgPSBwb3J0O1xuXG4gICAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICAgIG5hbWU6ICdURVNUX0lOVkFMSURfUE9SVCcsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgdHlwZTogJ3BvcnQnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBpbnZhbGlkIHBvcnQnXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uZmlnVmFsaWRhdG9yLnJlbW92ZVJ1bGUoJ1RFU1RfSU5WQUxJRF9QT1JUJyk7XG4gICAgICAgIGNvbmZpZ1ZhbGlkYXRvci5hZGRSdWxlKHJ1bGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfSU5WQUxJRF9QT1JUJyk7XG4gICAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgICBleHBlY3QodmFyaWFibGU/LmVycm9yKS50b0NvbnRhaW4oJ211c3QgYmUgYSB2YWxpZCBwb3J0IG51bWJlcicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRW51bSBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgZW51bSB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5URVNUX0VOVU0gPSAncHJvZHVjdGlvbic7XG5cbiAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICBuYW1lOiAnVEVTVF9FTlVNJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6ICdlbnVtJyxcbiAgICAgICAgZW51bVZhbHVlczogWydkZXZlbG9wbWVudCcsICdwcm9kdWN0aW9uJywgJ3Rlc3QnXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGVudW0nXG4gICAgICB9O1xuXG4gICAgICBjb25maWdWYWxpZGF0b3IuYWRkUnVsZShydWxlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ1ZhbGlkYXRvci52YWxpZGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSByZXN1bHQudmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09ICdURVNUX0VOVU0nKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbHVlKS50b0JlKCdwcm9kdWN0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBpbnZhbGlkIGVudW0gdmFsdWVzJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuVEVTVF9JTlZBTElEX0VOVU0gPSAnaW52YWxpZC12YWx1ZSc7XG5cbiAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICBuYW1lOiAnVEVTVF9JTlZBTElEX0VOVU0nLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ2VudW0nLFxuICAgICAgICBlbnVtVmFsdWVzOiBbJ2RldmVsb3BtZW50JywgJ3Byb2R1Y3Rpb24nLCAndGVzdCddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgaW52YWxpZCBlbnVtJ1xuICAgICAgfTtcblxuICAgICAgY29uZmlnVmFsaWRhdG9yLmFkZFJ1bGUocnVsZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfSU5WQUxJRF9FTlVNJyk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8uZXJyb3IpLnRvQ29udGFpbignbXVzdCBiZSBvbmUgb2Y6IGRldmVsb3BtZW50LCBwcm9kdWN0aW9uLCB0ZXN0Jyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZXF1aXJlZCB2cyBPcHRpb25hbCBWYXJpYWJsZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBmYWlsIHZhbGlkYXRpb24gZm9yIG1pc3NpbmcgcmVxdWlyZWQgdmFyaWFibGVzJywgKCkgPT4ge1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LlRFU1RfUkVRVUlSRUQ7XG5cbiAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICBuYW1lOiAnVEVTVF9SRVFVSVJFRCcsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHJlcXVpcmVkJ1xuICAgICAgfTtcblxuICAgICAgY29uZmlnVmFsaWRhdG9yLmFkZFJ1bGUocnVsZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfUkVRVUlSRUQnKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy5lcnJvcikudG9Db250YWluKCdSZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZSBURVNUX1JFUVVJUkVEIGlzIG5vdCBzZXQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGFzcyB2YWxpZGF0aW9uIGZvciBtaXNzaW5nIG9wdGlvbmFsIHZhcmlhYmxlcycsICgpID0+IHtcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5URVNUX09QVElPTkFMO1xuXG4gICAgICBjb25zdCBydWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgbmFtZTogJ1RFU1RfT1BUSU9OQUwnLFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3Qgb3B0aW9uYWwnXG4gICAgICB9O1xuXG4gICAgICBjb25maWdWYWxpZGF0b3IuYWRkUnVsZShydWxlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ1ZhbGlkYXRvci52YWxpZGF0ZSgpO1xuXG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHJlc3VsdC52YXJpYWJsZXMuZmluZCh2ID0+IHYubmFtZSA9PT0gJ1RFU1RfT1BUSU9OQUwnKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbHVlKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IHZhbHVlcyBmb3IgbWlzc2luZyB2YXJpYWJsZXMnLCAoKSA9PiB7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuVEVTVF9ERUZBVUxUO1xuXG4gICAgICBjb25zdCBydWxlOiBWYWxpZGF0aW9uUnVsZSA9IHtcbiAgICAgICAgbmFtZTogJ1RFU1RfREVGQVVMVCcsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAnZGVmYXVsdC12YWx1ZScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBkZWZhdWx0J1xuICAgICAgfTtcblxuICAgICAgY29uZmlnVmFsaWRhdG9yLmFkZFJ1bGUocnVsZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnVEVTVF9ERUZBVUxUJyk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWx1ZSkudG9CZSgnZGVmYXVsdC12YWx1ZScpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy51c2luZ0RlZmF1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFyaWFibGU/Lndhcm5pbmcpLnRvQ29udGFpbignVXNpbmcgZGVmYXVsdCB2YWx1ZScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGVmYXVsdCBSdWxlcycsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIC8vIFJlLWNyZWF0ZSB2YWxpZGF0b3Igd2l0aCBkZWZhdWx0IHJ1bGVzIGZvciB0aGlzIHRlc3Qgc3VpdGVcbiAgICAgIGNvbmZpZ1ZhbGlkYXRvciA9IG5ldyBDb25maWdWYWxpZGF0b3IoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgTk9ERV9FTlYnLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9ICdwcm9kdWN0aW9uJztcbiAgICAgIHByb2Nlc3MuZW52LlBPUlQgPSAnMzAwMCc7XG4gICAgICBwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkwgPSAncG9zdGdyZXNxbDovL3VzZXI6cGFzc0Bsb2NhbGhvc3Q6NTQzMi9kYic7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ1ZhbGlkYXRvci52YWxpZGF0ZSgpO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSByZXN1bHQudmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09ICdOT0RFX0VOVicpO1xuXG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWx1ZSkudG9CZSgncHJvZHVjdGlvbicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBQT1JUJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAncHJvZHVjdGlvbic7XG4gICAgICBwcm9jZXNzLmVudi5QT1JUID0gJzMwMDAnO1xuICAgICAgcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMID0gJ3Bvc3RncmVzcWw6Ly91c2VyOnBhc3NAbG9jYWxob3N0OjU0MzIvZGInO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnUE9SVCcpO1xuXG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWx1ZSkudG9CZSgzMDAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgREFUQUJBU0VfVVJMJywgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAncHJvZHVjdGlvbic7XG4gICAgICBwcm9jZXNzLmVudi5QT1JUID0gJzMwMDAnO1xuICAgICAgcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMID0gJ3Bvc3RncmVzcWw6Ly91c2VyOnBhc3NAbG9jYWxob3N0OjU0MzIvZGInO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnREFUQUJBU0VfVVJMJyk7XG5cbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LnZhbHVlKS50b0JlKCdwb3N0Z3Jlc3FsOi8vdXNlcjpwYXNzQGxvY2FsaG9zdDo1NDMyL2RiJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIHJlcXVpcmVkIHZhcmlhYmxlcyB3aXRoIGRlZmF1bHRzJywgKCkgPT4ge1xuICAgICAgLy8gQ2xlYXIgYWxsIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAgZm9yIChjb25zdCBydWxlIG9mIGNvbmZpZ1ZhbGlkYXRvci5nZXRSdWxlcygpKSB7XG4gICAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudltydWxlLm5hbWVdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgLy8gU2hvdWxkIHN0aWxsIGJlIHZhbGlkIGR1ZSB0byBkZWZhdWx0IHZhbHVlc1xuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7IC8vIERBVEFCQVNFX1VSTCBoYXMgbm8gZGVmYXVsdFxuICAgICAgZXhwZWN0KHJlc3VsdC5zdW1tYXJ5LnVzaW5nRGVmYXVsdHMpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmZpZ3VyYXRpb24gU3VtbWFyeScsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIC8vIFJlLWNyZWF0ZSB2YWxpZGF0b3Igd2l0aCBkZWZhdWx0IHJ1bGVzIGZvciB0aGlzIHRlc3Qgc3VpdGVcbiAgICAgIGNvbmZpZ1ZhbGlkYXRvciA9IG5ldyBDb25maWdWYWxpZGF0b3IoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvdmlkZSBjb25maWd1cmF0aW9uIHN1bW1hcnkgd2l0aCBtYXNrZWQgc2Vuc2l0aXZlIHZhbHVlcycsICgpID0+IHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID0gJ3Byb2R1Y3Rpb24nO1xuICAgICAgcHJvY2Vzcy5lbnYuUE9SVCA9ICczMDAwJztcbiAgICAgIHByb2Nlc3MuZW52LkhNQUNfU0VDUkVUID0gJ3N1cGVyLXNlY3JldC1rZXknO1xuICAgICAgcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMID0gJ3Bvc3RncmVzcWw6Ly91c2VyOnBhc3NAbG9jYWxob3N0OjU0MzIvZGInO1xuXG4gICAgICBjb25zdCBzdW1tYXJ5ID0gY29uZmlnVmFsaWRhdG9yLmdldENvbmZpZ1N1bW1hcnkoKTtcblxuICAgICAgZXhwZWN0KHN1bW1hcnkuTk9ERV9FTlYpLnRvQmUoJ3Byb2R1Y3Rpb24nKTtcbiAgICAgIGV4cGVjdChzdW1tYXJ5LlBPUlQpLnRvQmUoJzMwMDAnKTtcbiAgICAgIGV4cGVjdChzdW1tYXJ5LkhNQUNfU0VDUkVUKS50b0JlKCdbQ09ORklHVVJFRF0nKTtcbiAgICAgIGV4cGVjdChzdW1tYXJ5LkRBVEFCQVNFX1VSTCkudG9CZSgncG9zdGdyZXNxbDovL3VzZXI6cGFzc0Bsb2NhbGhvc3Q6NTQzMi9kYicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzaG93IFtOT1QgU0VUXSBmb3IgbWlzc2luZyB2YXJpYWJsZXMnLCAoKSA9PiB7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuUkVESVNfVVJMO1xuXG4gICAgICBjb25zdCBzdW1tYXJ5ID0gY29uZmlnVmFsaWRhdG9yLmdldENvbmZpZ1N1bW1hcnkoKTtcblxuICAgICAgZXhwZWN0KHN1bW1hcnkuUkVESVNfVVJMKS50b0JlKCdbTk9UIFNFVF0nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1ZhbGlkYXRpb24gU3VtbWFyeScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb3ZpZGUgdmFsaWRhdGlvbiBzdW1tYXJ5JywgKCkgPT4ge1xuICAgICAgLy8gU2V0IHVwIG1peGVkIHZhbGlkYXRpb24gcmVzdWx0c1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAncHJvZHVjdGlvbic7XG4gICAgICBwcm9jZXNzLmVudi5QT1JUID0gJ2ludmFsaWQtcG9ydCc7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREFUQUJBU0VfVVJMO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdW1tYXJ5LnRvdGFsKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1bW1hcnkudmFsaWQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VtbWFyeS5pbnZhbGlkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1bW1hcnkudG90YWwpLnRvQmUoXG4gICAgICAgIHJlc3VsdC5zdW1tYXJ5LnZhbGlkICsgcmVzdWx0LnN1bW1hcnkuaW52YWxpZFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJhY2sgd2FybmluZ3MgYW5kIGRlZmF1bHRzJywgKCkgPT4ge1xuICAgICAgLy8gQ2xlYXIgb3B0aW9uYWwgdmFyaWFibGUgdG8gdHJpZ2dlciBkZWZhdWx0XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuTE9HX0xFVkVMO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBjb25maWdWYWxpZGF0b3IudmFsaWRhdGUoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdW1tYXJ5LnVzaW5nRGVmYXVsdHMpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVua25vd24gdmFsaWRhdGlvbiB0eXBlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJ1bGU6IFZhbGlkYXRpb25SdWxlID0ge1xuICAgICAgICBuYW1lOiAnVEVTVF9VTktOT1dOX1RZUEUnLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ3Vua25vd24nIGFzIGFueSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHVua25vd24gdHlwZSdcbiAgICAgIH07XG5cbiAgICAgIHByb2Nlc3MuZW52LlRFU1RfVU5LTk9XTl9UWVBFID0gJ3Rlc3QtdmFsdWUnO1xuXG4gICAgICBjb25maWdWYWxpZGF0b3IuYWRkUnVsZShydWxlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ1ZhbGlkYXRvci52YWxpZGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnVEVTVF9VTktOT1dOX1RZUEUnKTtcbiAgICAgIGV4cGVjdCh2YXJpYWJsZT8udmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy5lcnJvcikudG9Db250YWluKCdVbmtub3duIHZhbGlkYXRpb24gdHlwZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgc3RyaW5nIHZhbHVlcycsICgpID0+IHtcbiAgICAgIHByb2Nlc3MuZW52LlRFU1RfRU1QVFkgPSAnJztcblxuICAgICAgY29uc3QgcnVsZTogVmFsaWRhdGlvblJ1bGUgPSB7XG4gICAgICAgIG5hbWU6ICdURVNUX0VNUFRZJyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgZW1wdHknXG4gICAgICB9O1xuXG4gICAgICBjb25maWdWYWxpZGF0b3IuYWRkUnVsZShydWxlKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmZpZ1ZhbGlkYXRvci52YWxpZGF0ZSgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gcmVzdWx0LnZhcmlhYmxlcy5maW5kKHYgPT4gdi5uYW1lID09PSAnVEVTVF9FTVBUWScpO1xuICAgICAgZXhwZWN0KHZhcmlhYmxlPy52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodmFyaWFibGU/LmVycm9yKS50b0NvbnRhaW4oJ1JlcXVpcmVkIGVudmlyb25tZW50IHZhcmlhYmxlIFRFU1RfRU1QVFkgaXMgbm90IHNldCcpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==