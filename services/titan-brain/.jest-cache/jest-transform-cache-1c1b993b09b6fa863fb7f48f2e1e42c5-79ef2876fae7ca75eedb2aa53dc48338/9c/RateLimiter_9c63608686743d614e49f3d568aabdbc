8237a39b77563c865d243dbf5ea3ffaf
"use strict";
/**
 * RateLimiter - Rate limiting middleware for Fastify
 *
 * Provides configurable rate limiting with Redis-based storage and in-memory fallback.
 * Supports different rate limits for different endpoints and includes proper headers.
 *
 * Requirements: 4.3.1, 4.3.2, 4.3.3, 4.3.4, 4.3.5
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_ENDPOINT_CONFIGS = exports.RateLimiter = void 0;
exports.rateLimiterPlugin = rateLimiterPlugin;
/**
 * Rate limiter class
 */
class RateLimiter {
    cacheManager;
    logger;
    defaultConfig;
    constructor(cacheManager, logger, defaultConfig) {
        this.cacheManager = cacheManager;
        this.logger = logger;
        this.defaultConfig = defaultConfig;
    }
    /**
     * Create rate limiter from environment variables
     */
    static createFromEnvironment(cacheManager, logger) {
        const defaultConfig = {
            windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || "60000"), // 1 minute
            maxRequests: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || "100"), // 100 requests per minute
            skipSuccessfulRequests: process.env.RATE_LIMIT_SKIP_SUCCESS === "true",
            skipFailedRequests: process.env.RATE_LIMIT_SKIP_FAILED === "true",
        };
        return new RateLimiter(cacheManager, logger, defaultConfig);
    }
    /**
     * Default key generator using IP address
     */
    defaultKeyGenerator(request) {
        const ip = request.ip || "unknown";
        const endpoint = request.url.split("?")[0]; // Remove query parameters
        return `rate_limit:${ip}:${endpoint}`;
    }
    /**
     * Check rate limit for a request
     */
    /**
     * Check rate limit for a request
     */
    async checkRateLimit(request, config) {
        const finalConfig = { ...this.defaultConfig, ...config };
        const keyGenerator = finalConfig.keyGenerator ||
            this.defaultKeyGenerator.bind(this);
        const key = keyGenerator(request);
        const now = Date.now();
        const windowStart = now - finalConfig.windowMs;
        try {
            // Get current hit count from cache
            const cacheResult = await this.cacheManager.get(key);
            let hits = [];
            if (cacheResult.success && cacheResult.value) {
                try {
                    hits = JSON.parse(cacheResult.value);
                    if (!Array.isArray(hits)) {
                        hits = [];
                    }
                }
                catch (error) {
                    this.logger.warn("Failed to parse rate limit data", undefined, {
                        key,
                        error: error instanceof Error ? error.message : String(error),
                    });
                    hits = [];
                }
            }
            // Filter hits within the current window
            hits = hits.filter((hit) => hit.timestamp > windowStart);
            // Count relevant hits based on configuration
            let relevantHits = hits.length;
            if (finalConfig.skipSuccessfulRequests || finalConfig.skipFailedRequests) {
                relevantHits = hits.filter((hit) => {
                    if (finalConfig.skipSuccessfulRequests && hit.success === true) {
                        return false;
                    }
                    if (finalConfig.skipFailedRequests && hit.success === false) {
                        return false;
                    }
                    return true;
                }).length;
            }
            const allowed = relevantHits < finalConfig.maxRequests;
            const remaining = Math.max(0, finalConfig.maxRequests - relevantHits - (allowed ? 1 : 0));
            const resetTime = windowStart + finalConfig.windowMs;
            // Add current request to hits if we're tracking it
            if (allowed) {
                hits.push({ timestamp: now });
                // Store updated hits with TTL
                const ttlMs = Math.ceil(finalConfig.windowMs / 1000);
                await this.cacheManager.set(key, JSON.stringify(hits), ttlMs);
            }
            return {
                allowed,
                remaining,
                resetTime,
                totalHits: hits.length,
            };
        }
        catch (error) {
            this.logger.error("Rate limit check failed", error instanceof Error ? error : new Error(String(error)), undefined, { key });
            // On error, allow the request (fail open)
            return {
                allowed: true,
                remaining: finalConfig.maxRequests,
                resetTime: now + finalConfig.windowMs,
                totalHits: 0,
            };
        }
    }
    /**
     * Update rate limit after response (for conditional counting)
     */
    async updateRateLimit(request, success, config) {
        const finalConfig = { ...this.defaultConfig, ...config };
        // Only update if we're conditionally counting requests
        if (!finalConfig.skipSuccessfulRequests && !finalConfig.skipFailedRequests) {
            return;
        }
        const keyGenerator = finalConfig.keyGenerator ||
            this.defaultKeyGenerator.bind(this);
        const key = keyGenerator(request);
        try {
            const cacheResult = await this.cacheManager.get(key);
            if (!cacheResult.success || !cacheResult.value)
                return;
            let hits = JSON.parse(cacheResult.value);
            // Update the most recent hit with success status
            if (hits.length > 0) {
                hits[hits.length - 1].success = success;
                const ttlMs = Math.ceil(finalConfig.windowMs / 1000);
                await this.cacheManager.set(key, JSON.stringify(hits), ttlMs);
            }
        }
        catch (error) {
            this.logger.warn("Failed to update rate limit", undefined, {
                key,
                success,
                error: error instanceof Error ? error.message : String(error),
            });
        }
    }
    createMiddleware(config) {
        return async (request, reply) => {
            const startTime = Date.now();
            try {
                const result = await this.checkRateLimit(request, config);
                // Add rate limit headers
                reply.header("X-RateLimit-Limit", (config?.maxRequests || this.defaultConfig.maxRequests).toString());
                reply.header("X-RateLimit-Remaining", result.remaining.toString());
                reply.header("X-RateLimit-Reset", Math.ceil(result.resetTime / 1000).toString());
                if (!result.allowed) {
                    // Log rate limit exceeded
                    this.logger.logSecurityEvent("Rate limit exceeded", "medium", request.correlationId, {
                        ip: request.ip,
                        endpoint: request.url,
                        method: request.method,
                        userAgent: request.headers["user-agent"],
                        totalHits: result.totalHits,
                        limit: config?.maxRequests || this.defaultConfig.maxRequests,
                    });
                    // Call custom handler if provided
                    if (config?.onLimitReached) {
                        config.onLimitReached(request, reply);
                    }
                    else {
                        reply.status(429).send({
                            error: "Too Many Requests",
                            message: "Rate limit exceeded. Please try again later.",
                            retryAfter: Math.ceil((result.resetTime - Date.now()) / 1000),
                            timestamp: new Date().toISOString(),
                        });
                    }
                    return;
                }
                // Add response hook to update rate limit if using conditional counting
                if (config?.skipSuccessfulRequests || config?.skipFailedRequests) {
                    // Note: Fastify doesn't have addHook on reply, we need to use a different approach
                    // For now, we'll skip this functionality in the middleware
                    // In a real implementation, this would be handled at the route level
                }
                // Log rate limit check
                const duration = Date.now() - startTime;
                this.logger.debug("Rate limit check completed", request.correlationId, {
                    ip: request.ip,
                    endpoint: request.url,
                    allowed: result.allowed,
                    remaining: result.remaining,
                    duration,
                });
                // done();
            }
            catch (error) {
                this.logger.error("Rate limit middleware error", error instanceof Error ? error : new Error(String(error)), request.correlationId, {
                    ip: request.ip,
                    endpoint: request.url,
                });
                // On error, allow the request (fail open)
            }
        };
    }
    /**
     * Create endpoint-specific rate limiting middleware
     */
    createEndpointMiddleware(endpointConfigs) {
        return async (request, reply) => {
            const endpoint = request.url.split("?")[0]; // Remove query parameters
            const config = endpointConfigs[endpoint];
            if (!config) {
                // No specific config for this endpoint, use default
                const defaultMiddleware = this.createMiddleware();
                return defaultMiddleware(request, reply);
            }
            const endpointMiddleware = this.createMiddleware(config);
            return endpointMiddleware(request, reply);
        };
    }
    /**
     * Reset rate limit for a specific key
     */
    async resetRateLimit(key) {
        try {
            await this.cacheManager.delete(key);
            this.logger.info("Rate limit reset", undefined, { key });
        }
        catch (error) {
            this.logger.error("Failed to reset rate limit", error instanceof Error ? error : new Error(String(error)), undefined, { key });
        }
    }
    /**
     * Get rate limit status for a key
     */
    async getRateLimitStatus(key) {
        try {
            const cacheResult = await this.cacheManager.get(key);
            if (!cacheResult.success || !cacheResult.value) {
                return {
                    hits: 0,
                    remaining: this.defaultConfig.maxRequests,
                    resetTime: Date.now() + this.defaultConfig.windowMs,
                };
            }
            const hits = JSON.parse(cacheResult.value);
            const now = Date.now();
            const windowStart = now - this.defaultConfig.windowMs;
            const validHits = hits.filter((hit) => hit.timestamp > windowStart);
            return {
                hits: validHits.length,
                remaining: Math.max(0, this.defaultConfig.maxRequests - validHits.length),
                resetTime: windowStart + this.defaultConfig.windowMs,
            };
        }
        catch (error) {
            this.logger.error("Failed to get rate limit status", error instanceof Error ? error : new Error(String(error)), undefined, { key });
            return null;
        }
    }
}
exports.RateLimiter = RateLimiter;
/**
 * Default rate limit configurations for different endpoints
 */
exports.DEFAULT_ENDPOINT_CONFIGS = {
    "/signal": {
        windowMs: 60000, // 1 minute
        maxRequests: 60, // 60 signals per minute
        skipFailedRequests: true, // Don't count failed signals
    },
    "/webhook/phase1": {
        windowMs: 60000, // 1 minute
        maxRequests: 120, // 120 webhooks per minute
        skipFailedRequests: true,
    },
    "/webhook/phase2": {
        windowMs: 60000, // 1 minute
        maxRequests: 60, // 60 webhooks per minute
        skipFailedRequests: true,
    },
    "/webhook/phase3": {
        windowMs: 60000, // 1 minute
        maxRequests: 30, // 30 webhooks per minute
        skipFailedRequests: true,
    },
    "/admin/override": {
        windowMs: 300000, // 5 minutes
        maxRequests: 5, // 5 override attempts per 5 minutes
        skipSuccessfulRequests: false,
        skipFailedRequests: false,
    },
    "/breaker/reset": {
        windowMs: 300000, // 5 minutes
        maxRequests: 10, // 10 reset attempts per 5 minutes
        skipSuccessfulRequests: false,
        skipFailedRequests: false,
    },
    "/dashboard": {
        windowMs: 60000, // 1 minute
        maxRequests: 300, // 300 dashboard requests per minute
        skipFailedRequests: true,
    },
    "/metrics": {
        windowMs: 60000, // 1 minute
        maxRequests: 600, // 600 metrics requests per minute (for monitoring)
        skipFailedRequests: true,
    },
};
/**
 * Rate limiter plugin for Fastify
 */
async function rateLimiterPlugin(fastify, options) {
    const rateLimiter = new RateLimiter(options.cacheManager, options.logger, options.defaultConfig || {
        windowMs: 60000,
        maxRequests: 100,
    });
    const endpointConfigs = options.endpointConfigs || exports.DEFAULT_ENDPOINT_CONFIGS;
    const middleware = rateLimiter.createEndpointMiddleware(endpointConfigs);
    fastify.addHook("preHandler", middleware);
    // Add rate limiter instance to fastify for access in routes
    fastify.decorate("rateLimiter", rateLimiter);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3NyYy9taWRkbGV3YXJlL1JhdGVMaW1pdGVyLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7OztHQU9HOzs7QUEwYkgsOENBeUJDO0FBdmJEOztHQUVHO0FBQ0gsTUFBYSxXQUFXO0lBQ2QsWUFBWSxDQUFlO0lBQzNCLE1BQU0sQ0FBUztJQUNmLGFBQWEsQ0FBa0I7SUFFdkMsWUFDRSxZQUEwQixFQUMxQixNQUFjLEVBQ2QsYUFBOEI7UUFFOUIsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7SUFDckMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLHFCQUFxQixDQUMxQixZQUEwQixFQUMxQixNQUFjO1FBRWQsTUFBTSxhQUFhLEdBQW9CO1lBQ3JDLFFBQVEsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsSUFBSSxPQUFPLENBQUMsRUFBRSxXQUFXO1lBQzVFLFdBQVcsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsSUFBSSxLQUFLLENBQUMsRUFBRSwwQkFBMEI7WUFDL0Ysc0JBQXNCLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsS0FBSyxNQUFNO1lBQ3RFLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLEtBQUssTUFBTTtTQUNsRSxDQUFDO1FBRUYsT0FBTyxJQUFJLFdBQVcsQ0FBQyxZQUFZLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7T0FFRztJQUNLLG1CQUFtQixDQUFDLE9BQXVCO1FBQ2pELE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFLElBQUksU0FBUyxDQUFDO1FBQ25DLE1BQU0sUUFBUSxHQUFH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QUssVUFBVSxpQkFBaUIsQ0FDckMsT0FBWSxFQUNaLE9BS0M7SUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLFdBQVcsQ0FDakMsT0FBTyxDQUFDLFlBQVksRUFDcEIsT0FBTyxDQUFDLE1BQU0sRUFDZCxPQUFPLENBQUMsYUFBYSxJQUFJO1FBQ3ZCLFFBQVEsRUFBRSxLQUFLO1FBQ2YsV0FBVyxFQUFFLEdBQUc7S0FDakIsQ0FDRixDQUFDO0lBRUYsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLGVBQWUsSUFBSSxnQ0FBd0IsQ0FBQztJQUM1RSxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsd0JBQXdCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFFekUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFMUMsNERBQTREO0lBQzVELE9BQU8sQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQy9DLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3NyYy9taWRkbGV3YXJlL1JhdGVMaW1pdGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmF0ZUxpbWl0ZXIgLSBSYXRlIGxpbWl0aW5nIG1pZGRsZXdhcmUgZm9yIEZhc3RpZnlcbiAqXG4gKiBQcm92aWRlcyBjb25maWd1cmFibGUgcmF0ZSBsaW1pdGluZyB3aXRoIFJlZGlzLWJhc2VkIHN0b3JhZ2UgYW5kIGluLW1lbW9yeSBmYWxsYmFjay5cbiAqIFN1cHBvcnRzIGRpZmZlcmVudCByYXRlIGxpbWl0cyBmb3IgZGlmZmVyZW50IGVuZHBvaW50cyBhbmQgaW5jbHVkZXMgcHJvcGVyIGhlYWRlcnMuXG4gKlxuICogUmVxdWlyZW1lbnRzOiA0LjMuMSwgNC4zLjIsIDQuMy4zLCA0LjMuNCwgNC4zLjVcbiAqL1xuXG5pbXBvcnQgeyBGYXN0aWZ5UmVwbHksIEZhc3RpZnlSZXF1ZXN0LCBIb29rSGFuZGxlckRvbmVGdW5jdGlvbiB9IGZyb20gXCJmYXN0aWZ5XCI7XG5pbXBvcnQgeyBDYWNoZU1hbmFnZXIgfSBmcm9tIFwiLi4vY2FjaGUvQ2FjaGVNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2luZy9Mb2dnZXIuanNcIjtcblxuLyoqXG4gKiBSYXRlIGxpbWl0IGNvbmZpZ3VyYXRpb24gZm9yIGFuIGVuZHBvaW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmF0ZUxpbWl0Q29uZmlnIHtcbiAgd2luZG93TXM6IG51bWJlcjsgLy8gVGltZSB3aW5kb3cgaW4gbWlsbGlzZWNvbmRzXG4gIG1heFJlcXVlc3RzOiBudW1iZXI7IC8vIE1heGltdW0gcmVxdWVzdHMgcGVyIHdpbmRvd1xuICBza2lwU3VjY2Vzc2Z1bFJlcXVlc3RzPzogYm9vbGVhbjsgLy8gRG9uJ3QgY291bnQgc3VjY2Vzc2Z1bCByZXF1ZXN0c1xuICBza2lwRmFpbGVkUmVxdWVzdHM/OiBib29sZWFuOyAvLyBEb24ndCBjb3VudCBmYWlsZWQgcmVxdWVzdHNcbiAga2V5R2VuZXJhdG9yPzogKHJlcXVlc3Q6IEZhc3RpZnlSZXF1ZXN0KSA9PiBzdHJpbmc7IC8vIEN1c3RvbSBrZXkgZ2VuZXJhdG9yXG4gIG9uTGltaXRSZWFjaGVkPzogKHJlcXVlc3Q6IEZhc3RpZnlSZXF1ZXN0LCByZXBseTogRmFzdGlmeVJlcGx5KSA9PiB2b2lkOyAvLyBDdXN0b20gbGltaXQgaGFuZGxlclxufVxuXG4vKipcbiAqIFJhdGUgbGltaXQgcmVzdWx0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmF0ZUxpbWl0UmVzdWx0IHtcbiAgYWxsb3dlZDogYm9vbGVhbjtcbiAgcmVtYWluaW5nOiBudW1iZXI7XG4gIHJlc2V0VGltZTogbnVtYmVyO1xuICB0b3RhbEhpdHM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBSYXRlIGxpbWl0ZXIgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFJhdGVMaW1pdGVyIHtcbiAgcHJpdmF0ZSBjYWNoZU1hbmFnZXI6IENhY2hlTWFuYWdlcjtcbiAgcHJpdmF0ZSBsb2dnZXI6IExvZ2dlcjtcbiAgcHJpdmF0ZSBkZWZhdWx0Q29uZmlnOiBSYXRlTGltaXRDb25maWc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2FjaGVNYW5hZ2VyOiBDYWNoZU1hbmFnZXIsXG4gICAgbG9nZ2VyOiBMb2dnZXIsXG4gICAgZGVmYXVsdENvbmZpZzogUmF0ZUxpbWl0Q29uZmlnLFxuICApIHtcbiAgICB0aGlzLmNhY2hlTWFuYWdlciA9IGNhY2hlTWFuYWdlcjtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSByYXRlIGxpbWl0ZXIgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVGcm9tRW52aXJvbm1lbnQoXG4gICAgY2FjaGVNYW5hZ2VyOiBDYWNoZU1hbmFnZXIsXG4gICAgbG9nZ2VyOiBMb2dnZXIsXG4gICk6IFJhdGVMaW1pdGVyIHtcbiAgICBjb25zdCBkZWZhdWx0Q29uZmlnOiBSYXRlTGltaXRDb25maWcgPSB7XG4gICAgICB3aW5kb3dNczogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkFURV9MSU1JVF9XSU5ET1dfTVMgfHwgXCI2MDAwMFwiKSwgLy8gMSBtaW51dGVcbiAgICAgIG1heFJlcXVlc3RzOiBwYXJzZUludChwcm9jZXNzLmVudi5SQVRFX0xJTUlUX01BWF9SRVFVRVNUUyB8fCBcIjEwMFwiKSwgLy8gMTAwIHJlcXVlc3RzIHBlciBtaW51dGVcbiAgICAgIHNraXBTdWNjZXNzZnVsUmVxdWVzdHM6IHByb2Nlc3MuZW52LlJBVEVfTElNSVRfU0tJUF9TVUNDRVNTID09PSBcInRydWVcIixcbiAgICAgIHNraXBGYWlsZWRSZXF1ZXN0czogcHJvY2Vzcy5lbnYuUkFURV9MSU1JVF9TS0lQX0ZBSUxFRCA9PT0gXCJ0cnVlXCIsXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUmF0ZUxpbWl0ZXIoY2FjaGVNYW5hZ2VyLCBsb2dnZXIsIGRlZmF1bHRDb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQga2V5IGdlbmVyYXRvciB1c2luZyBJUCBhZGRyZXNzXG4gICAqL1xuICBwcml2YXRlIGRlZmF1bHRLZXlHZW5lcmF0b3IocmVxdWVzdDogRmFzdGlmeVJlcXVlc3QpOiBzdHJpbmcge1xuICAgIGNvbnN0IGlwID0gcmVxdWVzdC5pcCB8fCBcInVua25vd25cIjtcbiAgICBjb25zdCBlbmRwb2ludCA9IHJlcXVlc3QudXJsLnNwbGl0KFwiP1wiKVswXTsgLy8gUmVtb3ZlIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICByZXR1cm4gYHJhdGVfbGltaXQ6JHtpcH06JHtlbmRwb2ludH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHJhdGUgbGltaXQgZm9yIGEgcmVxdWVzdFxuICAgKi9cbiAgLyoqXG4gICAqIENoZWNrIHJhdGUgbGltaXQgZm9yIGEgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgY2hlY2tSYXRlTGltaXQoXG4gICAgcmVxdWVzdDogRmFzdGlmeVJlcXVlc3QsXG4gICAgY29uZmlnPzogUGFydGlhbDxSYXRlTGltaXRDb25maWc+LFxuICApOiBQcm9taXNlPFJhdGVMaW1pdFJlc3VsdD4ge1xuICAgIGNvbnN0IGZpbmFsQ29uZmlnID0geyAuLi50aGlzLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZyB9O1xuICAgIGNvbnN0IGtleUdlbmVyYXRvciA9IGZpbmFsQ29uZmlnLmtleUdlbmVyYXRvciB8fFxuICAgICAgdGhpcy5kZWZhdWx0S2V5R2VuZXJhdG9yLmJpbmQodGhpcyk7XG4gICAgY29uc3Qga2V5ID0ga2V5R2VuZXJhdG9yKHJlcXVlc3QpO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IG5vdyAtIGZpbmFsQ29uZmlnLndpbmRvd01zO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IGhpdCBjb3VudCBmcm9tIGNhY2hlXG4gICAgICBjb25zdCBjYWNoZVJlc3VsdCA9IGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VyLmdldDxzdHJpbmc+KGtleSk7XG4gICAgICBsZXQgaGl0czogQXJyYXk8eyB0aW1lc3RhbXA6IG51bWJlcjsgc3VjY2Vzcz86IGJvb2xlYW4gfT4gPSBbXTtcblxuICAgICAgaWYgKGNhY2hlUmVzdWx0LnN1Y2Nlc3MgJiYgY2FjaGVSZXN1bHQudmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoaXRzID0gSlNPTi5wYXJzZShjYWNoZVJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhpdHMpKSB7XG4gICAgICAgICAgICBoaXRzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJGYWlsZWQgdG8gcGFyc2UgcmF0ZSBsaW1pdCBkYXRhXCIsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoaXRzID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIGhpdHMgd2l0aGluIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgICAgaGl0cyA9IGhpdHMuZmlsdGVyKChoaXQpID0+IGhpdC50aW1lc3RhbXAgPiB3aW5kb3dTdGFydCk7XG5cbiAgICAgIC8vIENvdW50IHJlbGV2YW50IGhpdHMgYmFzZWQgb24gY29uZmlndXJhdGlvblxuICAgICAgbGV0IHJlbGV2YW50SGl0cyA9IGhpdHMubGVuZ3RoO1xuICAgICAgaWYgKFxuICAgICAgICBmaW5hbENvbmZpZy5za2lwU3VjY2Vzc2Z1bFJlcXVlc3RzIHx8IGZpbmFsQ29uZmlnLnNraXBGYWlsZWRSZXF1ZXN0c1xuICAgICAgKSB7XG4gICAgICAgIHJlbGV2YW50SGl0cyA9IGhpdHMuZmlsdGVyKChoaXQpID0+IHtcbiAgICAgICAgICBpZiAoZmluYWxDb25maWcuc2tpcFN1Y2Nlc3NmdWxSZXF1ZXN0cyAmJiBoaXQuc3VjY2VzcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmluYWxDb25maWcuc2tpcEZhaWxlZFJlcXVlc3RzICYmIGhpdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbGxvd2VkID0gcmVsZXZhbnRIaXRzIDwgZmluYWxDb25maWcubWF4UmVxdWVzdHM7XG4gICAgICBjb25zdCByZW1haW5pbmcgPSBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgZmluYWxDb25maWcubWF4UmVxdWVzdHMgLSByZWxldmFudEhpdHMgLSAoYWxsb3dlZCA/IDEgOiAwKSxcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNldFRpbWUgPSB3aW5kb3dTdGFydCArIGZpbmFsQ29uZmlnLndpbmRvd01zO1xuXG4gICAgICAvLyBBZGQgY3VycmVudCByZXF1ZXN0IHRvIGhpdHMgaWYgd2UncmUgdHJhY2tpbmcgaXRcbiAgICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICAgIGhpdHMucHVzaCh7IHRpbWVzdGFtcDogbm93IH0pO1xuXG4gICAgICAgIC8vIFN0b3JlIHVwZGF0ZWQgaGl0cyB3aXRoIFRUTFxuICAgICAgICBjb25zdCB0dGxNcyA9IE1hdGguY2VpbChmaW5hbENvbmZpZy53aW5kb3dNcyAvIDEwMDApO1xuICAgICAgICBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlci5zZXQoa2V5LCBKU09OLnN0cmluZ2lmeShoaXRzKSwgdHRsTXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd2VkLFxuICAgICAgICByZW1haW5pbmcsXG4gICAgICAgIHJlc2V0VGltZSxcbiAgICAgICAgdG90YWxIaXRzOiBoaXRzLmxlbmd0aCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBcIlJhdGUgbGltaXQgY2hlY2sgZmFpbGVkXCIsXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB7IGtleSB9LFxuICAgICAgKTtcblxuICAgICAgLy8gT24gZXJyb3IsIGFsbG93IHRoZSByZXF1ZXN0IChmYWlsIG9wZW4pXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd2VkOiB0cnVlLFxuICAgICAgICByZW1haW5pbmc6IGZpbmFsQ29uZmlnLm1heFJlcXVlc3RzLFxuICAgICAgICByZXNldFRpbWU6IG5vdyArIGZpbmFsQ29uZmlnLndpbmRvd01zLFxuICAgICAgICB0b3RhbEhpdHM6IDAsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgcmF0ZSBsaW1pdCBhZnRlciByZXNwb25zZSAoZm9yIGNvbmRpdGlvbmFsIGNvdW50aW5nKVxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUmF0ZUxpbWl0KFxuICAgIHJlcXVlc3Q6IEZhc3RpZnlSZXF1ZXN0LFxuICAgIHN1Y2Nlc3M6IGJvb2xlYW4sXG4gICAgY29uZmlnPzogUGFydGlhbDxSYXRlTGltaXRDb25maWc+LFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmaW5hbENvbmZpZyA9IHsgLi4udGhpcy5kZWZhdWx0Q29uZmlnLCAuLi5jb25maWcgfTtcblxuICAgIC8vIE9ubHkgdXBkYXRlIGlmIHdlJ3JlIGNvbmRpdGlvbmFsbHkgY291bnRpbmcgcmVxdWVzdHNcbiAgICBpZiAoXG4gICAgICAhZmluYWxDb25maWcuc2tpcFN1Y2Nlc3NmdWxSZXF1ZXN0cyAmJiAhZmluYWxDb25maWcuc2tpcEZhaWxlZFJlcXVlc3RzXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qga2V5R2VuZXJhdG9yID0gZmluYWxDb25maWcua2V5R2VuZXJhdG9yIHx8XG4gICAgICB0aGlzLmRlZmF1bHRLZXlHZW5lcmF0b3IuYmluZCh0aGlzKTtcbiAgICBjb25zdCBrZXkgPSBrZXlHZW5lcmF0b3IocmVxdWVzdCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FjaGVSZXN1bHQgPSBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlci5nZXQ8c3RyaW5nPihrZXkpO1xuICAgICAgaWYgKCFjYWNoZVJlc3VsdC5zdWNjZXNzIHx8ICFjYWNoZVJlc3VsdC52YWx1ZSkgcmV0dXJuO1xuXG4gICAgICBsZXQgaGl0czogQXJyYXk8eyB0aW1lc3RhbXA6IG51bWJlcjsgc3VjY2Vzcz86IGJvb2xlYW4gfT4gPSBKU09OLnBhcnNlKFxuICAgICAgICBjYWNoZVJlc3VsdC52YWx1ZSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgbW9zdCByZWNlbnQgaGl0IHdpdGggc3VjY2VzcyBzdGF0dXNcbiAgICAgIGlmIChoaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGl0c1toaXRzLmxlbmd0aCAtIDFdLnN1Y2Nlc3MgPSBzdWNjZXNzO1xuXG4gICAgICAgIGNvbnN0IHR0bE1zID0gTWF0aC5jZWlsKGZpbmFsQ29uZmlnLndpbmRvd01zIC8gMTAwMCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FjaGVNYW5hZ2VyLnNldChrZXksIEpTT04uc3RyaW5naWZ5KGhpdHMpLCB0dGxNcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJGYWlsZWQgdG8gdXBkYXRlIHJhdGUgbGltaXRcIiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjcmVhdGVNaWRkbGV3YXJlKGNvbmZpZz86IFBhcnRpYWw8UmF0ZUxpbWl0Q29uZmlnPikge1xuICAgIHJldHVybiBhc3luYyAoXG4gICAgICByZXF1ZXN0OiBGYXN0aWZ5UmVxdWVzdCxcbiAgICAgIHJlcGx5OiBGYXN0aWZ5UmVwbHksXG4gICAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNoZWNrUmF0ZUxpbWl0KHJlcXVlc3QsIGNvbmZpZyk7XG5cbiAgICAgICAgLy8gQWRkIHJhdGUgbGltaXQgaGVhZGVyc1xuICAgICAgICByZXBseS5oZWFkZXIoXG4gICAgICAgICAgXCJYLVJhdGVMaW1pdC1MaW1pdFwiLFxuICAgICAgICAgIChjb25maWc/Lm1heFJlcXVlc3RzIHx8IHRoaXMuZGVmYXVsdENvbmZpZy5tYXhSZXF1ZXN0cykudG9TdHJpbmcoKSxcbiAgICAgICAgKTtcbiAgICAgICAgcmVwbHkuaGVhZGVyKFwiWC1SYXRlTGltaXQtUmVtYWluaW5nXCIsIHJlc3VsdC5yZW1haW5pbmcudG9TdHJpbmcoKSk7XG4gICAgICAgIHJlcGx5LmhlYWRlcihcbiAgICAgICAgICBcIlgtUmF0ZUxpbWl0LVJlc2V0XCIsXG4gICAgICAgICAgTWF0aC5jZWlsKHJlc3VsdC5yZXNldFRpbWUgLyAxMDAwKS50b1N0cmluZygpLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghcmVzdWx0LmFsbG93ZWQpIHtcbiAgICAgICAgICAvLyBMb2cgcmF0ZSBsaW1pdCBleGNlZWRlZFxuICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ1NlY3VyaXR5RXZlbnQoXG4gICAgICAgICAgICBcIlJhdGUgbGltaXQgZXhjZWVkZWRcIixcbiAgICAgICAgICAgIFwibWVkaXVtXCIsXG4gICAgICAgICAgICAocmVxdWVzdCBhcyBhbnkpLmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlwOiByZXF1ZXN0LmlwLFxuICAgICAgICAgICAgICBlbmRwb2ludDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgIHVzZXJBZ2VudDogcmVxdWVzdC5oZWFkZXJzW1widXNlci1hZ2VudFwiXSxcbiAgICAgICAgICAgICAgdG90YWxIaXRzOiByZXN1bHQudG90YWxIaXRzLFxuICAgICAgICAgICAgICBsaW1pdDogY29uZmlnPy5tYXhSZXF1ZXN0cyB8fCB0aGlzLmRlZmF1bHRDb25maWcubWF4UmVxdWVzdHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBDYWxsIGN1c3RvbSBoYW5kbGVyIGlmIHByb3ZpZGVkXG4gICAgICAgICAgaWYgKGNvbmZpZz8ub25MaW1pdFJlYWNoZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5vbkxpbWl0UmVhY2hlZChyZXF1ZXN0LCByZXBseSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcGx5LnN0YXR1cyg0MjkpLnNlbmQoe1xuICAgICAgICAgICAgICBlcnJvcjogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcIlJhdGUgbGltaXQgZXhjZWVkZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIsXG4gICAgICAgICAgICAgIHJldHJ5QWZ0ZXI6IE1hdGguY2VpbCgocmVzdWx0LnJlc2V0VGltZSAtIERhdGUubm93KCkpIC8gMTAwMCksXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXNwb25zZSBob29rIHRvIHVwZGF0ZSByYXRlIGxpbWl0IGlmIHVzaW5nIGNvbmRpdGlvbmFsIGNvdW50aW5nXG4gICAgICAgIGlmIChjb25maWc/LnNraXBTdWNjZXNzZnVsUmVxdWVzdHMgfHwgY29uZmlnPy5za2lwRmFpbGVkUmVxdWVzdHMpIHtcbiAgICAgICAgICAvLyBOb3RlOiBGYXN0aWZ5IGRvZXNuJ3QgaGF2ZSBhZGRIb29rIG9uIHJlcGx5LCB3ZSBuZWVkIHRvIHVzZSBhIGRpZmZlcmVudCBhcHByb2FjaFxuICAgICAgICAgIC8vIEZvciBub3csIHdlJ2xsIHNraXAgdGhpcyBmdW5jdGlvbmFsaXR5IGluIHRoZSBtaWRkbGV3YXJlXG4gICAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGJlIGhhbmRsZWQgYXQgdGhlIHJvdXRlIGxldmVsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2cgcmF0ZSBsaW1pdCBjaGVja1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxuICAgICAgICAgIFwiUmF0ZSBsaW1pdCBjaGVjayBjb21wbGV0ZWRcIixcbiAgICAgICAgICAocmVxdWVzdCBhcyBhbnkpLmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXA6IHJlcXVlc3QuaXAsXG4gICAgICAgICAgICBlbmRwb2ludDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICBhbGxvd2VkOiByZXN1bHQuYWxsb3dlZCxcbiAgICAgICAgICAgIHJlbWFpbmluZzogcmVzdWx0LnJlbWFpbmluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZG9uZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgXCJSYXRlIGxpbWl0IG1pZGRsZXdhcmUgZXJyb3JcIixcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSksXG4gICAgICAgICAgKHJlcXVlc3QgYXMgYW55KS5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlwOiByZXF1ZXN0LmlwLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IHJlcXVlc3QudXJsLFxuICAgICAgICAgIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gT24gZXJyb3IsIGFsbG93IHRoZSByZXF1ZXN0IChmYWlsIG9wZW4pXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgZW5kcG9pbnQtc3BlY2lmaWMgcmF0ZSBsaW1pdGluZyBtaWRkbGV3YXJlXG4gICAqL1xuICBjcmVhdGVFbmRwb2ludE1pZGRsZXdhcmUoXG4gICAgZW5kcG9pbnRDb25maWdzOiBSZWNvcmQ8c3RyaW5nLCBQYXJ0aWFsPFJhdGVMaW1pdENvbmZpZz4+LFxuICApIHtcbiAgICByZXR1cm4gYXN5bmMgKFxuICAgICAgcmVxdWVzdDogRmFzdGlmeVJlcXVlc3QsXG4gICAgICByZXBseTogRmFzdGlmeVJlcGx5LFxuICAgICk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3QgZW5kcG9pbnQgPSByZXF1ZXN0LnVybC5zcGxpdChcIj9cIilbMF07IC8vIFJlbW92ZSBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICBjb25zdCBjb25maWcgPSBlbmRwb2ludENvbmZpZ3NbZW5kcG9pbnRdO1xuXG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAvLyBObyBzcGVjaWZpYyBjb25maWcgZm9yIHRoaXMgZW5kcG9pbnQsIHVzZSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaWRkbGV3YXJlID0gdGhpcy5jcmVhdGVNaWRkbGV3YXJlKCk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TWlkZGxld2FyZShyZXF1ZXN0LCByZXBseSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVuZHBvaW50TWlkZGxld2FyZSA9IHRoaXMuY3JlYXRlTWlkZGxld2FyZShjb25maWcpO1xuICAgICAgcmV0dXJuIGVuZHBvaW50TWlkZGxld2FyZShyZXF1ZXN0LCByZXBseSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCByYXRlIGxpbWl0IGZvciBhIHNwZWNpZmljIGtleVxuICAgKi9cbiAgYXN5bmMgcmVzZXRSYXRlTGltaXQoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jYWNoZU1hbmFnZXIuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKFwiUmF0ZSBsaW1pdCByZXNldFwiLCB1bmRlZmluZWQsIHsga2V5IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzZXQgcmF0ZSBsaW1pdFwiLFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSksXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgeyBrZXkgfSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCByYXRlIGxpbWl0IHN0YXR1cyBmb3IgYSBrZXlcbiAgICovXG4gIGFzeW5jIGdldFJhdGVMaW1pdFN0YXR1cyhrZXk6IHN0cmluZyk6IFByb21pc2U8XG4gICAge1xuICAgICAgaGl0czogbnVtYmVyO1xuICAgICAgcmVtYWluaW5nOiBudW1iZXI7XG4gICAgICByZXNldFRpbWU6IG51bWJlcjtcbiAgICB9IHwgbnVsbFxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FjaGVSZXN1bHQgPSBhd2FpdCB0aGlzLmNhY2hlTWFuYWdlci5nZXQ8c3RyaW5nPihrZXkpO1xuICAgICAgaWYgKCFjYWNoZVJlc3VsdC5zdWNjZXNzIHx8ICFjYWNoZVJlc3VsdC52YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhpdHM6IDAsXG4gICAgICAgICAgcmVtYWluaW5nOiB0aGlzLmRlZmF1bHRDb25maWcubWF4UmVxdWVzdHMsXG4gICAgICAgICAgcmVzZXRUaW1lOiBEYXRlLm5vdygpICsgdGhpcy5kZWZhdWx0Q29uZmlnLndpbmRvd01zLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoaXRzOiBBcnJheTx7IHRpbWVzdGFtcDogbnVtYmVyIH0+ID0gSlNPTi5wYXJzZShjYWNoZVJlc3VsdC52YWx1ZSk7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3Qgd2luZG93U3RhcnQgPSBub3cgLSB0aGlzLmRlZmF1bHRDb25maWcud2luZG93TXM7XG4gICAgICBjb25zdCB2YWxpZEhpdHMgPSBoaXRzLmZpbHRlcigoaGl0KSA9PiBoaXQudGltZXN0YW1wID4gd2luZG93U3RhcnQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoaXRzOiB2YWxpZEhpdHMubGVuZ3RoLFxuICAgICAgICByZW1haW5pbmc6IE1hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnLm1heFJlcXVlc3RzIC0gdmFsaWRIaXRzLmxlbmd0aCxcbiAgICAgICAgKSxcbiAgICAgICAgcmVzZXRUaW1lOiB3aW5kb3dTdGFydCArIHRoaXMuZGVmYXVsdENvbmZpZy53aW5kb3dNcyxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBnZXQgcmF0ZSBsaW1pdCBzdGF0dXNcIixcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHsga2V5IH0sXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCByYXRlIGxpbWl0IGNvbmZpZ3VyYXRpb25zIGZvciBkaWZmZXJlbnQgZW5kcG9pbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VORFBPSU5UX0NPTkZJR1M6IFJlY29yZDxcbiAgc3RyaW5nLFxuICBQYXJ0aWFsPFJhdGVMaW1pdENvbmZpZz5cbj4gPSB7XG4gIFwiL3NpZ25hbFwiOiB7XG4gICAgd2luZG93TXM6IDYwMDAwLCAvLyAxIG1pbnV0ZVxuICAgIG1heFJlcXVlc3RzOiA2MCwgLy8gNjAgc2lnbmFscyBwZXIgbWludXRlXG4gICAgc2tpcEZhaWxlZFJlcXVlc3RzOiB0cnVlLCAvLyBEb24ndCBjb3VudCBmYWlsZWQgc2lnbmFsc1xuICB9LFxuICBcIi93ZWJob29rL3BoYXNlMVwiOiB7XG4gICAgd2luZG93TXM6IDYwMDAwLCAvLyAxIG1pbnV0ZVxuICAgIG1heFJlcXVlc3RzOiAxMjAsIC8vIDEyMCB3ZWJob29rcyBwZXIgbWludXRlXG4gICAgc2tpcEZhaWxlZFJlcXVlc3RzOiB0cnVlLFxuICB9LFxuICBcIi93ZWJob29rL3BoYXNlMlwiOiB7XG4gICAgd2luZG93TXM6IDYwMDAwLCAvLyAxIG1pbnV0ZVxuICAgIG1heFJlcXVlc3RzOiA2MCwgLy8gNjAgd2ViaG9va3MgcGVyIG1pbnV0ZVxuICAgIHNraXBGYWlsZWRSZXF1ZXN0czogdHJ1ZSxcbiAgfSxcbiAgXCIvd2ViaG9vay9waGFzZTNcIjoge1xuICAgIHdpbmRvd01zOiA2MDAwMCwgLy8gMSBtaW51dGVcbiAgICBtYXhSZXF1ZXN0czogMzAsIC8vIDMwIHdlYmhvb2tzIHBlciBtaW51dGVcbiAgICBza2lwRmFpbGVkUmVxdWVzdHM6IHRydWUsXG4gIH0sXG4gIFwiL2FkbWluL292ZXJyaWRlXCI6IHtcbiAgICB3aW5kb3dNczogMzAwMDAwLCAvLyA1IG1pbnV0ZXNcbiAgICBtYXhSZXF1ZXN0czogNSwgLy8gNSBvdmVycmlkZSBhdHRlbXB0cyBwZXIgNSBtaW51dGVzXG4gICAgc2tpcFN1Y2Nlc3NmdWxSZXF1ZXN0czogZmFsc2UsXG4gICAgc2tpcEZhaWxlZFJlcXVlc3RzOiBmYWxzZSxcbiAgfSxcbiAgXCIvYnJlYWtlci9yZXNldFwiOiB7XG4gICAgd2luZG93TXM6IDMwMDAwMCwgLy8gNSBtaW51dGVzXG4gICAgbWF4UmVxdWVzdHM6IDEwLCAvLyAxMCByZXNldCBhdHRlbXB0cyBwZXIgNSBtaW51dGVzXG4gICAgc2tpcFN1Y2Nlc3NmdWxSZXF1ZXN0czogZmFsc2UsXG4gICAgc2tpcEZhaWxlZFJlcXVlc3RzOiBmYWxzZSxcbiAgfSxcbiAgXCIvZGFzaGJvYXJkXCI6IHtcbiAgICB3aW5kb3dNczogNjAwMDAsIC8vIDEgbWludXRlXG4gICAgbWF4UmVxdWVzdHM6IDMwMCwgLy8gMzAwIGRhc2hib2FyZCByZXF1ZXN0cyBwZXIgbWludXRlXG4gICAgc2tpcEZhaWxlZFJlcXVlc3RzOiB0cnVlLFxuICB9LFxuICBcIi9tZXRyaWNzXCI6IHtcbiAgICB3aW5kb3dNczogNjAwMDAsIC8vIDEgbWludXRlXG4gICAgbWF4UmVxdWVzdHM6IDYwMCwgLy8gNjAwIG1ldHJpY3MgcmVxdWVzdHMgcGVyIG1pbnV0ZSAoZm9yIG1vbml0b3JpbmcpXG4gICAgc2tpcEZhaWxlZFJlcXVlc3RzOiB0cnVlLFxuICB9LFxufTtcblxuLyoqXG4gKiBSYXRlIGxpbWl0ZXIgcGx1Z2luIGZvciBGYXN0aWZ5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByYXRlTGltaXRlclBsdWdpbihcbiAgZmFzdGlmeTogYW55LFxuICBvcHRpb25zOiB7XG4gICAgY2FjaGVNYW5hZ2VyOiBDYWNoZU1hbmFnZXI7XG4gICAgbG9nZ2VyOiBMb2dnZXI7XG4gICAgZGVmYXVsdENvbmZpZz86IFJhdGVMaW1pdENvbmZpZztcbiAgICBlbmRwb2ludENvbmZpZ3M/OiBSZWNvcmQ8c3RyaW5nLCBQYXJ0aWFsPFJhdGVMaW1pdENvbmZpZz4+O1xuICB9LFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJhdGVMaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyKFxuICAgIG9wdGlvbnMuY2FjaGVNYW5hZ2VyLFxuICAgIG9wdGlvbnMubG9nZ2VyLFxuICAgIG9wdGlvbnMuZGVmYXVsdENvbmZpZyB8fCB7XG4gICAgICB3aW5kb3dNczogNjAwMDAsXG4gICAgICBtYXhSZXF1ZXN0czogMTAwLFxuICAgIH0sXG4gICk7XG5cbiAgY29uc3QgZW5kcG9pbnRDb25maWdzID0gb3B0aW9ucy5lbmRwb2ludENvbmZpZ3MgfHwgREVGQVVMVF9FTkRQT0lOVF9DT05GSUdTO1xuICBjb25zdCBtaWRkbGV3YXJlID0gcmF0ZUxpbWl0ZXIuY3JlYXRlRW5kcG9pbnRNaWRkbGV3YXJlKGVuZHBvaW50Q29uZmlncyk7XG5cbiAgZmFzdGlmeS5hZGRIb29rKFwicHJlSGFuZGxlclwiLCBtaWRkbGV3YXJlKTtcblxuICAvLyBBZGQgcmF0ZSBsaW1pdGVyIGluc3RhbmNlIHRvIGZhc3RpZnkgZm9yIGFjY2VzcyBpbiByb3V0ZXNcbiAgZmFzdGlmeS5kZWNvcmF0ZShcInJhdGVMaW1pdGVyXCIsIHJhdGVMaW1pdGVyKTtcbn1cbiJdLCJ2ZXJzaW9uIjozfQ==