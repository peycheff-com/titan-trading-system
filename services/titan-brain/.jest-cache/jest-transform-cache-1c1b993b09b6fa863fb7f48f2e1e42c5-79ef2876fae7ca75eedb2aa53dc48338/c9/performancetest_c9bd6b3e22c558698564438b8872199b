b32fa5eaed3fd5586ca58728d7097c49
"use strict";
/**
 * Performance validation tests for Titan Brain
 *
 * Tests performance requirements under load:
 * - Cache operations performance
 * - Memory usage stability
 * - No memory leaks detected
 */
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const CacheManager_js_1 = require("../../src/cache/CacheManager.js");
describe('Performance Validation Tests', () => {
    describe('Cache Performance', () => {
        let cacheManager;
        beforeAll(async () => {
            cacheManager = new CacheManager_js_1.CacheManager({
                redis: {
                    host: 'localhost',
                    port: 6379
                },
                enableInMemoryFallback: true,
                inMemoryMaxSize: 1000,
                inMemoryTtlMs: 300000, // 5 minutes
                healthCheckIntervalMs: 30000,
                healthCheckTimeoutMs: 5000,
                maxReconnectAttempts: 3,
                reconnectDelayMs: 1000
            });
            await cacheManager.initialize();
        });
        afterAll(async () => {
            if (cacheManager) {
                await cacheManager.shutdown();
            }
        });
        it('should handle high-frequency cache operations', async () => {
            const operations = 1000;
            const start = perf_hooks_1.performance.now();
            // Perform mixed cache operations
            for (let i = 0; i < operations; i++) {
                const key = `test-key-${i % 100}`; // Reuse keys to test overwrites
                const value = { data: `test-value-${i}`, timestamp: Date.now() };
                await cacheManager.set(key, value, 60000); // 1 minute TTL
                if (i % 10 === 0) {
                    await cacheManager.get(key);
                }
            }
            const end = perf_hooks_1.performance.now();
            const totalTime = end - start;
            const avgOperationTime = totalTime / operations;
            console.log(`Cache performance:
        Total time for ${operations} operations: ${totalTime.toFixed(2)}ms
        Average operation time: ${avgOperationTime.toFixed(3)}ms`);
            expect(avgOperationTime).toBeLessThan(5); // < 5ms per operation (more realistic)
            expect(totalTime).toBeLessThan(10000); // Total < 10 seconds
        }, 15000);
        it('should handle concurrent cache operations', async () => {
            const concurrentOps = 50;
            const promises = [];
            for (let i = 0; i < concurrentOps; i++) {
                promises.push((async () => {
                    const start = perf_hooks_1.performance.now();
                    try {
                        const key = `concurrent-key-${i}`;
                        const value = { id: i, data: `concurrent-data-${i}` };
                        await cacheManager.set(key, value, 30000);
                        const retrieved = await cacheManager.get(key);
                        const end = perf_hooks_1.performance.now();
                        expect(retrieved).toBeDefined();
                        return end - start;
                    }
                    catch (error) {
                        console.warn(`Concurrent cache operation ${i + 1} failed:`, error);
                        return 1000; // Return high time for failed operations
                    }
                })());
            }
            const operationTimes = await Promise.all(promises);
            const successfulOps = operationTimes.filter(time => time < 1000);
            // At least 90% of operations should succeed
            expect(successfulOps.length).toBeGreaterThanOrEqual(concurrentOps * 0.9);
            // Average time should be reasonable under concurrent load
            const avgOpTime = successfulOps.reduce((a, b) => a + b, 0) / successfulOps.length;
            expect(avgOpTime).toBeLessThan(100); // < 100ms under concurrent load
        }, 15000);
    });
    describe('Memory Usage', () => {
        it('should maintain stable memory usage', async () => {
            const initialMemory = process.memoryUsage();
            const memorySnapshots = [initialMemory];
            // Perform memory-intensive operations
            for (let i = 0; i < 100; i++) {
                // Create and discard objects to test garbage collection
                const largeArray = new Array(10000).fill(0).map((_, idx) => ({
                    id: idx,
                    data: `test-data-${idx}`,
                    timestamp: Date.now()
                }));
                // Force some async operations
                await new Promise(resolve => setTimeout(resolve, 10));
                // Take memory snapshot every 20 iterations
                if (i % 20 === 0) {
                    // Force garbage collection if available
                    if (global.gc) {
                        global.gc();
                    }
                    memorySnapshots.push(process.memoryUsage());
                }
            }
            const finalMemory = process.memoryUsage();
            const memoryGrowth = finalMemory.heapUsed - initialMemory.heapUsed;
            const memoryGrowthMB = memoryGrowth / (1024 * 1024);
            console.log(`Memory usage:
        Initial heap: ${(initialMemory.heapUsed / 1024 / 1024).toFixed(2)} MB
        Final heap: ${(finalMemory.heapUsed / 1024 / 1024).toFixed(2)} MB
        Growth: ${memoryGrowthMB.toFixed(2)} MB`);
            // Memory growth should be reasonable (< 100MB for this test)
            // Note: TypeScript compilation and Jest overhead can cause higher memory usage
            expect(memoryGrowthMB).toBeLessThan(100);
            // Heap usage should not exceed 200MB
            expect(finalMemory.heapUsed / 1024 / 1024).toBeLessThan(200);
        }, 15000);
        it('should not have significant memory leaks', async () => {
            const iterations = 50;
            const memoryReadings = [];
            for (let i = 0; i < iterations; i++) {
                // Create temporary objects
                const tempData = new Array(1000).fill(0).map((_, idx) => ({
                    id: `temp-${i}-${idx}`,
                    data: new Array(100).fill(`data-${i}-${idx}`),
                    timestamp: Date.now()
                }));
                // Use the data briefly
                const processed = tempData.filter(item => item.id.includes('temp'));
                expect(processed.length).toBe(1000);
                // Clear references
                tempData.length = 0;
                // Force garbage collection every 10 iterations
                if (i % 10 === 0 && global.gc) {
                    global.gc();
                    memoryReadings.push(process.memoryUsage().heapUsed);
                }
                await new Promise(resolve => setTimeout(resolve, 5));
            }
            // Check that memory usage doesn't continuously grow
            if (memoryReadings.length >= 3) {
                const firstReading = memoryReadings[0];
                const lastReading = memoryReadings[memoryReadings.length - 1];
                const memoryGrowth = (lastReading - firstReading) / (1024 * 1024);
                console.log(`Memory leak test:
          First reading: ${(firstReading / 1024 / 1024).toFixed(2)} MB
          Last reading: ${(lastReading / 1024 / 1024).toFixed(2)} MB
          Growth: ${memoryGrowth.toFixed(2)} MB`);
                // Memory growth should be minimal (< 20MB)
                expect(memoryGrowth).toBeLessThan(20);
            }
        }, 20000);
    });
    describe('CPU Performance', () => {
        it('should handle CPU-intensive operations efficiently', async () => {
            const iterations = 1000;
            const start = perf_hooks_1.performance.now();
            // Simulate CPU-intensive calculations
            let result = 0;
            for (let i = 0; i < iterations; i++) {
                // Mathematical operations
                result += Math.sqrt(i) * Math.sin(i) * Math.cos(i);
                // String operations
                const str = `test-string-${i}`;
                const processed = str.split('-').map(s => s.toUpperCase()).join('_');
                // Object operations
                const obj = { id: i, value: processed, timestamp: Date.now() };
                const serialized = JSON.stringify(obj);
                const deserialized = JSON.parse(serialized);
                expect(deserialized.id).toBe(i);
            }
            const end = perf_hooks_1.performance.now();
            const totalTime = end - start;
            const avgOperationTime = totalTime / iterations;
            console.log(`CPU performance:
        Total time for ${iterations} operations: ${totalTime.toFixed(2)}ms
        Average operation time: ${avgOperationTime.toFixed(3)}ms
        Result: ${result.toFixed(2)}`);
            expect(avgOperationTime).toBeLessThan(1); // < 1ms per operation
            expect(totalTime).toBeLessThan(2000); // Total < 2 seconds
        }, 10000);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3Rlc3RzL3BlcmZvcm1hbmNlL3BlcmZvcm1hbmNlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7O0dBT0c7O0FBRUgsMkNBQXlDO0FBQ3pDLHFFQUErRDtBQUUvRCxRQUFRLENBQUMsOEJBQThCLEVBQUUsR0FBRyxFQUFFO0lBQzVDLFFBQVEsQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLEVBQUU7UUFDakMsSUFBSSxZQUEwQixDQUFDO1FBRS9CLFNBQVMsQ0FBQyxLQUFLLElBQUksRUFBRTtZQUNuQixZQUFZLEdBQUcsSUFBSSw4QkFBWSxDQUFDO2dCQUM5QixLQUFLLEVBQUU7b0JBQ0wsSUFBSSxFQUFFLFdBQVc7b0JBQ2pCLElBQUksRUFBRSxJQUFJO2lCQUNYO2dCQUNELHNCQUFzQixFQUFFLElBQUk7Z0JBQzVCLGVBQWUsRUFBRSxJQUFJO2dCQUNyQixhQUFhLEVBQUUsTUFBTSxFQUFFLFlBQVk7Z0JBQ25DLHFCQUFxQixFQUFFLEtBQUs7Z0JBQzVCLG9CQUFvQixFQUFFLElBQUk7Z0JBQzFCLG9CQUFvQixFQUFFLENBQUM7Z0JBQ3ZCLGdCQUFnQixFQUFFLElBQUk7YUFDdkIsQ0FBQyxDQUFDO1lBRUgsTUFBTSxZQUFZLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDbEIsSUFBSSxZQUFZLEVBQUUsQ0FBQztnQkFDakIsTUFBTSxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDaEMsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLCtDQUErQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQztZQUN4QixNQUFNLEtBQUssR0FBRyx3QkFBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBRWhDLGlDQUFpQztZQUNqQyxLQUFLLElBQUks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QUcsS0FBSyxDQUFDO1lBQzlCLE1BQU0sZ0JBQWdCLEdBQUcsU0FBUyxHQUFHLFVBQVUsQ0FBQztZQUVoRCxPQUFPLENBQUMsR0FBRyxDQUFDO3lCQUNPLFVBQVUsZ0JBQWdCLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2tDQUNyQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2tCQUMzQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUVqQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxzQkFBc0I7WUFDaEUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLG9CQUFvQjtRQUM1RCxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDWixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9pdmFuL0NvZGUvdHJhZGluZy90aXRhbi9zZXJ2aWNlcy90aXRhbi1icmFpbi90ZXN0cy9wZXJmb3JtYW5jZS9wZXJmb3JtYW5jZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGVyZm9ybWFuY2UgdmFsaWRhdGlvbiB0ZXN0cyBmb3IgVGl0YW4gQnJhaW5cbiAqIFxuICogVGVzdHMgcGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzIHVuZGVyIGxvYWQ6XG4gKiAtIENhY2hlIG9wZXJhdGlvbnMgcGVyZm9ybWFuY2VcbiAqIC0gTWVtb3J5IHVzYWdlIHN0YWJpbGl0eVxuICogLSBObyBtZW1vcnkgbGVha3MgZGV0ZWN0ZWRcbiAqL1xuXG5pbXBvcnQgeyBwZXJmb3JtYW5jZSB9IGZyb20gJ3BlcmZfaG9va3MnO1xuaW1wb3J0IHsgQ2FjaGVNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vc3JjL2NhY2hlL0NhY2hlTWFuYWdlci5qcyc7XG5cbmRlc2NyaWJlKCdQZXJmb3JtYW5jZSBWYWxpZGF0aW9uIFRlc3RzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnQ2FjaGUgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgbGV0IGNhY2hlTWFuYWdlcjogQ2FjaGVNYW5hZ2VyO1xuXG4gICAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAgIGNhY2hlTWFuYWdlciA9IG5ldyBDYWNoZU1hbmFnZXIoe1xuICAgICAgICByZWRpczoge1xuICAgICAgICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgIHBvcnQ6IDYzNzlcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlSW5NZW1vcnlGYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgaW5NZW1vcnlNYXhTaXplOiAxMDAwLFxuICAgICAgICBpbk1lbW9yeVR0bE1zOiAzMDAwMDAsIC8vIDUgbWludXRlc1xuICAgICAgICBoZWFsdGhDaGVja0ludGVydmFsTXM6IDMwMDAwLFxuICAgICAgICBoZWFsdGhDaGVja1RpbWVvdXRNczogNTAwMCxcbiAgICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IDMsXG4gICAgICAgIHJlY29ubmVjdERlbGF5TXM6IDEwMDBcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBjYWNoZU1hbmFnZXIuaW5pdGlhbGl6ZSgpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGNhY2hlTWFuYWdlcikge1xuICAgICAgICBhd2FpdCBjYWNoZU1hbmFnZXIuc2h1dGRvd24oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGhpZ2gtZnJlcXVlbmN5IGNhY2hlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcGVyYXRpb25zID0gMTAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIFBlcmZvcm0gbWl4ZWQgY2FjaGUgb3BlcmF0aW9uc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYHRlc3Qta2V5LSR7aSAlIDEwMH1gOyAvLyBSZXVzZSBrZXlzIHRvIHRlc3Qgb3ZlcndyaXRlc1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHsgZGF0YTogYHRlc3QtdmFsdWUtJHtpfWAsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgY2FjaGVNYW5hZ2VyLnNldChrZXksIHZhbHVlLCA2MDAwMCk7IC8vIDEgbWludXRlIFRUTFxuICAgICAgICBcbiAgICAgICAgaWYgKGkgJSAxMCA9PT0gMCkge1xuICAgICAgICAgIGF3YWl0IGNhY2hlTWFuYWdlci5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgY29uc3QgYXZnT3BlcmF0aW9uVGltZSA9IHRvdGFsVGltZSAvIG9wZXJhdGlvbnM7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBwZXJmb3JtYW5jZTpcbiAgICAgICAgVG90YWwgdGltZSBmb3IgJHtvcGVyYXRpb25zfSBvcGVyYXRpb25zOiAke3RvdGFsVGltZS50b0ZpeGVkKDIpfW1zXG4gICAgICAgIEF2ZXJhZ2Ugb3BlcmF0aW9uIHRpbWU6ICR7YXZnT3BlcmF0aW9uVGltZS50b0ZpeGVkKDMpfW1zYCk7XG5cbiAgICAgIGV4cGVjdChhdmdPcGVyYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oNSk7IC8vIDwgNW1zIHBlciBvcGVyYXRpb24gKG1vcmUgcmVhbGlzdGljKVxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDEwMDAwKTsgLy8gVG90YWwgPCAxMCBzZWNvbmRzXG4gICAgfSwgMTUwMDApO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBjYWNoZSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uY3VycmVudE9wcyA9IDUwO1xuICAgICAgY29uc3QgcHJvbWlzZXM6IFByb21pc2U8bnVtYmVyPltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uY3VycmVudE9wczsgaSsrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgY29uY3VycmVudC1rZXktJHtpfWA7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0geyBpZDogaSwgZGF0YTogYGNvbmN1cnJlbnQtZGF0YS0ke2l9YCB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgYXdhaXQgY2FjaGVNYW5hZ2VyLnNldChrZXksIHZhbHVlLCAzMDAwMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHJldHJpZXZlZCA9IGF3YWl0IGNhY2hlTWFuYWdlci5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZXhwZWN0KHJldHJpZXZlZCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb25jdXJyZW50IGNhY2hlIG9wZXJhdGlvbiAke2kgKyAxfSBmYWlsZWQ6YCwgZXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm4gMTAwMDsgLy8gUmV0dXJuIGhpZ2ggdGltZSBmb3IgZmFpbGVkIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wZXJhdGlvblRpbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgY29uc3Qgc3VjY2Vzc2Z1bE9wcyA9IG9wZXJhdGlvblRpbWVzLmZpbHRlcih0aW1lID0+IHRpbWUgPCAxMDAwKTtcbiAgICAgIFxuICAgICAgLy8gQXQgbGVhc3QgOTAlIG9mIG9wZXJhdGlvbnMgc2hvdWxkIHN1Y2NlZWRcbiAgICAgIGV4cGVjdChzdWNjZXNzZnVsT3BzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChjb25jdXJyZW50T3BzICogMC45KTtcbiAgICAgIFxuICAgICAgLy8gQXZlcmFnZSB0aW1lIHNob3VsZCBiZSByZWFzb25hYmxlIHVuZGVyIGNvbmN1cnJlbnQgbG9hZFxuICAgICAgY29uc3QgYXZnT3BUaW1lID0gc3VjY2Vzc2Z1bE9wcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHN1Y2Nlc3NmdWxPcHMubGVuZ3RoO1xuICAgICAgZXhwZWN0KGF2Z09wVGltZSkudG9CZUxlc3NUaGFuKDEwMCk7IC8vIDwgMTAwbXMgdW5kZXIgY29uY3VycmVudCBsb2FkXG4gICAgfSwgMTUwMDApO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWVtb3J5IFVzYWdlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gc3RhYmxlIG1lbW9yeSB1c2FnZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICBjb25zdCBtZW1vcnlTbmFwc2hvdHM6IE5vZGVKUy5NZW1vcnlVc2FnZVtdID0gW2luaXRpYWxNZW1vcnldO1xuXG4gICAgICAvLyBQZXJmb3JtIG1lbW9yeS1pbnRlbnNpdmUgb3BlcmF0aW9uc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAvLyBDcmVhdGUgYW5kIGRpc2NhcmQgb2JqZWN0cyB0byB0ZXN0IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICBjb25zdCBsYXJnZUFycmF5ID0gbmV3IEFycmF5KDEwMDAwKS5maWxsKDApLm1hcCgoXywgaWR4KSA9PiAoe1xuICAgICAgICAgIGlkOiBpZHgsXG4gICAgICAgICAgZGF0YTogYHRlc3QtZGF0YS0ke2lkeH1gLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBzb21lIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUYWtlIG1lbW9yeSBzbmFwc2hvdCBldmVyeSAyMCBpdGVyYXRpb25zXG4gICAgICAgIGlmIChpICUgMjAgPT09IDApIHtcbiAgICAgICAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKGdsb2JhbC5nYykge1xuICAgICAgICAgICAgZ2xvYmFsLmdjKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbW9yeVNuYXBzaG90cy5wdXNoKHByb2Nlc3MubWVtb3J5VXNhZ2UoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICBjb25zdCBtZW1vcnlHcm93dGggPSBmaW5hbE1lbW9yeS5oZWFwVXNlZCAtIGluaXRpYWxNZW1vcnkuaGVhcFVzZWQ7XG4gICAgICBjb25zdCBtZW1vcnlHcm93dGhNQiA9IG1lbW9yeUdyb3d0aCAvICgxMDI0ICogMTAyNCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBNZW1vcnkgdXNhZ2U6XG4gICAgICAgIEluaXRpYWwgaGVhcDogJHsoaW5pdGlhbE1lbW9yeS5oZWFwVXNlZCAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQlxuICAgICAgICBGaW5hbCBoZWFwOiAkeyhmaW5hbE1lbW9yeS5oZWFwVXNlZCAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQlxuICAgICAgICBHcm93dGg6ICR7bWVtb3J5R3Jvd3RoTUIudG9GaXhlZCgyKX0gTUJgKTtcblxuICAgICAgLy8gTWVtb3J5IGdyb3d0aCBzaG91bGQgYmUgcmVhc29uYWJsZSAoPCAxMDBNQiBmb3IgdGhpcyB0ZXN0KVxuICAgICAgLy8gTm90ZTogVHlwZVNjcmlwdCBjb21waWxhdGlvbiBhbmQgSmVzdCBvdmVyaGVhZCBjYW4gY2F1c2UgaGlnaGVyIG1lbW9yeSB1c2FnZVxuICAgICAgZXhwZWN0KG1lbW9yeUdyb3d0aE1CKS50b0JlTGVzc1RoYW4oMTAwKTtcbiAgICAgIFxuICAgICAgLy8gSGVhcCB1c2FnZSBzaG91bGQgbm90IGV4Y2VlZCAyMDBNQlxuICAgICAgZXhwZWN0KGZpbmFsTWVtb3J5LmhlYXBVc2VkIC8gMTAyNCAvIDEwMjQpLnRvQmVMZXNzVGhhbigyMDApO1xuICAgIH0sIDE1MDAwKTtcblxuICAgIGl0KCdzaG91bGQgbm90IGhhdmUgc2lnbmlmaWNhbnQgbWVtb3J5IGxlYWtzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDUwO1xuICAgICAgY29uc3QgbWVtb3J5UmVhZGluZ3M6IG51bWJlcltdID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0ZW1wb3Jhcnkgb2JqZWN0c1xuICAgICAgICBjb25zdCB0ZW1wRGF0YSA9IG5ldyBBcnJheSgxMDAwKS5maWxsKDApLm1hcCgoXywgaWR4KSA9PiAoe1xuICAgICAgICAgIGlkOiBgdGVtcC0ke2l9LSR7aWR4fWAsXG4gICAgICAgICAgZGF0YTogbmV3IEFycmF5KDEwMCkuZmlsbChgZGF0YS0ke2l9LSR7aWR4fWApLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBkYXRhIGJyaWVmbHlcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gdGVtcERhdGEuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZC5pbmNsdWRlcygndGVtcCcpKTtcbiAgICAgICAgZXhwZWN0KHByb2Nlc3NlZC5sZW5ndGgpLnRvQmUoMTAwMCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgcmVmZXJlbmNlc1xuICAgICAgICB0ZW1wRGF0YS5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIEZvcmNlIGdhcmJhZ2UgY29sbGVjdGlvbiBldmVyeSAxMCBpdGVyYXRpb25zXG4gICAgICAgIGlmIChpICUgMTAgPT09IDAgJiYgZ2xvYmFsLmdjKSB7XG4gICAgICAgICAgZ2xvYmFsLmdjKCk7XG4gICAgICAgICAgbWVtb3J5UmVhZGluZ3MucHVzaChwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdGhhdCBtZW1vcnkgdXNhZ2UgZG9lc24ndCBjb250aW51b3VzbHkgZ3Jvd1xuICAgICAgaWYgKG1lbW9yeVJlYWRpbmdzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0UmVhZGluZyA9IG1lbW9yeVJlYWRpbmdzWzBdO1xuICAgICAgICBjb25zdCBsYXN0UmVhZGluZyA9IG1lbW9yeVJlYWRpbmdzW21lbW9yeVJlYWRpbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBtZW1vcnlHcm93dGggPSAobGFzdFJlYWRpbmcgLSBmaXJzdFJlYWRpbmcpIC8gKDEwMjQgKiAxMDI0KTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgTWVtb3J5IGxlYWsgdGVzdDpcbiAgICAgICAgICBGaXJzdCByZWFkaW5nOiAkeyhmaXJzdFJlYWRpbmcgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX0gTUJcbiAgICAgICAgICBMYXN0IHJlYWRpbmc6ICR7KGxhc3RSZWFkaW5nIC8gMTAyNCAvIDEwMjQpLnRvRml4ZWQoMil9IE1CXG4gICAgICAgICAgR3Jvd3RoOiAke21lbW9yeUdyb3d0aC50b0ZpeGVkKDIpfSBNQmApO1xuXG4gICAgICAgIC8vIE1lbW9yeSBncm93dGggc2hvdWxkIGJlIG1pbmltYWwgKDwgMjBNQilcbiAgICAgICAgZXhwZWN0KG1lbW9yeUdyb3d0aCkudG9CZUxlc3NUaGFuKDIwKTtcbiAgICAgIH1cbiAgICB9LCAyMDAwMCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDUFUgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQ1BVLWludGVuc2l2ZSBvcGVyYXRpb25zIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDEwMDA7XG4gICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBDUFUtaW50ZW5zaXZlIGNhbGN1bGF0aW9uc1xuICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAvLyBNYXRoZW1hdGljYWwgb3BlcmF0aW9uc1xuICAgICAgICByZXN1bHQgKz0gTWF0aC5zcXJ0KGkpICogTWF0aC5zaW4oaSkgKiBNYXRoLmNvcyhpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0cmluZyBvcGVyYXRpb25zXG4gICAgICAgIGNvbnN0IHN0ciA9IGB0ZXN0LXN0cmluZy0ke2l9YDtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gc3RyLnNwbGl0KCctJykubWFwKHMgPT4gcy50b1VwcGVyQ2FzZSgpKS5qb2luKCdfJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBPYmplY3Qgb3BlcmF0aW9uc1xuICAgICAgICBjb25zdCBvYmogPSB7IGlkOiBpLCB2YWx1ZTogcHJvY2Vzc2VkLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoZGVzZXJpYWxpemVkLmlkKS50b0JlKGkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgY29uc3QgYXZnT3BlcmF0aW9uVGltZSA9IHRvdGFsVGltZSAvIGl0ZXJhdGlvbnM7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBDUFUgcGVyZm9ybWFuY2U6XG4gICAgICAgIFRvdGFsIHRpbWUgZm9yICR7aXRlcmF0aW9uc30gb3BlcmF0aW9uczogJHt0b3RhbFRpbWUudG9GaXhlZCgyKX1tc1xuICAgICAgICBBdmVyYWdlIG9wZXJhdGlvbiB0aW1lOiAke2F2Z09wZXJhdGlvblRpbWUudG9GaXhlZCgzKX1tc1xuICAgICAgICBSZXN1bHQ6ICR7cmVzdWx0LnRvRml4ZWQoMil9YCk7XG5cbiAgICAgIGV4cGVjdChhdmdPcGVyYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMSk7IC8vIDwgMW1zIHBlciBvcGVyYXRpb25cbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKTsgLy8gVG90YWwgPCAyIHNlY29uZHNcbiAgICB9LCAxMDAwMCk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9