a214d48680f43384225507ca3ceb4231
"use strict";
/**
 * PerformanceTracker - Tracks PnL and calculates rolling Sharpe Ratios
 * Enables performance-based throttling of phase allocations
 *
 * Requirements: 2.1, 2.2, 2.3, 2.4, 2.8
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceTracker = void 0;
/** Milliseconds per day */
const MS_PER_DAY = 24 * 60 * 60 * 1000;
/** Annualization factor for Sharpe ratio (assuming 365 trading days) */
const ANNUALIZATION_FACTOR = Math.sqrt(365);
/**
 * PerformanceTracker tracks PnL per phase and calculates rolling Sharpe Ratios
 * to enable performance-based allocation throttling.
 */
class PerformanceTracker {
    config;
    db;
    constructor(config, db) {
        this.config = config;
        this.db = db ?? null;
    }
    /**
     * Record a trade for a phase with database persistence
     *
     * @param phaseId - The phase that executed the trade
     * @param pnl - Profit/loss in USD
     * @param timestamp - Unix timestamp in milliseconds
     * @param symbol - Optional trading symbol
     * @param side - Optional trade side (BUY/SELL)
     */
    async recordTrade(phaseId, pnl, timestamp, symbol, side) {
        if (!this.db) {
            throw new Error('Database not configured for PerformanceTracker');
        }
        await this.db.query(`INSERT INTO phase_trades (phase_id, timestamp, pnl, symbol, side)
       VALUES ($1, $2, $3, $4, $5)`, [phaseId, timestamp, pnl, symbol ?? null, side ?? null]);
    }
    /**
     * Get trade records for a phase within a time window
     *
     * @param phaseId - The phase to query
     * @param windowDays - Number of days to look back
     * @returns Array of trade records
     */
    async getTradesInWindow(phaseId, windowDays) {
        if (!this.db) {
            return [];
        }
        const windowStart = Date.now() - windowDays * MS_PER_DAY;
        const result = await this.db.query(`SELECT id, phase_id, pnl, timestamp, symbol, side
       FROM phase_trades
       WHERE phase_id = $1 AND timestamp >= $2
       ORDER BY timestamp ASC`, [phaseId, windowStart]);
        return result.rows.map((row) => ({
            id: row.id,
            phaseId: row.phase_id,
            pnl: parseFloat(row.pnl),
            timestamp: parseInt(row.timestamp, 10),
            symbol: row.symbol ?? undefined,
            side: row.side,
        }));
    }
    /**
     * Get the number of trades for a phase within a time window
     *
     * @param phaseId - The phase to query
     * @param windowDays - Number of days to look back
     * @returns Number of trades
     */
    async getTradeCount(phaseId, windowDays) {
        if (!this.db) {
            return 0;
        }
        const windowStart = Date.now() - windowDays * MS_PER_DAY;
        const result = await this.db.query(`SELECT COUNT(*) as count
       FROM phase_trades
       WHERE phase_id = $1 AND timestamp >= $2`, [phaseId, windowStart]);
        return parseInt(result.rows[0]?.count ?? '0', 10);
    }
    /**
     * Calculate the rolling Sharpe Ratio for a phase
     *
     * Sharpe Ratio = (Mean Return - Risk Free Rate) / Std Dev of Returns
     * We assume risk-free rate = 0 for simplicity
     *
     * @param phaseId - The phase to calculate for
     * @param windowDays - Rolling window in days (default: config.windowDays)
     * @returns Sharpe ratio (annualized), or 0 if insufficient data
     */
    async getSharpeRatio(phaseId, windowDays) {
        const window = windowDays ?? this.config.windowDays;
        const trades = await this.getTradesInWindow(phaseId, window);
        return this.calculateSharpeRatio(trades.map((t) => t.pnl));
    }
    /**
     * Calculate Sharpe ratio from an array of PnL values
     * Pure function for testability
     *
     * @param pnlValues - Array of PnL values
     * @returns Annualized Sharpe ratio
     */
    calculateSharpeRatio(pnlValues) {
        if (pnlValues.length < 2) {
            return 0;
        }
        const mean = this.calculateMean(pnlValues);
        const stdDev = this.calculateStdDev(pnlValues, mean);
        // Avoid division by zero
        if (stdDev === 0) {
            // If all returns are the same and positive, return a high Sharpe
            // If all returns are the same and negative, return a low Sharpe
            return mean > 0 ? 3.0 : mean < 0 ? -3.0 : 0;
        }
        // Daily Sharpe ratio
        const dailySharpe = mean / stdDev;
        // Annualize the Sharpe ratio
        return dailySharpe * ANNUALIZATION_FACTOR;
    }
    /**
     * Calculate mean of an array
     */
    calculateMean(values) {
        if (values.length === 0)
            return 0;
        return values.reduce((sum, v) => sum + v, 0) / values.length;
    }
    /**
     * Calculate standard deviation of an array
     */
    calculateStdDev(values, mean) {
        if (values.length < 2)
            return 0;
        const m = mean ?? this.calculateMean(values);
        const squaredDiffs = values.map((v) => Math.pow(v - m, 2));
        const variance = squaredDiffs.reduce((sum, v) => sum + v, 0) / (values.length - 1);
        return Math.sqrt(variance);
    }
    /**
     * Get the performance modifier for a phase based on Sharpe ratio
     *
     * Modifier logic:
     * - Sharpe < malusThreshold (0): Apply malusMultiplier (0.5x)
     * - Sharpe > bonusThreshold (2.0): Apply bonusMultiplier (1.2x)
     * - Otherwise: 1.0x (no modification)
     * - Insufficient trades (< minTradeCount): 1.0x (no modification)
     *
     * @param phaseId - The phase to get modifier for
     * @returns Performance modifier between 0.5 and 1.2
     */
    async getPerformanceModifier(phaseId) {
        const tradeCount = await this.getTradeCount(phaseId, this.config.windowDays);
        // Requirement 2.8: Insufficient trade history uses base weight
        if (tradeCount < this.config.minTradeCount) {
            return 1.0;
        }
        const sharpeRatio = await this.getSharpeRatio(phaseId);
        return this.calculateModifier(sharpeRatio);
    }
    /**
     * Calculate modifier from Sharpe ratio
     * Pure function for testability
     *
     * @param sharpeRatio - The Sharpe ratio
     * @returns Modifier between malusMultiplier and bonusMultiplier
     */
    calculateModifier(sharpeRatio) {
        // Requirement 2.3: Sharpe < 0 → malus penalty
        if (sharpeRatio < this.config.malusThreshold) {
            return this.config.malusMultiplier;
        }
        // Requirement 2.4: Sharpe > 2.0 → bonus multiplier
        if (sharpeRatio > this.config.bonusThreshold) {
            return this.config.bonusMultiplier;
        }
        // Normal performance: no modification
        return 1.0;
    }
    /**
     * Get full performance metrics for a phase
     *
     * @param phaseId - The phase to get metrics for
     * @returns PhasePerformance object with all metrics
     */
    async getPhasePerformance(phaseId) {
        const trades = await this.getTradesInWindow(phaseId, this.config.windowDays);
        const pnlValues = trades.map((t) => t.pnl);
        const totalPnL = pnlValues.reduce((sum, v) => sum + v, 0);
        const tradeCount = trades.length;
        const wins = pnlValues.filter((p) => p > 0);
        const losses = pnlValues.filter((p) => p < 0);
        const winRate = tradeCount > 0 ? wins.length / tradeCount : 0;
        const avgWin = wins.length > 0 ? this.calculateMean(wins) : 0;
        const avgLoss = losses.length > 0 ? Math.abs(this.calculateMean(losses)) : 0;
        const sharpeRatio = this.calculateSharpeRatio(pnlValues);
        const modifier = tradeCount >= this.config.minTradeCount
            ? this.calculateModifier(sharpeRatio)
            : 1.0;
        return {
            phaseId,
            sharpeRatio,
            totalPnL,
            tradeCount,
            winRate,
            avgWin,
            avgLoss,
            modifier,
        };
    }
    /**
     * Get performance metrics for all phases
     *
     * @returns Array of PhasePerformance for all phases
     */
    async getAllPhasePerformance() {
        const phases = ['phase1', 'phase2', 'phase3'];
        return Promise.all(phases.map((p) => this.getPhasePerformance(p)));
    }
    /**
     * Persist performance metrics snapshot to database
     * Called periodically (every 24 hours per Requirement 2.6)
     *
     * @param phaseId - The phase to persist metrics for
     */
    async persistPerformanceSnapshot(phaseId) {
        if (!this.db) {
            throw new Error('Database not configured for PerformanceTracker');
        }
        const performance = await this.getPhasePerformance(phaseId);
        const timestamp = Date.now();
        await this.db.query(`INSERT INTO phase_performance 
       (phase_id, timestamp, pnl, trade_count, sharpe_ratio, modifier)
       VALUES ($1, $2, $3, $4, $5, $6)`, [
            phaseId,
            timestamp,
            performance.totalPnL,
            performance.tradeCount,
            performance.sharpeRatio,
            performance.modifier,
        ]);
    }
    /**
     * Get configuration
     */
    getConfig() {
        return { ...this.config };
    }
}
exports.PerformanceTracker = PerformanceTracker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3NyYy9lbmdpbmUvUGVyZm9ybWFuY2VUcmFja2VyLnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7R0FLRzs7O0FBVUgsMkJBQTJCO0FBQzNCLE1BQU0sVUFBVSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztBQUV2Qyx3RUFBd0U7QUFDeEUsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBRTVDOzs7R0FHRztBQUNILE1BQWEsa0JBQWtCO0lBQ1osTUFBTSxDQUEyQjtJQUNqQyxFQUFFLENBQXlCO0lBRTVDLFlBQVksTUFBZ0MsRUFBRSxFQUFvQjtRQUNoRSxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsS0FBSyxDQUFDLFdBQVcsQ0FDZixPQUFnQixFQUNoQixHQUFXLEVBQ1gsU0FBaUIsRUFDakIsTUFBZSxFQUNmLElBQXFCO1FBRXJCLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDYixNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7UUFDcEUsQ0FBQztRQUVELE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQ2pCO21DQUM2QixFQUM3QixDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sSUFBSSxJQUFJLEVBQUUsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUN4RCxDQUFDO0lBQ0osQ0FBQztJQUdEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxpQkFBaUIsQ0FDckIsT0FBZ0IsRUFDaEIsVUFBa0I7UUFFbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUNiLE9BQU8s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UUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3pELE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxPQUFnQjtRQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO1FBQ3BFLENBQUM7UUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1RCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFN0IsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FDakI7O3VDQUVpQyxFQUNqQztZQUNFLE9BQU87WUFDUCxTQUFTO1lBQ1QsV0FBVyxDQUFDLFFBQVE7WUFDcEIsV0FBVyxDQUFDLFVBQVU7WUFDdEIsV0FBVyxDQUFDLFdBQVc7WUFDdkIsV0FBVyxDQUFDLFFBQVE7U0FDckIsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gsU0FBUztRQUNQLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM1QixDQUFDO0NBQ0Y7QUE5U0QsZ0RBOFNDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9pdmFuL0NvZGUvdHJhZGluZy90aXRhbi9zZXJ2aWNlcy90aXRhbi1icmFpbi9zcmMvZW5naW5lL1BlcmZvcm1hbmNlVHJhY2tlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBlcmZvcm1hbmNlVHJhY2tlciAtIFRyYWNrcyBQbkwgYW5kIGNhbGN1bGF0ZXMgcm9sbGluZyBTaGFycGUgUmF0aW9zXG4gKiBFbmFibGVzIHBlcmZvcm1hbmNlLWJhc2VkIHRocm90dGxpbmcgb2YgcGhhc2UgYWxsb2NhdGlvbnNcbiAqIFxuICogUmVxdWlyZW1lbnRzOiAyLjEsIDIuMiwgMi4zLCAyLjQsIDIuOFxuICovXG5cbmltcG9ydCB7XG4gIFBoYXNlSWQsXG4gIFRyYWRlUmVjb3JkLFxuICBQaGFzZVBlcmZvcm1hbmNlLFxuICBQZXJmb3JtYW5jZVRyYWNrZXJDb25maWcsXG59IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB7IERhdGFiYXNlTWFuYWdlciB9IGZyb20gJy4uL2RiL0RhdGFiYXNlTWFuYWdlci5qcyc7XG5cbi8qKiBNaWxsaXNlY29uZHMgcGVyIGRheSAqL1xuY29uc3QgTVNfUEVSX0RBWSA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbi8qKiBBbm51YWxpemF0aW9uIGZhY3RvciBmb3IgU2hhcnBlIHJhdGlvIChhc3N1bWluZyAzNjUgdHJhZGluZyBkYXlzKSAqL1xuY29uc3QgQU5OVUFMSVpBVElPTl9GQUNUT1IgPSBNYXRoLnNxcnQoMzY1KTtcblxuLyoqXG4gKiBQZXJmb3JtYW5jZVRyYWNrZXIgdHJhY2tzIFBuTCBwZXIgcGhhc2UgYW5kIGNhbGN1bGF0ZXMgcm9sbGluZyBTaGFycGUgUmF0aW9zXG4gKiB0byBlbmFibGUgcGVyZm9ybWFuY2UtYmFzZWQgYWxsb2NhdGlvbiB0aHJvdHRsaW5nLlxuICovXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VUcmFja2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IFBlcmZvcm1hbmNlVHJhY2tlckNvbmZpZztcbiAgcHJpdmF0ZSByZWFkb25seSBkYjogRGF0YWJhc2VNYW5hZ2VyIHwgbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFBlcmZvcm1hbmNlVHJhY2tlckNvbmZpZywgZGI/OiBEYXRhYmFzZU1hbmFnZXIpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmRiID0gZGIgPz8gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgYSB0cmFkZSBmb3IgYSBwaGFzZSB3aXRoIGRhdGFiYXNlIHBlcnNpc3RlbmNlXG4gICAqIFxuICAgKiBAcGFyYW0gcGhhc2VJZCAtIFRoZSBwaGFzZSB0aGF0IGV4ZWN1dGVkIHRoZSB0cmFkZVxuICAgKiBAcGFyYW0gcG5sIC0gUHJvZml0L2xvc3MgaW4gVVNEXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSBVbml4IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHN5bWJvbCAtIE9wdGlvbmFsIHRyYWRpbmcgc3ltYm9sXG4gICAqIEBwYXJhbSBzaWRlIC0gT3B0aW9uYWwgdHJhZGUgc2lkZSAoQlVZL1NFTEwpXG4gICAqL1xuICBhc3luYyByZWNvcmRUcmFkZShcbiAgICBwaGFzZUlkOiBQaGFzZUlkLFxuICAgIHBubDogbnVtYmVyLFxuICAgIHRpbWVzdGFtcDogbnVtYmVyLFxuICAgIHN5bWJvbD86IHN0cmluZyxcbiAgICBzaWRlPzogJ0JVWScgfCAnU0VMTCdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBjb25maWd1cmVkIGZvciBQZXJmb3JtYW5jZVRyYWNrZXInKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmRiLnF1ZXJ5KFxuICAgICAgYElOU0VSVCBJTlRPIHBoYXNlX3RyYWRlcyAocGhhc2VfaWQsIHRpbWVzdGFtcCwgcG5sLCBzeW1ib2wsIHNpZGUpXG4gICAgICAgVkFMVUVTICgkMSwgJDIsICQzLCAkNCwgJDUpYCxcbiAgICAgIFtwaGFzZUlkLCB0aW1lc3RhbXAsIHBubCwgc3ltYm9sID8/IG51bGwsIHNpZGUgPz8gbnVsbF1cbiAgICApO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRyYWRlIHJlY29yZHMgZm9yIGEgcGhhc2Ugd2l0aGluIGEgdGltZSB3aW5kb3dcbiAgICogXG4gICAqIEBwYXJhbSBwaGFzZUlkIC0gVGhlIHBoYXNlIHRvIHF1ZXJ5XG4gICAqIEBwYXJhbSB3aW5kb3dEYXlzIC0gTnVtYmVyIG9mIGRheXMgdG8gbG9vayBiYWNrXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHRyYWRlIHJlY29yZHNcbiAgICovXG4gIGFzeW5jIGdldFRyYWRlc0luV2luZG93KFxuICAgIHBoYXNlSWQ6IFBoYXNlSWQsXG4gICAgd2luZG93RGF5czogbnVtYmVyXG4gICk6IFByb21pc2U8VHJhZGVSZWNvcmRbXT4ge1xuICAgIGlmICghdGhpcy5kYikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gRGF0ZS5ub3coKSAtIHdpbmRvd0RheXMgKiBNU19QRVJfREFZO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kYi5xdWVyeTx7XG4gICAgICBpZDogbnVtYmVyO1xuICAgICAgcGhhc2VfaWQ6IHN0cmluZztcbiAgICAgIHBubDogc3RyaW5nO1xuICAgICAgdGltZXN0YW1wOiBzdHJpbmc7XG4gICAgICBzeW1ib2w6IHN0cmluZyB8IG51bGw7XG4gICAgICBzaWRlOiBzdHJpbmcgfCBudWxsO1xuICAgIH0+KFxuICAgICAgYFNFTEVDVCBpZCwgcGhhc2VfaWQsIHBubCwgdGltZXN0YW1wLCBzeW1ib2wsIHNpZGVcbiAgICAgICBGUk9NIHBoYXNlX3RyYWRlc1xuICAgICAgIFdIRVJFIHBoYXNlX2lkID0gJDEgQU5EIHRpbWVzdGFtcCA+PSAkMlxuICAgICAgIE9SREVSIEJZIHRpbWVzdGFtcCBBU0NgLFxuICAgICAgW3BoYXNlSWQsIHdpbmRvd1N0YXJ0XVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnJvd3MubWFwKChyb3cpID0+ICh7XG4gICAgICBpZDogcm93LmlkLFxuICAgICAgcGhhc2VJZDogcm93LnBoYXNlX2lkIGFzIFBoYXNlSWQsXG4gICAgICBwbmw6IHBhcnNlRmxvYXQocm93LnBubCksXG4gICAgICB0aW1lc3RhbXA6IHBhcnNlSW50KHJvdy50aW1lc3RhbXAsIDEwKSxcbiAgICAgIHN5bWJvbDogcm93LnN5bWJvbCA/PyB1bmRlZmluZWQsXG4gICAgICBzaWRlOiByb3cuc2lkZSBhcyAnQlVZJyB8ICdTRUxMJyB8IHVuZGVmaW5lZCxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgdHJhZGVzIGZvciBhIHBoYXNlIHdpdGhpbiBhIHRpbWUgd2luZG93XG4gICAqIFxuICAgKiBAcGFyYW0gcGhhc2VJZCAtIFRoZSBwaGFzZSB0byBxdWVyeVxuICAgKiBAcGFyYW0gd2luZG93RGF5cyAtIE51bWJlciBvZiBkYXlzIHRvIGxvb2sgYmFja1xuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdHJhZGVzXG4gICAqL1xuICBhc3luYyBnZXRUcmFkZUNvdW50KHBoYXNlSWQ6IFBoYXNlSWQsIHdpbmRvd0RheXM6IG51bWJlcik6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IERhdGUubm93KCkgLSB3aW5kb3dEYXlzICogTVNfUEVSX0RBWTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGIucXVlcnk8eyBjb3VudDogc3RyaW5nIH0+KFxuICAgICAgYFNFTEVDVCBDT1VOVCgqKSBhcyBjb3VudFxuICAgICAgIEZST00gcGhhc2VfdHJhZGVzXG4gICAgICAgV0hFUkUgcGhhc2VfaWQgPSAkMSBBTkQgdGltZXN0YW1wID49ICQyYCxcbiAgICAgIFtwaGFzZUlkLCB3aW5kb3dTdGFydF1cbiAgICApO1xuXG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC5yb3dzWzBdPy5jb3VudCA/PyAnMCcsIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHJvbGxpbmcgU2hhcnBlIFJhdGlvIGZvciBhIHBoYXNlXG4gICAqIFxuICAgKiBTaGFycGUgUmF0aW8gPSAoTWVhbiBSZXR1cm4gLSBSaXNrIEZyZWUgUmF0ZSkgLyBTdGQgRGV2IG9mIFJldHVybnNcbiAgICogV2UgYXNzdW1lIHJpc2stZnJlZSByYXRlID0gMCBmb3Igc2ltcGxpY2l0eVxuICAgKiBcbiAgICogQHBhcmFtIHBoYXNlSWQgLSBUaGUgcGhhc2UgdG8gY2FsY3VsYXRlIGZvclxuICAgKiBAcGFyYW0gd2luZG93RGF5cyAtIFJvbGxpbmcgd2luZG93IGluIGRheXMgKGRlZmF1bHQ6IGNvbmZpZy53aW5kb3dEYXlzKVxuICAgKiBAcmV0dXJucyBTaGFycGUgcmF0aW8gKGFubnVhbGl6ZWQpLCBvciAwIGlmIGluc3VmZmljaWVudCBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTaGFycGVSYXRpbyhcbiAgICBwaGFzZUlkOiBQaGFzZUlkLFxuICAgIHdpbmRvd0RheXM/OiBudW1iZXJcbiAgKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCB3aW5kb3cgPSB3aW5kb3dEYXlzID8/IHRoaXMuY29uZmlnLndpbmRvd0RheXM7XG4gICAgY29uc3QgdHJhZGVzID0gYXdhaXQgdGhpcy5nZXRUcmFkZXNJbldpbmRvdyhwaGFzZUlkLCB3aW5kb3cpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlU2hhcnBlUmF0aW8odHJhZGVzLm1hcCgodCkgPT4gdC5wbmwpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgU2hhcnBlIHJhdGlvIGZyb20gYW4gYXJyYXkgb2YgUG5MIHZhbHVlc1xuICAgKiBQdXJlIGZ1bmN0aW9uIGZvciB0ZXN0YWJpbGl0eVxuICAgKiBcbiAgICogQHBhcmFtIHBubFZhbHVlcyAtIEFycmF5IG9mIFBuTCB2YWx1ZXNcbiAgICogQHJldHVybnMgQW5udWFsaXplZCBTaGFycGUgcmF0aW9cbiAgICovXG4gIGNhbGN1bGF0ZVNoYXJwZVJhdGlvKHBubFZhbHVlczogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmIChwbmxWYWx1ZXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgbWVhbiA9IHRoaXMuY2FsY3VsYXRlTWVhbihwbmxWYWx1ZXMpO1xuICAgIGNvbnN0IHN0ZERldiA9IHRoaXMuY2FsY3VsYXRlU3RkRGV2KHBubFZhbHVlcywgbWVhbik7XG5cbiAgICAvLyBBdm9pZCBkaXZpc2lvbiBieSB6ZXJvXG4gICAgaWYgKHN0ZERldiA9PT0gMCkge1xuICAgICAgLy8gSWYgYWxsIHJldHVybnMgYXJlIHRoZSBzYW1lIGFuZCBwb3NpdGl2ZSwgcmV0dXJuIGEgaGlnaCBTaGFycGVcbiAgICAgIC8vIElmIGFsbCByZXR1cm5zIGFyZSB0aGUgc2FtZSBhbmQgbmVnYXRpdmUsIHJldHVybiBhIGxvdyBTaGFycGVcbiAgICAgIHJldHVybiBtZWFuID4gMCA/IDMuMCA6IG1lYW4gPCAwID8gLTMuMCA6IDA7XG4gICAgfVxuXG4gICAgLy8gRGFpbHkgU2hhcnBlIHJhdGlvXG4gICAgY29uc3QgZGFpbHlTaGFycGUgPSBtZWFuIC8gc3RkRGV2O1xuXG4gICAgLy8gQW5udWFsaXplIHRoZSBTaGFycGUgcmF0aW9cbiAgICByZXR1cm4gZGFpbHlTaGFycGUgKiBBTk5VQUxJWkFUSU9OX0ZBQ1RPUjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgbWVhbiBvZiBhbiBhcnJheVxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNZWFuKHZhbHVlczogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyB2LCAwKSAvIHZhbHVlcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheVxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVTdGREZXYodmFsdWVzOiBudW1iZXJbXSwgbWVhbj86IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcbiAgICBjb25zdCBtID0gbWVhbiA/PyB0aGlzLmNhbGN1bGF0ZU1lYW4odmFsdWVzKTtcbiAgICBjb25zdCBzcXVhcmVkRGlmZnMgPSB2YWx1ZXMubWFwKCh2KSA9PiBNYXRoLnBvdyh2IC0gbSwgMikpO1xuICAgIGNvbnN0IHZhcmlhbmNlID0gc3F1YXJlZERpZmZzLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyB2LCAwKSAvICh2YWx1ZXMubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh2YXJpYW5jZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmZvcm1hbmNlIG1vZGlmaWVyIGZvciBhIHBoYXNlIGJhc2VkIG9uIFNoYXJwZSByYXRpb1xuICAgKiBcbiAgICogTW9kaWZpZXIgbG9naWM6XG4gICAqIC0gU2hhcnBlIDwgbWFsdXNUaHJlc2hvbGQgKDApOiBBcHBseSBtYWx1c011bHRpcGxpZXIgKDAuNXgpXG4gICAqIC0gU2hhcnBlID4gYm9udXNUaHJlc2hvbGQgKDIuMCk6IEFwcGx5IGJvbnVzTXVsdGlwbGllciAoMS4yeClcbiAgICogLSBPdGhlcndpc2U6IDEuMHggKG5vIG1vZGlmaWNhdGlvbilcbiAgICogLSBJbnN1ZmZpY2llbnQgdHJhZGVzICg8IG1pblRyYWRlQ291bnQpOiAxLjB4IChubyBtb2RpZmljYXRpb24pXG4gICAqIFxuICAgKiBAcGFyYW0gcGhhc2VJZCAtIFRoZSBwaGFzZSB0byBnZXQgbW9kaWZpZXIgZm9yXG4gICAqIEByZXR1cm5zIFBlcmZvcm1hbmNlIG1vZGlmaWVyIGJldHdlZW4gMC41IGFuZCAxLjJcbiAgICovXG4gIGFzeW5jIGdldFBlcmZvcm1hbmNlTW9kaWZpZXIocGhhc2VJZDogUGhhc2VJZCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgdHJhZGVDb3VudCA9IGF3YWl0IHRoaXMuZ2V0VHJhZGVDb3VudChwaGFzZUlkLCB0aGlzLmNvbmZpZy53aW5kb3dEYXlzKTtcblxuICAgIC8vIFJlcXVpcmVtZW50IDIuODogSW5zdWZmaWNpZW50IHRyYWRlIGhpc3RvcnkgdXNlcyBiYXNlIHdlaWdodFxuICAgIGlmICh0cmFkZUNvdW50IDwgdGhpcy5jb25maWcubWluVHJhZGVDb3VudCkge1xuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFycGVSYXRpbyA9IGF3YWl0IHRoaXMuZ2V0U2hhcnBlUmF0aW8ocGhhc2VJZCk7XG5cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVNb2RpZmllcihzaGFycGVSYXRpbyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIG1vZGlmaWVyIGZyb20gU2hhcnBlIHJhdGlvXG4gICAqIFB1cmUgZnVuY3Rpb24gZm9yIHRlc3RhYmlsaXR5XG4gICAqIFxuICAgKiBAcGFyYW0gc2hhcnBlUmF0aW8gLSBUaGUgU2hhcnBlIHJhdGlvXG4gICAqIEByZXR1cm5zIE1vZGlmaWVyIGJldHdlZW4gbWFsdXNNdWx0aXBsaWVyIGFuZCBib251c011bHRpcGxpZXJcbiAgICovXG4gIGNhbGN1bGF0ZU1vZGlmaWVyKHNoYXJwZVJhdGlvOiBudW1iZXIpOiBudW1iZXIge1xuICAgIC8vIFJlcXVpcmVtZW50IDIuMzogU2hhcnBlIDwgMCDihpIgbWFsdXMgcGVuYWx0eVxuICAgIGlmIChzaGFycGVSYXRpbyA8IHRoaXMuY29uZmlnLm1hbHVzVGhyZXNob2xkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWcubWFsdXNNdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIC8vIFJlcXVpcmVtZW50IDIuNDogU2hhcnBlID4gMi4wIOKGkiBib251cyBtdWx0aXBsaWVyXG4gICAgaWYgKHNoYXJwZVJhdGlvID4gdGhpcy5jb25maWcuYm9udXNUaHJlc2hvbGQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5ib251c011bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsIHBlcmZvcm1hbmNlOiBubyBtb2RpZmljYXRpb25cbiAgICByZXR1cm4gMS4wO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmdWxsIHBlcmZvcm1hbmNlIG1ldHJpY3MgZm9yIGEgcGhhc2VcbiAgICogXG4gICAqIEBwYXJhbSBwaGFzZUlkIC0gVGhlIHBoYXNlIHRvIGdldCBtZXRyaWNzIGZvclxuICAgKiBAcmV0dXJucyBQaGFzZVBlcmZvcm1hbmNlIG9iamVjdCB3aXRoIGFsbCBtZXRyaWNzXG4gICAqL1xuICBhc3luYyBnZXRQaGFzZVBlcmZvcm1hbmNlKHBoYXNlSWQ6IFBoYXNlSWQpOiBQcm9taXNlPFBoYXNlUGVyZm9ybWFuY2U+IHtcbiAgICBjb25zdCB0cmFkZXMgPSBhd2FpdCB0aGlzLmdldFRyYWRlc0luV2luZG93KHBoYXNlSWQsIHRoaXMuY29uZmlnLndpbmRvd0RheXMpO1xuICAgIGNvbnN0IHBubFZhbHVlcyA9IHRyYWRlcy5tYXAoKHQpID0+IHQucG5sKTtcblxuICAgIGNvbnN0IHRvdGFsUG5MID0gcG5sVmFsdWVzLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyB2LCAwKTtcbiAgICBjb25zdCB0cmFkZUNvdW50ID0gdHJhZGVzLmxlbmd0aDtcblxuICAgIGNvbnN0IHdpbnMgPSBwbmxWYWx1ZXMuZmlsdGVyKChwKSA9PiBwID4gMCk7XG4gICAgY29uc3QgbG9zc2VzID0gcG5sVmFsdWVzLmZpbHRlcigocCkgPT4gcCA8IDApO1xuXG4gICAgY29uc3Qgd2luUmF0ZSA9IHRyYWRlQ291bnQgPiAwID8gd2lucy5sZW5ndGggLyB0cmFkZUNvdW50IDogMDtcbiAgICBjb25zdCBhdmdXaW4gPSB3aW5zLmxlbmd0aCA+IDAgPyB0aGlzLmNhbGN1bGF0ZU1lYW4od2lucykgOiAwO1xuICAgIGNvbnN0IGF2Z0xvc3MgPSBsb3NzZXMubGVuZ3RoID4gMCA/IE1hdGguYWJzKHRoaXMuY2FsY3VsYXRlTWVhbihsb3NzZXMpKSA6IDA7XG5cbiAgICBjb25zdCBzaGFycGVSYXRpbyA9IHRoaXMuY2FsY3VsYXRlU2hhcnBlUmF0aW8ocG5sVmFsdWVzKTtcbiAgICBjb25zdCBtb2RpZmllciA9XG4gICAgICB0cmFkZUNvdW50ID49IHRoaXMuY29uZmlnLm1pblRyYWRlQ291bnRcbiAgICAgICAgPyB0aGlzLmNhbGN1bGF0ZU1vZGlmaWVyKHNoYXJwZVJhdGlvKVxuICAgICAgICA6IDEuMDtcblxuICAgIHJldHVybiB7XG4gICAgICBwaGFzZUlkLFxuICAgICAgc2hhcnBlUmF0aW8sXG4gICAgICB0b3RhbFBuTCxcbiAgICAgIHRyYWRlQ291bnQsXG4gICAgICB3aW5SYXRlLFxuICAgICAgYXZnV2luLFxuICAgICAgYXZnTG9zcyxcbiAgICAgIG1vZGlmaWVyLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBlcmZvcm1hbmNlIG1ldHJpY3MgZm9yIGFsbCBwaGFzZXNcbiAgICogXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIFBoYXNlUGVyZm9ybWFuY2UgZm9yIGFsbCBwaGFzZXNcbiAgICovXG4gIGFzeW5jIGdldEFsbFBoYXNlUGVyZm9ybWFuY2UoKTogUHJvbWlzZTxQaGFzZVBlcmZvcm1hbmNlW10+IHtcbiAgICBjb25zdCBwaGFzZXM6IFBoYXNlSWRbXSA9IFsncGhhc2UxJywgJ3BoYXNlMicsICdwaGFzZTMnXTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGhhc2VzLm1hcCgocCkgPT4gdGhpcy5nZXRQaGFzZVBlcmZvcm1hbmNlKHApKSk7XG4gIH1cblxuICAvKipcbiAgICogUGVyc2lzdCBwZXJmb3JtYW5jZSBtZXRyaWNzIHNuYXBzaG90IHRvIGRhdGFiYXNlXG4gICAqIENhbGxlZCBwZXJpb2RpY2FsbHkgKGV2ZXJ5IDI0IGhvdXJzIHBlciBSZXF1aXJlbWVudCAyLjYpXG4gICAqIFxuICAgKiBAcGFyYW0gcGhhc2VJZCAtIFRoZSBwaGFzZSB0byBwZXJzaXN0IG1ldHJpY3MgZm9yXG4gICAqL1xuICBhc3luYyBwZXJzaXN0UGVyZm9ybWFuY2VTbmFwc2hvdChwaGFzZUlkOiBQaGFzZUlkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBjb25maWd1cmVkIGZvciBQZXJmb3JtYW5jZVRyYWNrZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJmb3JtYW5jZSA9IGF3YWl0IHRoaXMuZ2V0UGhhc2VQZXJmb3JtYW5jZShwaGFzZUlkKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgYXdhaXQgdGhpcy5kYi5xdWVyeShcbiAgICAgIGBJTlNFUlQgSU5UTyBwaGFzZV9wZXJmb3JtYW5jZSBcbiAgICAgICAocGhhc2VfaWQsIHRpbWVzdGFtcCwgcG5sLCB0cmFkZV9jb3VudCwgc2hhcnBlX3JhdGlvLCBtb2RpZmllcilcbiAgICAgICBWQUxVRVMgKCQxLCAkMiwgJDMsICQ0LCAkNSwgJDYpYCxcbiAgICAgIFtcbiAgICAgICAgcGhhc2VJZCxcbiAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICBwZXJmb3JtYW5jZS50b3RhbFBuTCxcbiAgICAgICAgcGVyZm9ybWFuY2UudHJhZGVDb3VudCxcbiAgICAgICAgcGVyZm9ybWFuY2Uuc2hhcnBlUmF0aW8sXG4gICAgICAgIHBlcmZvcm1hbmNlLm1vZGlmaWVyLFxuICAgICAgXVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldENvbmZpZygpOiBQZXJmb3JtYW5jZVRyYWNrZXJDb25maWcge1xuICAgIHJldHVybiB7IC4uLnRoaXMuY29uZmlnIH07XG4gIH1cbn1cbiJdLCJ2ZXJzaW9uIjozfQ==