d8647cf3091ac114dd944f1ec08727a9
"use strict";
/**
 * CircuitBreaker - Emergency halt system for Titan Brain
 * Monitors for extreme conditions and triggers emergency halt when thresholds are breached
 *
 * Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.8
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircuitBreaker = void 0;
const index_js_1 = require("../types/index.js");
/**
 * CircuitBreaker monitors for extreme conditions and triggers
 * emergency halt when thresholds are breached.
 *
 * Trigger conditions:
 * - Daily drawdown exceeds 15% (HARD)
 * - Equity drops below $150 (HARD)
 * - 3 consecutive losing trades within 1 hour (SOFT - 30 min cooldown)
 */
class CircuitBreaker {
    config;
    /** Current breaker state */
    active = false;
    breakerType;
    triggerReason;
    triggeredAt;
    cooldownEndsAt;
    /** Tracking state */
    dailyStartEquity = 0;
    recentLosses = [];
    /** External handlers */
    positionHandler;
    notificationHandler;
    eventPersistence;
    constructor(config) {
        this.config = config;
    }
    /**
     * Set the position closure handler
     */
    setPositionHandler(handler) {
        this.positionHandler = handler;
    }
    /**
     * Set the notification handler
     */
    setNotificationHandler(handler) {
        this.notificationHandler = handler;
    }
    /**
     * Set the event persistence handler
     */
    setEventPersistence(persistence) {
        this.eventPersistence = persistence;
    }
    /**
     * Set daily start equity for drawdown calculation
     * Should be called at the start of each trading day
     */
    setDailyStartEquity(equity) {
        this.dailyStartEquity = Math.max(0, equity);
    }
    /**
     * Get daily start equity
     */
    getDailyStartEquity() {
        return this.dailyStartEquity;
    }
    /**
     * Check all breaker conditions
     *
     * @param input - Breaker check input with equity, positions, and trade history
     * @returns Current breaker status
     */
    checkConditions(input) {
        const { equity, positions, dailyStartEquity, recentTrades } = input;
        // Update daily start equity if provided
        if (dailyStartEquity > 0) {
            this.dailyStartEquity = dailyStartEquity;
        }
        // Calculate daily drawdown
        const dailyDrawdown = this.calculateDailyDrawdown(equity);
        // Count consecutive losses within the time window
        const consecutiveLosses = this.countConsecutiveLosses(recentTrades);
        // Check for soft breaker cooldown expiry
        this.checkCooldownExpiry();
        // If already active with HARD breaker, maintain state
        if (this.active && this.breakerType === index_js_1.BreakerType.HARD) {
            return this.getStatus();
        }
        // Requirement 5.1: Daily drawdown exceeds 15%
        if (dailyDrawdown >= this.config.maxDailyDrawdown) {
            this.trigger(`Daily drawdown exceeded: ${(dailyDrawdown * 100).toFixed(2)}% >= ${(this.config.maxDailyDrawdown * 100).toFixed(0)}%`);
            return this.getStatus();
        }
        // Requirement 5.2: Equity drops below minimum
        if (equity < this.config.minEquity) {
            this.trigger(`Equity below minimum: $${equity.toFixed(2)} < $${this.config.minEquity}`);
            return this.getStatus();
        }
        // Requirement 5.3: Consecutive losses (soft pause)
        if (consecutiveLosses >= this.config.consecutiveLossLimit && !this.active) {
            this.triggerSoftPause(`${consecutiveLosses} consecutive losses within ${this.config.consecutiveLossWindow / 60000} minutes`);
            return this.getStatus();
        }
        return {
            active: this.active,
            type: this.breakerType,
            reason: this.triggerReason,
            triggeredAt: this.triggeredAt,
            dailyDrawdown,
            consecutiveLosses,
            equityLevel: equity,
            cooldownEndsAt: this.cooldownEndsAt,
        };
    }
    /**
     * Trigger the circuit breaker (HARD)
     * Requirement 5.4: Close all positions immediately
     * Requirement 5.5: Reject all new signals until manual reset
     *
     * @param reason - Reason for triggering
     */
    async trigger(reason) {
        // Requirement 5.4: Idempotence - don't create duplicate events
        if (this.active && this.breakerType === index_js_1.BreakerType.HARD) {
            return;
        }
        const timestamp = Date.now();
        this.active = true;
        this.breakerType = index_js_1.BreakerType.HARD;
        this.triggerReason = reason;
        this.triggeredAt = timestamp;
        this.cooldownEndsAt = undefined;
        // Requirement 5.4: Close all open positions immediately
        if (this.positionHandler) {
            try {
                await this.positionHandler.closeAllPositions();
            }
            catch (error) {
                // Log error but don't prevent breaker activation
                console.error('Failed to close positions during circuit breaker trigger:', error);
            }
        }
        // Requirement 5.6: Send emergency notifications
        if (this.notificationHandler) {
            try {
                await this.notificationHandler.sendEmergencyNotification(reason, this.dailyStartEquity);
            }
            catch (error) {
                console.error('Failed to send emergency notification:', error);
            }
        }
        // Requirement 5.7: Log the event
        const event = {
            timestamp,
            eventType: 'TRIGGER',
            breakerType: index_js_1.BreakerType.HARD,
            reason,
            equity: this.dailyStartEquity,
            metadata: {
                dailyDrawdown: this.calculateDailyDrawdown(this.dailyStartEquity),
            },
        };
        if (this.eventPersistence) {
            try {
                await this.eventPersistence.persistEvent(event);
            }
            catch (error) {
                console.error('Failed to persist breaker event:', error);
            }
        }
    }
    /**
     * Trigger a soft pause (cooldown period)
     * Requirement 5.3: 30 minute cooldown for consecutive losses
     *
     * @param reason - Reason for soft pause
     */
    async triggerSoftPause(reason) {
        // Don't downgrade from HARD to SOFT
        if (this.active && this.breakerType === index_js_1.BreakerType.HARD) {
            return;
        }
        // Idempotence for SOFT breaker
        if (this.active && this.breakerType === index_js_1.BreakerType.SOFT) {
            return;
        }
        const timestamp = Date.now();
        this.active = true;
        this.breakerType = index_js_1.BreakerType.SOFT;
        this.triggerReason = reason;
        this.triggeredAt = timestamp;
        this.cooldownEndsAt = timestamp + (this.config.cooldownMinutes * 60 * 1000);
        // Log the event
        const event = {
            timestamp,
            eventType: 'TRIGGER',
            breakerType: index_js_1.BreakerType.SOFT,
            reason,
            equity: this.dailyStartEquity,
            metadata: {
                cooldownMinutes: this.config.cooldownMinutes,
                cooldownEndsAt: this.cooldownEndsAt,
            },
        };
        if (this.eventPersistence) {
            try {
                await this.eventPersistence.persistEvent(event);
            }
            catch (error) {
                console.error('Failed to persist soft pause event:', error);
            }
        }
    }
    /**
     * Reset the circuit breaker (manual reset)
     * Requirement 5.8: Require confirmation and log operator identity
     *
     * @param operatorId - ID of the operator performing the reset
     */
    async reset(operatorId) {
        if (!this.active) {
            return;
        }
        if (!operatorId || operatorId.trim() === '') {
            throw new Error('Operator ID is required for circuit breaker reset');
        }
        const timestamp = Date.now();
        const previousReason = this.triggerReason;
        const previousType = this.breakerType;
        // Reset state
        this.active = false;
        this.breakerType = undefined;
        this.triggerReason = undefined;
        this.triggeredAt = undefined;
        this.cooldownEndsAt = undefined;
        // Requirement 5.8: Log the reset with operator identity
        const event = {
            timestamp,
            eventType: 'RESET',
            reason: `Manual reset by operator: ${operatorId}`,
            equity: this.dailyStartEquity,
            operatorId,
            metadata: {
                previousReason,
                previousType,
            },
        };
        if (this.eventPersistence) {
            try {
                await this.eventPersistence.persistEvent(event);
            }
            catch (error) {
                console.error('Failed to persist reset event:', error);
            }
        }
    }
    /**
     * Check if circuit breaker is active
     * Requirement 5.5: Reject all new signals until manual reset
     */
    isActive() {
        // Check for soft breaker cooldown expiry
        this.checkCooldownExpiry();
        return this.active;
    }
    /**
     * Get current breaker status
     */
    getStatus() {
        // Check for soft breaker cooldown expiry
        this.checkCooldownExpiry();
        return {
            active: this.active,
            type: this.breakerType,
            reason: this.triggerReason,
            triggeredAt: this.triggeredAt,
            dailyDrawdown: this.calculateDailyDrawdown(this.dailyStartEquity),
            consecutiveLosses: this.recentLosses.length,
            equityLevel: this.dailyStartEquity,
            cooldownEndsAt: this.cooldownEndsAt,
        };
    }
    /**
     * Record a trade result for consecutive loss tracking
     *
     * @param pnl - Trade PnL (positive = profit, negative = loss)
     * @param timestamp - Trade timestamp
     */
    recordTrade(pnl, timestamp) {
        const tradeTime = timestamp ?? Date.now();
        // Add to recent losses tracking
        this.recentLosses.push({ pnl, timestamp: tradeTime });
        // Clean up old trades outside the window
        const windowStart = tradeTime - this.config.consecutiveLossWindow;
        this.recentLosses = this.recentLosses.filter(t => t.timestamp >= windowStart);
        // If profitable trade, reset consecutive loss counter
        if (pnl >= 0) {
            this.recentLosses = this.recentLosses.filter(t => t.pnl < 0 && t.timestamp > tradeTime - this.config.consecutiveLossWindow);
        }
    }
    /**
     * Get configuration
     */
    getConfig() {
        return { ...this.config };
    }
    // ============ Private Helper Methods ============
    /**
     * Calculate daily drawdown percentage
     */
    calculateDailyDrawdown(currentEquity) {
        if (this.dailyStartEquity <= 0) {
            return 0;
        }
        const drawdown = (this.dailyStartEquity - currentEquity) / this.dailyStartEquity;
        return Math.max(0, drawdown);
    }
    /**
     * Count consecutive losses within the time window
     */
    countConsecutiveLosses(recentTrades) {
        if (recentTrades.length === 0) {
            return 0;
        }
        const now = Date.now();
        const windowStart = now - this.config.consecutiveLossWindow;
        // Filter trades within the window and sort by timestamp (most recent first)
        const tradesInWindow = recentTrades
            .filter(t => t.timestamp >= windowStart)
            .sort((a, b) => b.timestamp - a.timestamp);
        // Count consecutive losses from most recent
        let consecutiveLosses = 0;
        for (const trade of tradesInWindow) {
            if (trade.pnl < 0) {
                consecutiveLosses++;
            }
            else {
                break; // Stop counting at first profitable trade
            }
        }
        return consecutiveLosses;
    }
    /**
     * Check if soft breaker cooldown has expired
     */
    checkCooldownExpiry() {
        if (this.active &&
            this.breakerType === index_js_1.BreakerType.SOFT &&
            this.cooldownEndsAt &&
            Date.now() >= this.cooldownEndsAt) {
            // Auto-reset soft breaker after cooldown
            this.active = false;
            this.breakerType = undefined;
            this.triggerReason = undefined;
            this.triggeredAt = undefined;
            this.cooldownEndsAt = undefined;
        }
    }
}
exports.CircuitBreaker = CircuitBreaker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2l2YW4vQ29kZS90cmFkaW5nL3RpdGFuL3NlcnZpY2VzL3RpdGFuLWJyYWluL3NyYy9lbmdpbmUvQ2lyY3VpdEJyZWFrZXIudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHOzs7QUFFSCxnREFPMkI7QUEwQjNCOzs7Ozs7OztHQVFHO0FBQ0gsTUFBYSxjQUFjO0lBQ1IsTUFBTSxDQUF1QjtJQUU5Qyw0QkFBNEI7SUFDcEIsTUFBTSxHQUFZLEtBQUssQ0FBQztJQUN4QixXQUFXLENBQWU7SUFDMUIsYUFBYSxDQUFVO0lBQ3ZCLFdBQVcsQ0FBVTtJQUNyQixjQUFjLENBQVU7SUFFaEMscUJBQXFCO0lBQ2IsZ0JBQWdCLEdBQVcsQ0FBQyxDQUFDO0lBQzdCLFlBQVksR0FBOEMsRUFBRSxDQUFDO0lBRXJFLHdCQUF3QjtJQUNoQixlQUFlLENBQTBCO0lBQ3pDLG1CQUFtQixDQUF1QjtJQUMxQyxnQkFBZ0IsQ0FBMkI7SUFFbkQsWUFBWSxNQUE0QjtRQUN0QyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUN2QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxrQkFBa0IsQ0FBQyxPQUErQjtRQUNoRCxJQUFJLENBQUMsZUFBZSxHQUFHLE9BQU8sQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxzQkFBc0IsQ0FBQyxPQUE0QjtRQUNqRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsT0FBTyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7T0FFRztJQUNILG1CQUFtQixDQUFDLFdBQW9DO1FBQ3RELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxXQUFXLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILG1CQUFtQixDQUFDLE1BQWM7UUFDaEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRDs7T0FFRztJQUNILG1CQUFtQjtRQUNqQixPQUFPLElBQUksQ0FBQyxnQkFBZ0Is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LGNBQWMsRUFDakMsQ0FBQztZQUNELHlDQUF5QztZQUN6QyxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztZQUNwQixJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQztZQUM3QixJQUFJLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztZQUMvQixJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQztZQUM3QixJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQztRQUNsQyxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBeFlELHdDQXdZQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvaXZhbi9Db2RlL3RyYWRpbmcvdGl0YW4vc2VydmljZXMvdGl0YW4tYnJhaW4vc3JjL2VuZ2luZS9DaXJjdWl0QnJlYWtlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENpcmN1aXRCcmVha2VyIC0gRW1lcmdlbmN5IGhhbHQgc3lzdGVtIGZvciBUaXRhbiBCcmFpblxuICogTW9uaXRvcnMgZm9yIGV4dHJlbWUgY29uZGl0aW9ucyBhbmQgdHJpZ2dlcnMgZW1lcmdlbmN5IGhhbHQgd2hlbiB0aHJlc2hvbGRzIGFyZSBicmVhY2hlZFxuICogXG4gKiBSZXF1aXJlbWVudHM6IDUuMSwgNS4yLCA1LjMsIDUuNCwgNS41LCA1LjhcbiAqL1xuXG5pbXBvcnQge1xuICBCcmVha2VyVHlwZSxcbiAgQnJlYWtlclN0YXR1cyxcbiAgQnJlYWtlckV2ZW50LFxuICBDaXJjdWl0QnJlYWtlckNvbmZpZyxcbiAgQnJlYWtlckNoZWNrSW5wdXQsXG4gIFBvc2l0aW9uLFxufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBwb3NpdGlvbiBjbG9zdXJlIGNhbGxiYWNrXG4gKiBBbGxvd3MgZXh0ZXJuYWwgc3lzdGVtcyB0byBoYW5kbGUgcG9zaXRpb24gY2xvc3VyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBvc2l0aW9uQ2xvc3VyZUhhbmRsZXIge1xuICBjbG9zZUFsbFBvc2l0aW9ucygpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3Igbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gKiBBbGxvd3MgZXh0ZXJuYWwgc3lzdGVtcyB0byBzZW5kIGVtZXJnZW5jeSBub3RpZmljYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uSGFuZGxlciB7XG4gIHNlbmRFbWVyZ2VuY3lOb3RpZmljYXRpb24ocmVhc29uOiBzdHJpbmcsIGVxdWl0eTogbnVtYmVyKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGV2ZW50IHBlcnNpc3RlbmNlXG4gKiBBbGxvd3MgZXh0ZXJuYWwgc3lzdGVtcyB0byBwZXJzaXN0IGJyZWFrZXIgZXZlbnRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnJlYWtlckV2ZW50UGVyc2lzdGVuY2Uge1xuICBwZXJzaXN0RXZlbnQoZXZlbnQ6IEJyZWFrZXJFdmVudCk6IFByb21pc2U8dm9pZD47XG59XG5cbi8qKlxuICogQ2lyY3VpdEJyZWFrZXIgbW9uaXRvcnMgZm9yIGV4dHJlbWUgY29uZGl0aW9ucyBhbmQgdHJpZ2dlcnNcbiAqIGVtZXJnZW5jeSBoYWx0IHdoZW4gdGhyZXNob2xkcyBhcmUgYnJlYWNoZWQuXG4gKiBcbiAqIFRyaWdnZXIgY29uZGl0aW9uczpcbiAqIC0gRGFpbHkgZHJhd2Rvd24gZXhjZWVkcyAxNSUgKEhBUkQpXG4gKiAtIEVxdWl0eSBkcm9wcyBiZWxvdyAkMTUwIChIQVJEKVxuICogLSAzIGNvbnNlY3V0aXZlIGxvc2luZyB0cmFkZXMgd2l0aGluIDEgaG91ciAoU09GVCAtIDMwIG1pbiBjb29sZG93bilcbiAqL1xuZXhwb3J0IGNsYXNzIENpcmN1aXRCcmVha2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IENpcmN1aXRCcmVha2VyQ29uZmlnO1xuICBcbiAgLyoqIEN1cnJlbnQgYnJlYWtlciBzdGF0ZSAqL1xuICBwcml2YXRlIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGJyZWFrZXJUeXBlPzogQnJlYWtlclR5cGU7XG4gIHByaXZhdGUgdHJpZ2dlclJlYXNvbj86IHN0cmluZztcbiAgcHJpdmF0ZSB0cmlnZ2VyZWRBdD86IG51bWJlcjtcbiAgcHJpdmF0ZSBjb29sZG93bkVuZHNBdD86IG51bWJlcjtcbiAgXG4gIC8qKiBUcmFja2luZyBzdGF0ZSAqL1xuICBwcml2YXRlIGRhaWx5U3RhcnRFcXVpdHk6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgcmVjZW50TG9zc2VzOiBBcnJheTx7IHBubDogbnVtYmVyOyB0aW1lc3RhbXA6IG51bWJlciB9PiA9IFtdO1xuICBcbiAgLyoqIEV4dGVybmFsIGhhbmRsZXJzICovXG4gIHByaXZhdGUgcG9zaXRpb25IYW5kbGVyPzogUG9zaXRpb25DbG9zdXJlSGFuZGxlcjtcbiAgcHJpdmF0ZSBub3RpZmljYXRpb25IYW5kbGVyPzogTm90aWZpY2F0aW9uSGFuZGxlcjtcbiAgcHJpdmF0ZSBldmVudFBlcnNpc3RlbmNlPzogQnJlYWtlckV2ZW50UGVyc2lzdGVuY2U7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBDaXJjdWl0QnJlYWtlckNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gY2xvc3VyZSBoYW5kbGVyXG4gICAqL1xuICBzZXRQb3NpdGlvbkhhbmRsZXIoaGFuZGxlcjogUG9zaXRpb25DbG9zdXJlSGFuZGxlcik6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb25IYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG5vdGlmaWNhdGlvbiBoYW5kbGVyXG4gICAqL1xuICBzZXROb3RpZmljYXRpb25IYW5kbGVyKGhhbmRsZXI6IE5vdGlmaWNhdGlvbkhhbmRsZXIpOiB2b2lkIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbkhhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXZlbnQgcGVyc2lzdGVuY2UgaGFuZGxlclxuICAgKi9cbiAgc2V0RXZlbnRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZTogQnJlYWtlckV2ZW50UGVyc2lzdGVuY2UpOiB2b2lkIHtcbiAgICB0aGlzLmV2ZW50UGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGFpbHkgc3RhcnQgZXF1aXR5IGZvciBkcmF3ZG93biBjYWxjdWxhdGlvblxuICAgKiBTaG91bGQgYmUgY2FsbGVkIGF0IHRoZSBzdGFydCBvZiBlYWNoIHRyYWRpbmcgZGF5XG4gICAqL1xuICBzZXREYWlseVN0YXJ0RXF1aXR5KGVxdWl0eTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5kYWlseVN0YXJ0RXF1aXR5ID0gTWF0aC5tYXgoMCwgZXF1aXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGFpbHkgc3RhcnQgZXF1aXR5XG4gICAqL1xuICBnZXREYWlseVN0YXJ0RXF1aXR5KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGFpbHlTdGFydEVxdWl0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBhbGwgYnJlYWtlciBjb25kaXRpb25zXG4gICAqIFxuICAgKiBAcGFyYW0gaW5wdXQgLSBCcmVha2VyIGNoZWNrIGlucHV0IHdpdGggZXF1aXR5LCBwb3NpdGlvbnMsIGFuZCB0cmFkZSBoaXN0b3J5XG4gICAqIEByZXR1cm5zIEN1cnJlbnQgYnJlYWtlciBzdGF0dXNcbiAgICovXG4gIGNoZWNrQ29uZGl0aW9ucyhpbnB1dDogQnJlYWtlckNoZWNrSW5wdXQpOiBCcmVha2VyU3RhdHVzIHtcbiAgICBjb25zdCB7IGVxdWl0eSwgcG9zaXRpb25zLCBkYWlseVN0YXJ0RXF1aXR5LCByZWNlbnRUcmFkZXMgfSA9IGlucHV0O1xuICAgIFxuICAgIC8vIFVwZGF0ZSBkYWlseSBzdGFydCBlcXVpdHkgaWYgcHJvdmlkZWRcbiAgICBpZiAoZGFpbHlTdGFydEVxdWl0eSA+IDApIHtcbiAgICAgIHRoaXMuZGFpbHlTdGFydEVxdWl0eSA9IGRhaWx5U3RhcnRFcXVpdHk7XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBkYWlseSBkcmF3ZG93blxuICAgIGNvbnN0IGRhaWx5RHJhd2Rvd24gPSB0aGlzLmNhbGN1bGF0ZURhaWx5RHJhd2Rvd24oZXF1aXR5KTtcbiAgICBcbiAgICAvLyBDb3VudCBjb25zZWN1dGl2ZSBsb3NzZXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvd1xuICAgIGNvbnN0IGNvbnNlY3V0aXZlTG9zc2VzID0gdGhpcy5jb3VudENvbnNlY3V0aXZlTG9zc2VzKHJlY2VudFRyYWRlcyk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHNvZnQgYnJlYWtlciBjb29sZG93biBleHBpcnlcbiAgICB0aGlzLmNoZWNrQ29vbGRvd25FeHBpcnkoKTtcbiAgICBcbiAgICAvLyBJZiBhbHJlYWR5IGFjdGl2ZSB3aXRoIEhBUkQgYnJlYWtlciwgbWFpbnRhaW4gc3RhdGVcbiAgICBpZiAodGhpcy5hY3RpdmUgJiYgdGhpcy5icmVha2VyVHlwZSA9PT0gQnJlYWtlclR5cGUuSEFSRCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlcXVpcmVtZW50IDUuMTogRGFpbHkgZHJhd2Rvd24gZXhjZWVkcyAxNSVcbiAgICBpZiAoZGFpbHlEcmF3ZG93biA+PSB0aGlzLmNvbmZpZy5tYXhEYWlseURyYXdkb3duKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoYERhaWx5IGRyYXdkb3duIGV4Y2VlZGVkOiAkeyhkYWlseURyYXdkb3duICogMTAwKS50b0ZpeGVkKDIpfSUgPj0gJHsodGhpcy5jb25maWcubWF4RGFpbHlEcmF3ZG93biAqIDEwMCkudG9GaXhlZCgwKX0lYCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdGF0dXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVxdWlyZW1lbnQgNS4yOiBFcXVpdHkgZHJvcHMgYmVsb3cgbWluaW11bVxuICAgIGlmIChlcXVpdHkgPCB0aGlzLmNvbmZpZy5taW5FcXVpdHkpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihgRXF1aXR5IGJlbG93IG1pbmltdW06ICQke2VxdWl0eS50b0ZpeGVkKDIpfSA8ICQke3RoaXMuY29uZmlnLm1pbkVxdWl0eX1gKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXR1cygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXF1aXJlbWVudCA1LjM6IENvbnNlY3V0aXZlIGxvc3NlcyAoc29mdCBwYXVzZSlcbiAgICBpZiAoY29uc2VjdXRpdmVMb3NzZXMgPj0gdGhpcy5jb25maWcuY29uc2VjdXRpdmVMb3NzTGltaXQgJiYgIXRoaXMuYWN0aXZlKSB7XG4gICAgICB0aGlzLnRyaWdnZXJTb2Z0UGF1c2UoYCR7Y29uc2VjdXRpdmVMb3NzZXN9IGNvbnNlY3V0aXZlIGxvc3NlcyB3aXRoaW4gJHt0aGlzLmNvbmZpZy5jb25zZWN1dGl2ZUxvc3NXaW5kb3cgLyA2MDAwMH0gbWludXRlc2ApO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBhY3RpdmU6IHRoaXMuYWN0aXZlLFxuICAgICAgdHlwZTogdGhpcy5icmVha2VyVHlwZSxcbiAgICAgIHJlYXNvbjogdGhpcy50cmlnZ2VyUmVhc29uLFxuICAgICAgdHJpZ2dlcmVkQXQ6IHRoaXMudHJpZ2dlcmVkQXQsXG4gICAgICBkYWlseURyYXdkb3duLFxuICAgICAgY29uc2VjdXRpdmVMb3NzZXMsXG4gICAgICBlcXVpdHlMZXZlbDogZXF1aXR5LFxuICAgICAgY29vbGRvd25FbmRzQXQ6IHRoaXMuY29vbGRvd25FbmRzQXQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBjaXJjdWl0IGJyZWFrZXIgKEhBUkQpXG4gICAqIFJlcXVpcmVtZW50IDUuNDogQ2xvc2UgYWxsIHBvc2l0aW9ucyBpbW1lZGlhdGVseVxuICAgKiBSZXF1aXJlbWVudCA1LjU6IFJlamVjdCBhbGwgbmV3IHNpZ25hbHMgdW50aWwgbWFudWFsIHJlc2V0XG4gICAqIFxuICAgKiBAcGFyYW0gcmVhc29uIC0gUmVhc29uIGZvciB0cmlnZ2VyaW5nXG4gICAqL1xuICBhc3luYyB0cmlnZ2VyKHJlYXNvbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gUmVxdWlyZW1lbnQgNS40OiBJZGVtcG90ZW5jZSAtIGRvbid0IGNyZWF0ZSBkdXBsaWNhdGUgZXZlbnRzXG4gICAgaWYgKHRoaXMuYWN0aXZlICYmIHRoaXMuYnJlYWtlclR5cGUgPT09IEJyZWFrZXJUeXBlLkhBUkQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5icmVha2VyVHlwZSA9IEJyZWFrZXJUeXBlLkhBUkQ7XG4gICAgdGhpcy50cmlnZ2VyUmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMudHJpZ2dlcmVkQXQgPSB0aW1lc3RhbXA7XG4gICAgdGhpcy5jb29sZG93bkVuZHNBdCA9IHVuZGVmaW5lZDtcbiAgICBcbiAgICAvLyBSZXF1aXJlbWVudCA1LjQ6IENsb3NlIGFsbCBvcGVuIHBvc2l0aW9ucyBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLnBvc2l0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wb3NpdGlvbkhhbmRsZXIuY2xvc2VBbGxQb3NpdGlvbnMoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgcHJldmVudCBicmVha2VyIGFjdGl2YXRpb25cbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNsb3NlIHBvc2l0aW9ucyBkdXJpbmcgY2lyY3VpdCBicmVha2VyIHRyaWdnZXI6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSZXF1aXJlbWVudCA1LjY6IFNlbmQgZW1lcmdlbmN5IG5vdGlmaWNhdGlvbnNcbiAgICBpZiAodGhpcy5ub3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLm5vdGlmaWNhdGlvbkhhbmRsZXIuc2VuZEVtZXJnZW5jeU5vdGlmaWNhdGlvbihyZWFzb24sIHRoaXMuZGFpbHlTdGFydEVxdWl0eSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VuZCBlbWVyZ2VuY3kgbm90aWZpY2F0aW9uOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmVxdWlyZW1lbnQgNS43OiBMb2cgdGhlIGV2ZW50XG4gICAgY29uc3QgZXZlbnQ6IEJyZWFrZXJFdmVudCA9IHtcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIGV2ZW50VHlwZTogJ1RSSUdHRVInLFxuICAgICAgYnJlYWtlclR5cGU6IEJyZWFrZXJUeXBlLkhBUkQsXG4gICAgICByZWFzb24sXG4gICAgICBlcXVpdHk6IHRoaXMuZGFpbHlTdGFydEVxdWl0eSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIGRhaWx5RHJhd2Rvd246IHRoaXMuY2FsY3VsYXRlRGFpbHlEcmF3ZG93bih0aGlzLmRhaWx5U3RhcnRFcXVpdHkpLFxuICAgICAgfSxcbiAgICB9O1xuICAgIFxuICAgIGlmICh0aGlzLmV2ZW50UGVyc2lzdGVuY2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXZlbnRQZXJzaXN0ZW5jZS5wZXJzaXN0RXZlbnQoZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBlcnNpc3QgYnJlYWtlciBldmVudDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBzb2Z0IHBhdXNlIChjb29sZG93biBwZXJpb2QpXG4gICAqIFJlcXVpcmVtZW50IDUuMzogMzAgbWludXRlIGNvb2xkb3duIGZvciBjb25zZWN1dGl2ZSBsb3NzZXNcbiAgICogXG4gICAqIEBwYXJhbSByZWFzb24gLSBSZWFzb24gZm9yIHNvZnQgcGF1c2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdHJpZ2dlclNvZnRQYXVzZShyZWFzb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIERvbid0IGRvd25ncmFkZSBmcm9tIEhBUkQgdG8gU09GVFxuICAgIGlmICh0aGlzLmFjdGl2ZSAmJiB0aGlzLmJyZWFrZXJUeXBlID09PSBCcmVha2VyVHlwZS5IQVJEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIElkZW1wb3RlbmNlIGZvciBTT0ZUIGJyZWFrZXJcbiAgICBpZiAodGhpcy5hY3RpdmUgJiYgdGhpcy5icmVha2VyVHlwZSA9PT0gQnJlYWtlclR5cGUuU09GVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmJyZWFrZXJUeXBlID0gQnJlYWtlclR5cGUuU09GVDtcbiAgICB0aGlzLnRyaWdnZXJSZWFzb24gPSByZWFzb247XG4gICAgdGhpcy50cmlnZ2VyZWRBdCA9IHRpbWVzdGFtcDtcbiAgICB0aGlzLmNvb2xkb3duRW5kc0F0ID0gdGltZXN0YW1wICsgKHRoaXMuY29uZmlnLmNvb2xkb3duTWludXRlcyAqIDYwICogMTAwMCk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSBldmVudFxuICAgIGNvbnN0IGV2ZW50OiBCcmVha2VyRXZlbnQgPSB7XG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBldmVudFR5cGU6ICdUUklHR0VSJyxcbiAgICAgIGJyZWFrZXJUeXBlOiBCcmVha2VyVHlwZS5TT0ZULFxuICAgICAgcmVhc29uLFxuICAgICAgZXF1aXR5OiB0aGlzLmRhaWx5U3RhcnRFcXVpdHksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBjb29sZG93bk1pbnV0ZXM6IHRoaXMuY29uZmlnLmNvb2xkb3duTWludXRlcyxcbiAgICAgICAgY29vbGRvd25FbmRzQXQ6IHRoaXMuY29vbGRvd25FbmRzQXQsXG4gICAgICB9LFxuICAgIH07XG4gICAgXG4gICAgaWYgKHRoaXMuZXZlbnRQZXJzaXN0ZW5jZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5ldmVudFBlcnNpc3RlbmNlLnBlcnNpc3RFdmVudChldmVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGVyc2lzdCBzb2Z0IHBhdXNlIGV2ZW50OicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIGNpcmN1aXQgYnJlYWtlciAobWFudWFsIHJlc2V0KVxuICAgKiBSZXF1aXJlbWVudCA1Ljg6IFJlcXVpcmUgY29uZmlybWF0aW9uIGFuZCBsb2cgb3BlcmF0b3IgaWRlbnRpdHlcbiAgICogXG4gICAqIEBwYXJhbSBvcGVyYXRvcklkIC0gSUQgb2YgdGhlIG9wZXJhdG9yIHBlcmZvcm1pbmcgdGhlIHJlc2V0XG4gICAqL1xuICBhc3luYyByZXNldChvcGVyYXRvcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICghb3BlcmF0b3JJZCB8fCBvcGVyYXRvcklkLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0b3IgSUQgaXMgcmVxdWlyZWQgZm9yIGNpcmN1aXQgYnJlYWtlciByZXNldCcpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHByZXZpb3VzUmVhc29uID0gdGhpcy50cmlnZ2VyUmVhc29uO1xuICAgIGNvbnN0IHByZXZpb3VzVHlwZSA9IHRoaXMuYnJlYWtlclR5cGU7XG4gICAgXG4gICAgLy8gUmVzZXQgc3RhdGVcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuYnJlYWtlclR5cGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50cmlnZ2VyUmVhc29uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudHJpZ2dlcmVkQXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb29sZG93bkVuZHNBdCA9IHVuZGVmaW5lZDtcbiAgICBcbiAgICAvLyBSZXF1aXJlbWVudCA1Ljg6IExvZyB0aGUgcmVzZXQgd2l0aCBvcGVyYXRvciBpZGVudGl0eVxuICAgIGNvbnN0IGV2ZW50OiBCcmVha2VyRXZlbnQgPSB7XG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBldmVudFR5cGU6ICdSRVNFVCcsXG4gICAgICByZWFzb246IGBNYW51YWwgcmVzZXQgYnkgb3BlcmF0b3I6ICR7b3BlcmF0b3JJZH1gLFxuICAgICAgZXF1aXR5OiB0aGlzLmRhaWx5U3RhcnRFcXVpdHksXG4gICAgICBvcGVyYXRvcklkLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgcHJldmlvdXNSZWFzb24sXG4gICAgICAgIHByZXZpb3VzVHlwZSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBcbiAgICBpZiAodGhpcy5ldmVudFBlcnNpc3RlbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmV2ZW50UGVyc2lzdGVuY2UucGVyc2lzdEV2ZW50KGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwZXJzaXN0IHJlc2V0IGV2ZW50OicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgY2lyY3VpdCBicmVha2VyIGlzIGFjdGl2ZVxuICAgKiBSZXF1aXJlbWVudCA1LjU6IFJlamVjdCBhbGwgbmV3IHNpZ25hbHMgdW50aWwgbWFudWFsIHJlc2V0XG4gICAqL1xuICBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBmb3Igc29mdCBicmVha2VyIGNvb2xkb3duIGV4cGlyeVxuICAgIHRoaXMuY2hlY2tDb29sZG93bkV4cGlyeSgpO1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBicmVha2VyIHN0YXR1c1xuICAgKi9cbiAgZ2V0U3RhdHVzKCk6IEJyZWFrZXJTdGF0dXMge1xuICAgIC8vIENoZWNrIGZvciBzb2Z0IGJyZWFrZXIgY29vbGRvd24gZXhwaXJ5XG4gICAgdGhpcy5jaGVja0Nvb2xkb3duRXhwaXJ5KCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZTogdGhpcy5hY3RpdmUsXG4gICAgICB0eXBlOiB0aGlzLmJyZWFrZXJUeXBlLFxuICAgICAgcmVhc29uOiB0aGlzLnRyaWdnZXJSZWFzb24sXG4gICAgICB0cmlnZ2VyZWRBdDogdGhpcy50cmlnZ2VyZWRBdCxcbiAgICAgIGRhaWx5RHJhd2Rvd246IHRoaXMuY2FsY3VsYXRlRGFpbHlEcmF3ZG93bih0aGlzLmRhaWx5U3RhcnRFcXVpdHkpLFxuICAgICAgY29uc2VjdXRpdmVMb3NzZXM6IHRoaXMucmVjZW50TG9zc2VzLmxlbmd0aCxcbiAgICAgIGVxdWl0eUxldmVsOiB0aGlzLmRhaWx5U3RhcnRFcXVpdHksXG4gICAgICBjb29sZG93bkVuZHNBdDogdGhpcy5jb29sZG93bkVuZHNBdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCBhIHRyYWRlIHJlc3VsdCBmb3IgY29uc2VjdXRpdmUgbG9zcyB0cmFja2luZ1xuICAgKiBcbiAgICogQHBhcmFtIHBubCAtIFRyYWRlIFBuTCAocG9zaXRpdmUgPSBwcm9maXQsIG5lZ2F0aXZlID0gbG9zcylcbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIFRyYWRlIHRpbWVzdGFtcFxuICAgKi9cbiAgcmVjb3JkVHJhZGUocG5sOiBudW1iZXIsIHRpbWVzdGFtcD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYWRlVGltZSA9IHRpbWVzdGFtcCA/PyBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIEFkZCB0byByZWNlbnQgbG9zc2VzIHRyYWNraW5nXG4gICAgdGhpcy5yZWNlbnRMb3NzZXMucHVzaCh7IHBubCwgdGltZXN0YW1wOiB0cmFkZVRpbWUgfSk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb2xkIHRyYWRlcyBvdXRzaWRlIHRoZSB3aW5kb3dcbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IHRyYWRlVGltZSAtIHRoaXMuY29uZmlnLmNvbnNlY3V0aXZlTG9zc1dpbmRvdztcbiAgICB0aGlzLnJlY2VudExvc3NlcyA9IHRoaXMucmVjZW50TG9zc2VzLmZpbHRlcih0ID0+IHQudGltZXN0YW1wID49IHdpbmRvd1N0YXJ0KTtcbiAgICBcbiAgICAvLyBJZiBwcm9maXRhYmxlIHRyYWRlLCByZXNldCBjb25zZWN1dGl2ZSBsb3NzIGNvdW50ZXJcbiAgICBpZiAocG5sID49IDApIHtcbiAgICAgIHRoaXMucmVjZW50TG9zc2VzID0gdGhpcy5yZWNlbnRMb3NzZXMuZmlsdGVyKHQgPT4gdC5wbmwgPCAwICYmIHQudGltZXN0YW1wID4gdHJhZGVUaW1lIC0gdGhpcy5jb25maWcuY29uc2VjdXRpdmVMb3NzV2luZG93KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldENvbmZpZygpOiBDaXJjdWl0QnJlYWtlckNvbmZpZyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PSBQcml2YXRlIEhlbHBlciBNZXRob2RzID09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZGFpbHkgZHJhd2Rvd24gcGVyY2VudGFnZVxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVEYWlseURyYXdkb3duKGN1cnJlbnRFcXVpdHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuZGFpbHlTdGFydEVxdWl0eSA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZHJhd2Rvd24gPSAodGhpcy5kYWlseVN0YXJ0RXF1aXR5IC0gY3VycmVudEVxdWl0eSkgLyB0aGlzLmRhaWx5U3RhcnRFcXVpdHk7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGRyYXdkb3duKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudCBjb25zZWN1dGl2ZSBsb3NzZXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvd1xuICAgKi9cbiAgcHJpdmF0ZSBjb3VudENvbnNlY3V0aXZlTG9zc2VzKHJlY2VudFRyYWRlczogQXJyYXk8eyBwbmw6IG51bWJlcjsgdGltZXN0YW1wOiBudW1iZXIgfT4pOiBudW1iZXIge1xuICAgIGlmIChyZWNlbnRUcmFkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IG5vdyAtIHRoaXMuY29uZmlnLmNvbnNlY3V0aXZlTG9zc1dpbmRvdztcbiAgICBcbiAgICAvLyBGaWx0ZXIgdHJhZGVzIHdpdGhpbiB0aGUgd2luZG93IGFuZCBzb3J0IGJ5IHRpbWVzdGFtcCAobW9zdCByZWNlbnQgZmlyc3QpXG4gICAgY29uc3QgdHJhZGVzSW5XaW5kb3cgPSByZWNlbnRUcmFkZXNcbiAgICAgIC5maWx0ZXIodCA9PiB0LnRpbWVzdGFtcCA+PSB3aW5kb3dTdGFydClcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcCAtIGEudGltZXN0YW1wKTtcbiAgICBcbiAgICAvLyBDb3VudCBjb25zZWN1dGl2ZSBsb3NzZXMgZnJvbSBtb3N0IHJlY2VudFxuICAgIGxldCBjb25zZWN1dGl2ZUxvc3NlcyA9IDA7XG4gICAgZm9yIChjb25zdCB0cmFkZSBvZiB0cmFkZXNJbldpbmRvdykge1xuICAgICAgaWYgKHRyYWRlLnBubCA8IDApIHtcbiAgICAgICAgY29uc2VjdXRpdmVMb3NzZXMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrOyAvLyBTdG9wIGNvdW50aW5nIGF0IGZpcnN0IHByb2ZpdGFibGUgdHJhZGVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbnNlY3V0aXZlTG9zc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNvZnQgYnJlYWtlciBjb29sZG93biBoYXMgZXhwaXJlZFxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0Nvb2xkb3duRXhwaXJ5KCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIHRoaXMuYWN0aXZlICYmXG4gICAgICB0aGlzLmJyZWFrZXJUeXBlID09PSBCcmVha2VyVHlwZS5TT0ZUICYmXG4gICAgICB0aGlzLmNvb2xkb3duRW5kc0F0ICYmXG4gICAgICBEYXRlLm5vdygpID49IHRoaXMuY29vbGRvd25FbmRzQXRcbiAgICApIHtcbiAgICAgIC8vIEF1dG8tcmVzZXQgc29mdCBicmVha2VyIGFmdGVyIGNvb2xkb3duXG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5icmVha2VyVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudHJpZ2dlclJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudHJpZ2dlcmVkQXQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmNvb2xkb3duRW5kc0F0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuIl0sInZlcnNpb24iOjN9