use rust_decimal_macros::dec;
use titan_execution_rs::risk_policy::RiskPolicy;

#[test]
fn test_risk_policy_compatibility() {
    // 1. Simulate JSON generated by @titan/shared RiskPolicySchemaV1 (camelCase)
    let json_payload = r#"{
        "maxAccountLeverage": 20.0,
        "maxPositionNotional": 100000.0,
        "maxDailyLoss": -5000.0,
        "maxOpenOrdersPerSymbol": 10,
        "symbolWhitelist": ["BTC/USDT", "ETH/USDT"],
        "maxSlippageBps": 200,
        "maxStalenessMs": 5000,
        "maxCorrelation": 0.75,
        "correlationPenalty": 0.5,
        "minConfidenceScore": 0.8,
        "minStopDistanceMultiplier": 2.0,
        "version": 1,
        "lastUpdated": 1700000000000
    }"#;

    // 2. Deserialize into Rust Struct
    let policy: RiskPolicy =
        serde_json::from_str(json_payload).expect("Failed to deserialize RiskPolicy V1");

    // 3. Assert values match
    assert_eq!(policy.max_account_leverage, dec!(20.0));
    assert_eq!(policy.max_position_notional, dec!(100000.0));
    assert_eq!(policy.max_daily_loss, dec!(-5000.0));
    assert_eq!(policy.max_open_orders_per_symbol, 10);
    assert!(policy.symbol_whitelist.contains("BTC/USDT"));
    assert!(policy.symbol_whitelist.contains("ETH/USDT"));
    assert_eq!(policy.max_slippage_bps, 200);

    // Check new fields
    assert_eq!(policy.max_correlation, dec!(0.75));
    assert_eq!(policy.correlation_penalty, dec!(0.5));
    assert_eq!(policy.min_confidence_score, dec!(0.8));
    assert_eq!(policy.min_stop_distance_multiplier, dec!(2.0));
    assert_eq!(policy.version, 1);
    assert_eq!(policy.last_updated, 1700000000000);

    println!("âœ… Risk Policy V1 Compatibility Verified");
}
